{"version":3,"sources":["../src/connectors/burner.ts","../src/constants/index.ts","../src/context/burnerProvider.tsx","../src/hooks/useBurner.ts","../src/manager/burnerManager.ts","../src/utils/storage.ts","../src/manager/prefundAccount.ts","../src/hooks/useBurnerManager.ts"],"sourcesContent":["import { AccountInterface, Account } from \"starknet\";\nimport { Connector } from \"@starknet-react/core\";\n\n/*  \n    This is a custom connector to use within Starknet React.\n*/\n\nexport class BurnerConnector extends Connector {\n    private _account: AccountInterface | Account | null;\n    public _name: string = \"Burner Connector\";\n\n    // Use the \"options\" type as per your need. Here, I am assuming it to be an object.\n    constructor(options: object, account: AccountInterface | Account | null) {\n        super({ options });\n        this._account = account;\n    }\n\n    available(): boolean {\n        // Implement your logic here.\n        return true;\n    }\n\n    async ready(): Promise<boolean> {\n        // Implement your logic here.\n        return true;\n    }\n\n    async connect(): Promise<AccountInterface> {\n        if (!this._account) {\n            throw new Error(\"account not found\");\n        }\n        return Promise.resolve(this._account);\n    }\n\n    async disconnect(): Promise<void> {\n        Promise.resolve(this._account == null);\n    }\n\n    async initEventListener(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    async removeEventListener(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    async account(): Promise<AccountInterface | null> {\n        return Promise.resolve(this._account);\n    }\n\n    get id(): string {\n        return this._account?.address.toString() || \"Burner Account\";\n    }\n\n    get name(): string {\n        return this._name;\n    }\n\n    get icon(): string {\n        return \"my-icon-url\";\n    }\n}\n","export const OPENZEPPELIN_ACCOUNT_GOERLI =\n    \"0x2f318C334780961FB129D2a6c30D0763d9a5C970\";\nexport const PREFUND_AMOUNT = \"0x2386f26fc10000\"; // 0.001ETH\nexport const KATANA_ETH_CONTRACT_ADDRESS =\n    \"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\";\nexport const KATANA_ACCOUNT_CLASS_HASH =\n    \"0x04d07e40e93398ed3c76981e72dd1fd22557a78ce36c0515f679e27f0bb5bc5f\";\n","import { ReactNode, createContext } from \"react\";\nimport { BurnerManagerOptions } from \"../types\";\n\nexport const BurnerContext = createContext<BurnerManagerOptions | null>(null);\n\ninterface BurnerProviderProps {\n    children: ReactNode;\n    initOptions: BurnerManagerOptions;\n}\n\nexport const BurnerProvider = ({\n    children,\n    initOptions,\n}: BurnerProviderProps): JSX.Element => {\n    return (\n        <BurnerContext.Provider value={initOptions}>\n            {children}\n        </BurnerContext.Provider>\n    );\n};\n","import { useCallback, useContext, useEffect, useMemo, useState } from \"react\";\nimport { Account } from \"starknet\";\nimport { BurnerConnector } from \"..\";\nimport { BurnerContext } from \"../context\";\nimport { BurnerManager } from \"../manager/burnerManager\";\nimport { Burner } from \"../types\";\n\n/**\n * A React hook to manage Burner accounts.\n * Provides utility methods like get, list, select, and create.\n *\n * @returns An object with utility methods and properties.\n */\nexport const useBurner = () => {\n    const initParams = useContext(BurnerContext);\n\n    if (!initParams) {\n        throw new Error(\"useBurner must be used within a BurnerProvider\");\n    }\n\n    // Initialize the BurnerManager with the provided options.\n    const burnerManager = useMemo(\n        () => new BurnerManager(initParams),\n        [initParams]\n    );\n\n    // State to manage the current active account.\n    const [account, setAccount] = useState<Account | null>(null);\n\n    const [burnerUpdate, setBurnerUpdate] = useState(0);\n\n    const [isDeploying, setIsDeploying] = useState(false);\n\n    // On mount, initialize the burner manager and set the active account.\n    useEffect(() => {\n        burnerManager.init();\n        setAccount(burnerManager.getActiveAccount());\n    }, []);\n\n    /**\n     * Lists all the burners available in the storage.\n     *\n     * @returns An array of Burner accounts.\n     */\n    const list = useCallback((): Burner[] => {\n        return burnerManager.list();\n    }, [burnerManager.list(), burnerUpdate]);\n\n    /**\n     * Selects and sets a burner as the active account.\n     *\n     * @param address - The address of the burner account to set as active.\n     */\n    const select = useCallback(\n        (address: string): void => {\n            burnerManager.select(address);\n            setAccount(burnerManager.getActiveAccount());\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Retrieves a burner account based on its address.\n     *\n     * @param address - The address of the burner account to retrieve.\n     * @returns The Burner account corresponding to the provided address.\n     */\n    const get = useCallback(\n        (address: string): Account => {\n            return burnerManager.get(address);\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Clears a burner account based on its address.\n     *\n     * @param address - The address of the burner account to retrieve.\n     * @returns The Burner account corresponding to the provided address.\n     */\n    const clear = useCallback(() => {\n        burnerManager.clear();\n        setBurnerUpdate((prev) => prev + 1);\n    }, [burnerManager]);\n\n    /**\n     * Creates a new burner account and sets it as the active account.\n     *\n     * @returns A promise that resolves to the newly created Burner account.\n     */\n    const create = useCallback(async (): Promise<Account> => {\n        burnerManager.setIsDeployingCallback(setIsDeploying);\n        const newAccount = await burnerManager.create();\n        setAccount(newAccount);\n        return newAccount;\n    }, [burnerManager]);\n\n    /**\n     * Generates a list of BurnerConnector instances for each burner account. These can be added to Starknet React.\n     *\n     * @returns An array of BurnerConnector instances.\n     */\n    const listConnectors = useCallback((): BurnerConnector[] => {\n        // Retrieve all the burners.\n        const burners = list();\n\n        // Map each burner to its respective BurnerConnector instance.\n        return burners.map((burner) => {\n            return new BurnerConnector(\n                {\n                    options: {\n                        id: burner.address,\n                    },\n                },\n                get(burner.address)\n            );\n        });\n    }, [burnerManager.isDeploying]);\n\n    /**\n     * Copy burners to clipboard\n     */\n    const copyToClipboard = useCallback(async () => {\n        await burnerManager.copyBurnersToClipboard();\n    }, [burnerManager]);\n\n    /**\n     * Set burners from clipboard\n     */\n    const applyFromClipboard = useCallback(async () => {\n        await burnerManager.setBurnersFromClipboard();\n        setAccount(burnerManager.getActiveAccount()); // set the active account\n        setBurnerUpdate((prev) => prev + 1); // re-fetch of the list\n    }, [burnerManager]);\n\n    // Expose methods and properties for the consumers of this hook.\n    return {\n        get,\n        list,\n        select,\n        create,\n        listConnectors,\n        clear,\n        account,\n        isDeploying,\n        copyToClipboard,\n        applyFromClipboard,\n    };\n};\n","import { Account, CallData, ec, hash, RpcProvider, stark } from \"starknet\";\nimport { Burner, BurnerManagerOptions, BurnerStorage } from \"../types\";\nimport Storage from \"../utils/storage\";\nimport { prefundAccount } from \"./prefundAccount\";\n\nexport class BurnerManager {\n    public masterAccount: Account;\n    public accountClassHash: string;\n    public provider: RpcProvider;\n\n    public account: Account | null = null;\n    public isDeploying: boolean = false;\n    public burnerAccounts: Burner[] = [];\n\n    private setIsDeploying?: (isDeploying: boolean) => void;\n\n    constructor({\n        masterAccount,\n        accountClassHash,\n        rpcProvider,\n    }: BurnerManagerOptions) {\n        this.masterAccount = masterAccount;\n        this.accountClassHash = accountClassHash;\n        this.provider = rpcProvider;\n    }\n\n    public setIsDeployingCallback(\n        callback: (isDeploying: boolean) => void\n    ): void {\n        this.setIsDeploying = callback;\n    }\n\n    private updateIsDeploying(status: boolean) {\n        this.isDeploying = status;\n        if (this.setIsDeploying) {\n            this.setIsDeploying(status);\n        }\n    }\n\n    private getBurnerStorage(): BurnerStorage {\n        return Storage.get(\"burners\") || {};\n    }\n\n    private setActiveBurnerAccount(storage: BurnerStorage): void {\n        for (let address in storage) {\n            if (storage[address].active) {\n                this.account = new Account(\n                    this.provider,\n                    address,\n                    storage[address].privateKey\n                );\n                return;\n            }\n        }\n    }\n\n    public init(): void {\n        const storage = this.getBurnerStorage();\n\n        if (Object.keys(storage).length > 0) {\n            const firstAddr = Object.keys(storage)[0];\n            this.masterAccount\n                ?.getTransactionReceipt(storage[firstAddr].deployTx)\n                .then((response) => {\n                    if (!response) {\n                        this.account = null;\n                        Storage.remove(\"burners\");\n                        throw new Error(\n                            \"Burners not deployed, chain may have restarted\"\n                        );\n                    }\n                })\n                .catch(() => {\n                    throw new Error(\"Error fetching transaction receipt\");\n                });\n\n            this.setActiveBurnerAccount(storage);\n        }\n    }\n\n    public list(): Burner[] {\n        const storage = this.getBurnerStorage();\n        return Object.keys(storage).map((address) => {\n            return {\n                address,\n                active: storage[address].active,\n            };\n        });\n    }\n\n    public select(address: string): void {\n        const storage = this.getBurnerStorage();\n        if (!storage[address]) {\n            throw new Error(\"burner not found\");\n        }\n\n        for (let addr in storage) {\n            storage[addr].active = false;\n        }\n        storage[address].active = true;\n\n        Storage.set(\"burners\", storage);\n        this.account = new Account(\n            this.provider,\n            address,\n            storage[address].privateKey\n        );\n    }\n\n    public get(address: string): Account {\n        const storage = this.getBurnerStorage();\n        if (!storage[address]) {\n            throw new Error(\"burner not found\");\n        }\n\n        return new Account(this.provider, address, storage[address].privateKey);\n    }\n\n    clear(): void {\n        Storage.clear();\n    }\n\n    getActiveAccount(): Account | null {\n        const storage = this.getBurnerStorage();\n        for (let address in storage) {\n            if (storage[address].active) {\n                return new Account(\n                    this.provider,\n                    address,\n                    storage[address].privateKey\n                );\n            }\n        }\n        return null;\n    }\n\n    public async create(): Promise<Account> {\n        this.updateIsDeploying(true);\n\n        const privateKey = stark.randomAddress();\n        const publicKey = ec.starkCurve.getStarkKey(privateKey);\n        const address = hash.calculateContractAddressFromHash(\n            publicKey,\n            this.accountClassHash,\n            CallData.compile({ publicKey }),\n            0\n        );\n\n        if (!this.masterAccount) {\n            throw new Error(\"wallet account not found\");\n        }\n\n        try {\n            await prefundAccount(address, this.masterAccount);\n        } catch (e) {\n            this.isDeploying = false;\n        }\n\n        const accountOptions = {\n            classHash: this.accountClassHash,\n            constructorCalldata: CallData.compile({ publicKey }),\n            addressSalt: publicKey,\n        };\n\n        // deploy burner\n        const burner = new Account(this.provider, address, privateKey);\n\n        const nonce = await this.account?.getNonce();\n\n        const { transaction_hash: deployTx } = await burner.deployAccount(\n            accountOptions,\n            {\n                nonce,\n                maxFee: 0, // TODO: update\n            }\n        );\n\n        const storage = this.getBurnerStorage();\n        for (let address in storage) {\n            storage[address].active = false;\n        }\n\n        storage[address] = {\n            privateKey,\n            publicKey,\n            deployTx,\n            active: true,\n        };\n\n        this.account = burner;\n        this.updateIsDeploying(false);\n        Storage.set(\"burners\", storage);\n\n        return burner;\n    }\n\n    public async copyBurnersToClipboard(): Promise<void> {\n        const burners = this.getBurnerStorage();\n        try {\n            await navigator.clipboard.writeText(JSON.stringify(burners));\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    public async setBurnersFromClipboard(): Promise<void> {\n        try {\n            const text = await navigator.clipboard.readText();\n            const burners: BurnerStorage = JSON.parse(text);\n\n            // Assume no burner is active\n            let activeAddress = null;\n\n            // Iterate over the pasted burners to find the active one\n            for (const [address, burner] of Object.entries(burners)) {\n                if (burner.active) {\n                    activeAddress = address;\n                    break;\n                }\n            }\n\n            Storage.set(\"burners\", burners);\n\n            // If there's an active burner, select it\n            if (activeAddress) {\n                this.select(activeAddress);\n            }\n        } catch (error) {\n            throw error;\n        }\n    }\n}\n","import Cookies from \"js-cookie\";\n\nconst hasLocalStorageSupport = (): boolean => {\n    try {\n        const testKey = \"__test__\";\n        if (typeof window !== \"undefined\") {\n            window.localStorage.setItem(testKey, testKey);\n            window.localStorage.removeItem(testKey);\n            return true;\n        }\n    } catch (e) {\n        return false;\n    }\n    return false;\n};\n\nconst isLocalStorage = hasLocalStorageSupport();\n\nconst safeParse = (data: string): any => {\n    try {\n        if (data === \"\") return null;\n        return JSON.parse(data);\n    } catch (e) {\n        console.error(\"Error parsing JSON data:\", e, \"Data:\", data);\n        return null;\n    }\n};\n\nconst Storage = {\n    keys: (): string[] => {\n        if (isLocalStorage) {\n            return Object.keys(window.localStorage);\n        }\n        return Object.keys(Cookies.get());\n    },\n\n    get: (key: string): any => {\n        if (isLocalStorage) {\n            return safeParse(window.localStorage.getItem(key) || \"\");\n        }\n        return safeParse(Cookies.get(key) || \"\");\n    },\n\n    set: (key: string, value: any): void => {\n        const data = JSON.stringify(value);\n        if (isLocalStorage) {\n            window.localStorage.setItem(key, data);\n        } else {\n            Cookies.set(key, data, {\n                secure: true,\n                sameSite: \"strict\",\n            });\n        }\n    },\n\n    remove: (key: string): void => {\n        if (isLocalStorage) {\n            window.localStorage.removeItem(key);\n        } else {\n            Cookies.remove(key);\n        }\n    },\n\n    clear: (): void => {\n        if (isLocalStorage) {\n            window.localStorage.clear();\n        } else {\n            const cookies = Cookies.get();\n            Object.keys(cookies).forEach((key) => Cookies.remove(key));\n        }\n    },\n};\n\nexport default Storage;\n","import {\n    AccountInterface,\n    CallData,\n    TransactionFinalityStatus,\n} from \"starknet\";\nimport { KATANA_ETH_CONTRACT_ADDRESS, PREFUND_AMOUNT } from \"..\";\n\n/**\n * Pre-funds a given account by initiating a transfer transaction.\n *\n * @param address - The destination address to which funds are to be transferred.\n * @param account - The source account from which funds will be deducted.\n * @param ethContractAddress - The Ethereum contract address responsible for the transfer.\n *                             If not provided, defaults to KATANA_ETH_CONTRACT_ADDRESS.\n *\n * @returns - Returns the result of the transfer transaction, typically including transaction details.\n *\n * @throws - Throws an error if the transaction does not complete successfully.\n */\nexport const prefundAccount = async (\n    address: string,\n    account: AccountInterface,\n    ethContractAddress: string = KATANA_ETH_CONTRACT_ADDRESS\n): Promise<any> => {\n    try {\n        // Configure the options for the transfer transaction\n        const transferOptions = {\n            contractAddress: ethContractAddress,\n            entrypoint: \"transfer\",\n            calldata: CallData.compile([address, PREFUND_AMOUNT, \"0x0\"]),\n        };\n\n        // Retrieve the nonce for the account to avoid transaction collisions\n        const nonce = await account.getNonce();\n\n        // Initiate the transaction\n        const { transaction_hash } = await account.execute(\n            transferOptions,\n            undefined,\n            {\n                nonce,\n                maxFee: 0, // This is set to 0 for now, consider adjusting it based on network conditions or requirements.\n            }\n        );\n\n        // Wait for the transaction to complete and check its status\n        const result = await account.waitForTransaction(transaction_hash, {\n            retryInterval: 1000,\n            successStates: [TransactionFinalityStatus.ACCEPTED_ON_L2],\n        });\n\n        if (!result) {\n            throw new Error(\"Transaction did not complete successfully.\");\n        }\n\n        return result;\n    } catch (error) {\n        console.error(error);\n        throw error;\n    }\n};\n","import { useCallback, useEffect, useState } from \"react\";\nimport { Account } from \"starknet\";\nimport { BurnerConnector } from \"..\";\nimport { BurnerManager } from \"../manager/burnerManager\";\nimport { Burner } from \"../types\";\n\n/**\n * A React hook that takes the Burner Manager object avoiding the React Context.\n * Useful for building apps without React Context.\n *\n * @returns An object with utility methods and properties.\n */\nexport const useBurnerManager = ({\n    burnerManager,\n}: {\n    burnerManager: BurnerManager; // Accepts the BurnerManager class as an optional parameter\n}) => {\n    if (!burnerManager.masterAccount) {\n        throw new Error(\"BurnerManagerClass must be provided\");\n    }\n\n    // State to manage the current active account.\n    const [account, setAccount] = useState<Account | null>(null);\n\n    const [burnerUpdate, setBurnerUpdate] = useState(0);\n\n    const [isDeploying, setIsDeploying] = useState(false);\n\n    // On mount, initialize the burner manager and set the active account.\n    useEffect(() => {\n        burnerManager.init();\n        setAccount(burnerManager.getActiveAccount());\n    }, []);\n\n    /**\n     * Lists all the burners available in the storage.\n     *\n     * @returns An array of Burner accounts.\n     */\n    const list = useCallback((): Burner[] => {\n        return burnerManager.list();\n    }, [burnerManager.list(), burnerUpdate]);\n\n    /**\n     * Selects and sets a burner as the active account.\n     *\n     * @param address - The address of the burner account to set as active.\n     */\n    const select = useCallback(\n        (address: string): void => {\n            burnerManager.select(address);\n            setAccount(burnerManager.getActiveAccount());\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Retrieves a burner account based on its address.\n     *\n     * @param address - The address of the burner account to retrieve.\n     * @returns The Burner account corresponding to the provided address.\n     */\n    const get = useCallback(\n        (address: string): Account => {\n            return burnerManager.get(address);\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Clears a burner account based on its address.\n     *\n     * @param address - The address of the burner account to retrieve.\n     * @returns The Burner account corresponding to the provided address.\n     */\n    const clear = useCallback(() => {\n        burnerManager.clear();\n        setBurnerUpdate((prev) => prev + 1);\n    }, [burnerManager]);\n\n    /**\n     * Creates a new burner account and sets it as the active account.\n     *\n     * @returns A promise that resolves to the newly created Burner account.\n     */\n    const create = useCallback(async (): Promise<Account> => {\n        burnerManager.setIsDeployingCallback(setIsDeploying);\n        const newAccount = await burnerManager.create();\n        setAccount(newAccount);\n        return newAccount;\n    }, [burnerManager]);\n\n    /**\n     * Generates a list of BurnerConnector instances for each burner account. These can be added to Starknet React.\n     *\n     * @returns An array of BurnerConnector instances.\n     */\n    const listConnectors = useCallback((): BurnerConnector[] => {\n        // Retrieve all the burners.\n        const burners = list();\n\n        // Map each burner to its respective BurnerConnector instance.\n        return burners.map((burner) => {\n            return new BurnerConnector(\n                {\n                    options: {\n                        id: burner.address,\n                    },\n                },\n                get(burner.address)\n            );\n        });\n    }, [burnerManager.isDeploying]);\n\n    /**\n     * Copy burners to clipboard\n     */\n    const copyToClipboard = useCallback(async () => {\n        await burnerManager.copyBurnersToClipboard();\n    }, [burnerManager]);\n\n    /**\n     * Set burners from clipboard\n     */\n    const applyFromClipboard = useCallback(async () => {\n        await burnerManager.setBurnersFromClipboard();\n        setAccount(burnerManager.getActiveAccount()); // set the active account\n        setBurnerUpdate((prev) => prev + 1); // re-fetch of the list\n    }, [burnerManager]);\n\n    // Expose methods and properties for the consumers of this hook.\n    return {\n        get,\n        list,\n        select,\n        create,\n        listConnectors,\n        clear,\n        account,\n        isDeploying,\n        copyToClipboard,\n        applyFromClipboard,\n    };\n};\n"],"mappings":"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","names":["CallData","CallData","address","useCallback","useEffect","useState","useState","useEffect","useCallback"]}