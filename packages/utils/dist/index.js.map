{"version":3,"sources":["../src/utils/index.ts","../src/game/simplex.ts"],"sourcesContent":["import { Event } from \"starknet\";\nimport {\n    Entity,\n    setComponent,\n    Component,\n    Components,\n    ComponentValue,\n    Type as RecsType,\n    Schema,\n} from \"@dojoengine/recs\";\nimport { poseidonHashMany } from \"micro-starknet\";\n\n/**\n * Filters events from a given receipt based on specific criteria.\n *\n * @param {any} receipt - The transaction receipt.\n * @returns {any[]} An array of events that meet the filtering criteria.\n */\nexport function getEvents(receipt: any): any[] {\n    return receipt.events.filter((event: any) => {\n        return (\n            event.keys.length === 1 &&\n            event.keys[0] ===\n                \"0x1a2f334228cee715f1f0f54053bb6b5eac54fa336e0bc1aacf7516decb0471d\"\n        );\n    });\n}\n\n/**\n * Iterates over an array of events and updates components based on event data.\n *\n * @param {Components} components - The components to be updated.\n * @param {Event[]} events - An array of events containing component data.\n */\nexport function setComponentsFromEvents(\n    components: Components,\n    events: Event[]\n) {\n    events.forEach((event) => setComponentFromEvent(components, event.data));\n}\n\n/**\n * Updates a component based on the data from a single event.\n *\n * @param {Components} components - The components to be updated.\n * @param {string[]} eventData - The data from a single event.\n */\nexport function setComponentFromEvent(\n    components: Components,\n    eventData: string[]\n) {\n    // retrieve the component name\n    const componentName = hexToAscii(eventData[0]);\n\n    // retrieve the component from name\n    const component = components[componentName];\n\n    // get keys\n    const keysNumber = parseInt(eventData[1]);\n    let index = 2 + keysNumber + 1;\n\n    const keys = eventData.slice(2, 2 + keysNumber).map((key) => BigInt(key));\n\n    // get entityIndex from keys\n    const entityIndex = getEntityIdFromKeys(keys);\n\n    // get values\n    const numberOfValues = parseInt(eventData[index++]);\n\n    const string_keys = keys.map((key) => key.toString());\n\n    // get values\n    const values = eventData.slice(index, index + numberOfValues);\n\n    // create component object from values with schema\n    const componentValues = decodeComponent(component, [\n        ...string_keys,\n        ...values,\n    ]);\n\n    // console.log(componentName, entityIndex, componentValues);\n\n    // set component\n    setComponent(component, entityIndex, componentValues);\n}\n\n/**\n * Parse component value into typescript typed value\n *\n * @param {string} value - The value to parse\n * @param {RecsType} type - The target type\n */\nexport function parseComponentValue(value: string, type: RecsType) {\n    switch (type) {\n        case RecsType.Boolean:\n            return value === \"0x0\" ? false : true;\n        case RecsType.Number:\n            return Number(value);\n        case RecsType.BigInt:\n            return BigInt(value);\n        default:\n            return value;\n    }\n}\n\n/**\n * Decodes a component based on the provided schema.\n *\n * @param {Component} component - The component description created by defineComponent(), containing the schema and metadata types.\n * @param {string[]} values - An array of string values used to populate the decoded component.\n * @returns {Object} The decoded component object.\n */\nexport function decodeComponent(component: Component, values: string[]): any {\n    const schema: any = component.schema;\n    const types: string[] = (component.metadata?.types as string[]) ?? [];\n    const indices = { types: 0, values: 0 };\n    return decodeComponentValues(schema, types, values, indices);\n}\n\nfunction decodeComponentValues(\n    schema: Schema,\n    types: string[],\n    values: string[],\n    indices: any\n): any {\n    // Iterate through the keys of the schema and reduce them to build the decoded component.\n    return Object.keys(schema).reduce((acc: any, key) => {\n        const valueType = schema[key];\n        if (typeof valueType === \"object\") {\n            // valueType is a Schema\n            // it means it's a nested component. Therefore, we recursively decode it.\n            acc[key] = decodeComponentValues(\n                valueType as Schema,\n                types,\n                values,\n                indices\n            );\n        } else {\n            // valueType is a RecsType\n            // If the schema key points directly to a type or is not an object,\n            // we parse its value using the provided parseComponentValue function\n            // and move to the next index in the values array.\n            acc[key] = parseComponentValue(\n                values[indices.values],\n                valueType as RecsType\n            );\n            indices.values++;\n            // the u256 type in cairo is actually { low: u128, high: u128 }\n            // we need to consume two u128 values, shifting the second to compose u256\n            if (types[indices.types] == \"u256\") {\n                const value = parseComponentValue(\n                    values[indices.values],\n                    valueType as RecsType\n                ) as bigint;\n                acc[key] |= value << 128n;\n                indices.values++;\n            }\n            indices.types++;\n        }\n        return acc;\n    }, {});\n}\n\n/**\n * Converts a hexadecimal string to an ASCII string.\n *\n * @param {string} hex - The hexadecimal string.\n * @returns {string} The converted ASCII string.\n */\nexport function hexToAscii(hex: string) {\n    var str = \"\";\n    for (var n = 2; n < hex.length; n += 2) {\n        str += String.fromCharCode(parseInt(hex.substr(n, 2), 16));\n    }\n    return str;\n}\n\n/**\n * Determines the entity ID from an array of keys. If only one key is provided,\n * it's directly used as the entity ID. Otherwise, a poseidon hash of the keys is calculated.\n *\n * @param {bigint[]} keys - An array of big integer keys.\n * @returns {Entity} The determined entity ID.\n */\nexport function getEntityIdFromKeys(keys: bigint[]): Entity {\n    // if (keys.length === 1) {\n    //     return (\"0x\" + keys[0].toString(16)) as Entity;\n    // }\n    // calculate the poseidon hash of the keys\n    let poseidon = poseidonHashMany(keys);\n    return (\"0x\" + poseidon.toString(16)) as Entity;\n}\n\n/**\n * Iterate through GraphQL entities and set components based on them.\n *\n * @param {Components} components - The target components structure where the parsed data will be set.\n * @param {any[]} entities - The array of GraphQL entities to parse and set in the components.\n */\nexport function setComponentsFromGraphQLEntities(\n    components: Components,\n    entities: any\n) {\n    entities.forEach((entity: any) => {\n        setComponentFromGraphQLEntity(components, entity);\n    });\n}\n\n/**\n * Set a component from a single GraphQL entity.\n *\n * @param {Components} components - The target components structure where the parsed data will be set.\n * @param {any} entityEdge - The GraphQL entity containing node information to parse and set in the components.\n */\nexport function setComponentFromGraphQLEntity(\n    components: Components,\n    entityEdge: any\n) {\n    const keys = entityEdge.node.keys.map((key: string) => BigInt(key));\n    const entityIndex = getEntityIdFromKeys(keys);\n\n    entityEdge.node.models.forEach((model: any) => {\n        const componentName = model.__typename;\n        const component = components[componentName];\n\n        if (!component) {\n            console.error(`Component ${componentName} not found`);\n            return;\n        }\n\n        const componentValues = Object.keys(component.schema).reduce(\n            (acc: ComponentValue, key) => {\n                const value = model[key];\n                const parsedValue = parseComponentValueFromGraphQLEntity(\n                    value,\n                    component.schema[key]\n                );\n                acc[key] = parsedValue;\n                return acc;\n            },\n            {}\n        );\n\n        // console.log(componentValues);\n        setComponent(component, entityIndex, componentValues);\n    });\n}\n\n/**\n * Parse a component's value from a GraphQL entity based on its type or schema.\n *\n * @param {any} value - The raw value from the GraphQL entity.\n * @param {RecsType | object} type - The expected type or schema for the value.\n * @returns {any} The parsed value.\n */\nexport function parseComponentValueFromGraphQLEntity(\n    value: any,\n    type: RecsType | object\n): any {\n    if (value === undefined || value === null) return value;\n\n    // Check if type is an object (i.e., a nested schema)\n    if (typeof type === \"object\" && type !== null) {\n        const parsedObject: any = {};\n        for (const key in type) {\n            parsedObject[key] = parseComponentValueFromGraphQLEntity(\n                value[key],\n                (type as any)[key]\n            );\n        }\n        return parsedObject;\n    }\n\n    // For primitive types\n    switch (type) {\n        case RecsType.Boolean:\n            return !!value;\n        case RecsType.Number:\n            if (typeof value === \"string\") {\n                return 0;\n            }\n            return !isNaN(Number(value)) ? Number(value) : value;\n        case RecsType.BigInt:\n            return BigInt(value);\n        default:\n            return value;\n    }\n}\n\nexport function shortenHex(hexString: string, numDigits = 6) {\n    if (hexString?.length <= numDigits) {\n        return hexString;\n    }\n\n    const halfDigits = Math.floor(numDigits / 2);\n    const firstHalf = hexString.slice(0, halfDigits);\n    const secondHalf = hexString.slice(-halfDigits);\n    return `${firstHalf}...${secondHalf}`;\n}\n","import * as math from \"mathjs\";\n\nconst multiply = (a: any, b: any) => {\n    if (!Array.isArray(a) || !Array.isArray(b)) return math.multiply(a, b);\n    return a.map((v, i) => v * b[i]);\n};\n\nconst floor = (a: any) => {\n    return a.map((v: any) => Math.floor(v));\n};\n\nconst step = (a: any, b: any) => {\n    return a.map((v: any, i: any) => (b[i] <= v ? 0 : 1));\n};\n\nconst mod289 = (x: any) => {\n    return x.map((v: any) => v - Math.floor(v * (1.0 / 289.0)) * 289.0);\n};\n\nconst permute = (x: any) => {\n    x = x.map((v: any) => (v * 34.0 + 1.0) * v);\n    return mod289(x);\n};\n\nconst taylorInvSqrt = (r: any) => {\n    return r.map((v: any) => 1.79284291400159 - 0.85373472095314 * v);\n};\n\nexport const snoise = (v: any) => {\n    const C = [1.0 / 6.0, 1.0 / 3.0];\n    const D = [0.0, 0.5, 1.0, 2.0];\n\n    // First corner\n    let i = floor(math.add(v, math.dot(v, [C[1], C[1], C[1]])));\n    let x0 = math.add(math.subtract(v, i), math.dot(i, [C[0], C[0], C[0]]));\n\n    // Other corners\n    let g = step([x0[1], x0[2], x0[0]], [x0[0], x0[1], x0[2]]);\n    let l = math.subtract(1.0, g);\n    let i1 = math.min(\n        [\n            [g[0], g[1], g[2]],\n            [l[2], l[0], l[1]],\n        ],\n        0\n    );\n    let i2 = math.max(\n        [\n            [g[0], g[1], g[2]],\n            [l[2], l[0], l[1]],\n        ],\n        0\n    );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    let x1 = math.add(math.subtract(x0, i1), [C[0], C[0], C[0]]);\n    let x2 = math.add(math.subtract(x0, i2), [C[1], C[1], C[1]]); // 2.0*C.x = 1/3 = C.y\n    let x3 = math.subtract(x0, [D[1], D[1], D[1]]); // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    let p1 = permute(math.add(i[2], [0.0, i1[2], i2[2], 1.0]));\n    let p2 = permute(math.add(math.add(p1, i[1]), [0.0, i1[1], i2[1], 1.0]));\n    let p = permute(math.add(math.add(p2, i[0]), [0.0, i1[0], i2[0], 1.0]));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    let ns = [0.285714285714286, -0.928571428571428, 0.142857142857143]; // these must be *exact*\n    let j = math.subtract(p, multiply(49, floor(multiply(p, ns[2] * ns[2])))); //  mod(p,7*7)\n\n    let x_ = floor(multiply(j, ns[2]));\n    let y_ = floor(math.subtract(j, multiply(7, x_))); // mod(j,N)\n\n    let x = math.add(multiply(x_, ns[0]), [ns[1], ns[1], ns[1], ns[1]]);\n    let y = math.add(multiply(y_, ns[0]), [ns[1], ns[1], ns[1], ns[1]]);\n    let h = math.subtract(math.subtract(1.0, math.abs(x)), math.abs(y));\n\n    let b0 = [x[0], x[1], y[0], y[1]];\n    let b1 = [x[2], x[3], y[2], y[3]];\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    let s0 = math.add(multiply(floor(b0), 2.0), 1.0);\n    let s1 = math.add(multiply(floor(b1), 2.0), 1.0);\n    let sh = multiply(-1, step(h, [0, 0, 0, 0]));\n\n    let a0 = math.add(\n        [b0[0], b0[2], b0[1], b0[3]],\n        multiply([s0[0], s0[2], s0[1], s0[3]], [sh[0], sh[0], sh[1], sh[1]])\n    );\n    let a1 = math.add(\n        [b1[0], b1[2], b1[1], b1[3]],\n        multiply([s1[0], s1[2], s1[1], s1[3]], [sh[2], sh[2], sh[3], sh[3]])\n    );\n\n    let p0 = [a0[0], a0[1], h[0]];\n    p1 = [a0[2], a0[3], h[1]];\n    p2 = [a1[0], a1[1], h[2]];\n    let p3 = [a1[2], a1[3], h[3]];\n\n    // Normalise gradients\n    let norm = taylorInvSqrt([\n        math.dot(p0, p0),\n        math.dot(p1, p1),\n        math.dot(p2, p2),\n        math.dot(p3, p3),\n    ]);\n    p0 = multiply(p0, norm[0]);\n    p1 = multiply(p1, norm[1]);\n    p2 = multiply(p2, norm[2]);\n    p3 = multiply(p3, norm[3]);\n\n    // Mix final noise value\n    //@ts-ignore\n    let m = math.max(\n        [\n            //@ts-ignore\n            math.subtract(0.5, [\n                math.dot(x0, x0),\n                math.dot(x1, x1),\n                math.dot(x2, x2),\n                math.dot(x3, x3),\n            ]),\n            [0, 0, 0, 0],\n        ],\n        0\n    );\n    m = multiply(m, m);\n    m = multiply(m, m);\n    let noise = multiply(\n        105.0,\n        //@ts-ignore\n        math.dot(m, [\n            math.dot(p0, x0),\n            math.dot(p1, x1),\n            math.dot(p2, x2),\n            math.dot(p3, x3),\n        ])\n    );\n    return noise;\n};\n\nexport const recursiveSNoise = (p: any, pers: any, octaves: any) => {\n    let total = 0.0;\n    let frequency = 1.0;\n    let amplitude = 1.0;\n    let maxValue = 0.0;\n\n    for (let i = 0; i < octaves; i++) {\n        total += snoise(multiply(p, frequency)) * amplitude;\n        maxValue += amplitude;\n        amplitude *= pers;\n        frequency *= 2.0;\n    }\n\n    const noise = total / maxValue;\n    return noise;\n};\n\nexport default {\n    snoise,\n    recursiveSNoise,\n};\n"],"mappings":"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","names":["setComponent","RecsType","poseidonHashMany","getEvents","receipt","event","setComponentsFromEvents","components","events","setComponentFromEvent","eventData","componentName","hexToAscii","component","keysNumber","index","keys","key","entityIndex","getEntityIdFromKeys","numberOfValues","string_keys","values","componentValues","decodeComponent","parseComponentValue","value","type","schema","types","decodeComponentValues","indices","acc","valueType","hex","str","n","setComponentsFromGraphQLEntities","entities","entity","setComponentFromGraphQLEntity","entityEdge","model","parsedValue","parseComponentValueFromGraphQLEntity","parsedObject","shortenHex","hexString","numDigits","halfDigits","firstHalf","secondHalf","math","multiply","a","b","v","i","floor","step","mod289","x","permute","taylorInvSqrt","r","snoise","C","D","x0","g","l","i1","i2","x1","x2","x3","p1","p2","p","ns","j","x_","y_","y","h","b0","b1","s0","s1","sh","a0","a1","p0","p3","norm","m","recursiveSNoise","pers","octaves","total","frequency","amplitude","maxValue"]}