{"version":3,"sources":["../src/useSubscribeEntityModel.ts","../src/utils.ts","../src/useSync.ts","../src/useComponentValue.ts","../src/usePromise.ts","../src/syncManager/createSyncManager.ts","../src/useEntityQuery.ts","../src/utils/useDeepMemo.ts","../src/useSyncWorld.ts"],"sourcesContent":["import { getEntityIdFromKeys } from \"@dojoengine/utils\";\nimport {\n    Component,\n    ComponentValue,\n    Entity,\n    Metadata,\n    Schema,\n    setComponent,\n} from \"@dojoengine/recs\";\nimport { useEffect, useMemo } from \"react\";\nimport { Client } from \"@dojoengine/torii-client\";\nimport { convertValues } from \"./utils\";\n\nexport function useSubscribeEntityModel<S extends Schema>(\n    client: Client,\n    component: Component<S, Metadata, undefined>,\n    keys: any[]\n) {\n    const entityIndex = useMemo(() => {\n        if (keys.length === 1) return keys[0].toString();\n        return getEntityIdFromKeys(keys);\n    }, [keys]);\n\n    const componentName = useMemo(\n        () => component.metadata?.name,\n        [component.metadata?.name]\n    );\n\n    const keys_to_strings = useMemo(\n        () => keys.map((key) => key.toString()),\n        [keys]\n    );\n\n    const setModelValue = async () => {\n        try {\n            setComponent(\n                component,\n                entityIndex as Entity,\n                convertValues(\n                    component.schema,\n                    await client.getModelValue(\n                        componentName as string,\n                        keys_to_strings\n                    )\n                ) as ComponentValue\n            );\n        } catch (error) {\n            console.error(\"Failed to fetch or set model value:\", error);\n        }\n    };\n\n    useEffect(() => {\n        client.onSyncEntityChange(\n            { model: componentName as string, keys: keys_to_strings },\n            setModelValue\n        );\n    }, [client]);\n}\n","import { Type as RecsType, Schema } from \"@dojoengine/recs\";\n\nexport function convertValues(schema: Schema, values: any) {\n    return Object.keys(schema).reduce<any>((acc, key) => {\n        const schemaType = schema[key];\n        const value = values[key];\n\n        if (\n            typeof schemaType === \"object\" &&\n            value &&\n            typeof value === \"object\"\n        ) {\n            acc[key] = convertValues(schemaType, value);\n        } else {\n            acc[key] =\n                schemaType === RecsType.BigInt ? BigInt(value) : Number(value);\n        }\n        return acc;\n    }, {});\n}\n","import { getEntityIdFromKeys } from \"@dojoengine/utils\";\nimport {\n    Component,\n    ComponentValue,\n    Entity,\n    Metadata,\n    Schema,\n    setComponent,\n} from \"@dojoengine/recs\";\nimport { useEffect } from \"react\";\nimport { Client } from \"@dojoengine/torii-client\";\nimport { convertValues } from \"./utils\";\n\nexport function useSync<S extends Schema>(\n    client: Client,\n    component: Component<S, Metadata, undefined>,\n    keys: any[]\n) {\n    useEffect(() => {\n        let isMounted = true;\n\n        const fetchAndSetModelValue = async () => {\n            try {\n                if (isMounted) {\n                    setComponent(\n                        component,\n                        getEntityIdFromKeys(\n                            keys.map((key) => BigInt(key))\n                        ) as Entity,\n                        convertValues(\n                            component.schema,\n                            await client.getModelValue(\n                                component.metadata?.name as string,\n                                keys.map((key) => key.toString())\n                            )\n                        ) as ComponentValue\n                    );\n                }\n            } catch (error) {\n                console.error(\"Failed to fetch or set model value:\", error);\n            }\n        };\n\n        fetchAndSetModelValue();\n\n        return () => {\n            isMounted = false;\n        };\n    }, [client]);\n\n    useEffect(() => {\n        const entity = {\n            model: component.metadata?.name as string,\n            keys: keys.map((key) => key.toString()),\n        };\n\n        client.addEntitiesToSync([entity]);\n\n        return () => {\n            client.removeEntitiesToSync([entity]).catch((error) => {\n                console.error(\"Failed to remove entities on cleanup\", error);\n            });\n        };\n    }, [client]);\n}\n","import {\n    Component,\n    ComponentValue,\n    defineQuery,\n    Entity,\n    getComponentValue,\n    Has,\n    isComponentUpdate,\n    Schema,\n} from \"@dojoengine/recs\";\nimport { useEffect, useState } from \"react\";\n\nexport function useComponentValue<S extends Schema>(\n    component: Component<S>,\n    entity: Entity | undefined,\n    defaultValue: ComponentValue<S>\n): ComponentValue<S>;\n\nexport function useComponentValue<S extends Schema>(\n    component: Component<S>,\n    entity: Entity | undefined\n): ComponentValue<S> | undefined;\n\nexport function useComponentValue<S extends Schema>(\n    component: Component<S>,\n    entity: Entity | undefined,\n    defaultValue?: ComponentValue<S>\n) {\n    const [value, setValue] = useState(\n        entity != null ? getComponentValue(component, entity) : undefined\n    );\n\n    useEffect(() => {\n        // component or entity changed, update state to latest value\n        setValue(\n            entity != null ? getComponentValue(component, entity) : undefined\n        );\n        if (entity == null) return;\n\n        const queryResult = defineQuery([Has(component)], { runOnInit: false });\n        const subscription = queryResult.update$.subscribe((update) => {\n            if (\n                isComponentUpdate(update, component) &&\n                update.entity === entity\n            ) {\n                const [nextValue] = update.value;\n                setValue(nextValue);\n            }\n        });\n        return () => subscription.unsubscribe();\n    }, [component, entity]);\n\n    return value ?? defaultValue;\n}\n","import { useEffect, useRef, useState } from \"react\";\n\n// TODO: narrow type so `null`/`undefined` always return `{status: \"idle\"}`?\n\nexport type UsePromiseResult<T> =\n    | PromiseSettledResult<Awaited<T>>\n    | { status: \"pending\" }\n    | { status: \"idle\" };\n\nexport function usePromise<T>(promise: PromiseLike<T> | null | undefined) {\n    const promiseRef = useRef(promise);\n    const [result, setResult] = useState<UsePromiseResult<T>>(\n        promise == null ? { status: \"idle\" } : { status: \"pending\" }\n    );\n\n    useEffect(() => {\n        if (promise !== promiseRef.current) {\n            promiseRef.current = promise;\n            setResult(\n                promise == null ? { status: \"idle\" } : { status: \"pending\" }\n            );\n        }\n    }, [promise]);\n\n    useEffect(() => {\n        if (promise == null) return;\n        // TODO: do we need to check if result is already populated?\n        Promise.allSettled([promise]).then(([settled]) => {\n            if (promise === promiseRef.current) {\n                setResult(settled);\n            }\n        });\n    }, [promise]);\n\n    return result;\n}\n","import { Client } from \"@dojoengine/torii-client\";\nimport { Component, Schema, Metadata, setComponent } from \"@dojoengine/recs\";\nimport { getEntityIdFromKeys } from \"@dojoengine/utils\";\nimport { convertValues } from \"../utils\";\n\ntype ModelEntry<S extends Schema> = {\n    model: Component<S, Metadata, undefined>;\n    keys: any[];\n};\n\nasync function fetchAndSetModelValue<S extends Schema>(\n    client: Client,\n    modelEntry: ModelEntry<S>\n): Promise<void> {\n    const { model, keys } = modelEntry;\n\n    try {\n        setComponent(\n            model,\n            getEntityIdFromKeys(keys),\n            convertValues(\n                model.schema,\n                await client.getModelValue(\n                    model.metadata?.name as string,\n                    keys.map((key) => key.toString())\n                )\n            ) as any\n        );\n    } catch (error) {\n        console.error(\"Failed to fetch or set model value:\", error);\n    }\n}\n\nexport function createSyncManager<S extends Schema>(\n    client: Client,\n    modelEntries: ModelEntry<S>[]\n) {\n    function sync() {\n        modelEntries.forEach((modelEntry) => {\n            fetchAndSetModelValue(client, modelEntry);\n            client.addEntitiesToSync([\n                {\n                    model: modelEntry.model.metadata?.name as string,\n                    keys: modelEntry.keys.map((k) => k.toString()),\n                },\n            ]);\n            client.onSyncEntityChange(\n                {\n                    model: modelEntry.model.metadata?.name! as string,\n                    keys: modelEntry.keys.map((k) => k.toString()),\n                },\n                () => {\n                    client\n                        .getModelValue(\n                            modelEntry.model.metadata?.name! as string,\n                            modelEntry.keys.map((k) => k.toString())\n                        )\n                        .then((modelValue) => {\n                            setComponent(\n                                modelEntry.model,\n                                getEntityIdFromKeys(modelEntry.keys),\n                                convertValues(\n                                    modelEntry.model.schema,\n                                    modelValue\n                                ) as any\n                            );\n                        });\n                }\n            );\n        });\n    }\n\n    function cleanup() {\n        modelEntries.forEach((modelEntry) => {\n            client\n                .removeEntitiesToSync([\n                    {\n                        model: modelEntry.model.metadata?.name as string,\n                        keys: modelEntry.keys.map((k) => k.toString()),\n                    },\n                ])\n                .catch((error) => {\n                    console.error(\n                        \"Failed to remove entities on cleanup\",\n                        error\n                    );\n                });\n        });\n    }\n\n    return { cleanup, sync };\n}\n","import { defineQuery, QueryFragment } from \"@dojoengine/recs\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { useDeepMemo } from \"./utils/useDeepMemo\";\nimport isEqual from \"fast-deep-equal\";\nimport { distinctUntilChanged, map } from \"rxjs\";\n\n// This does a little more rendering than is necessary when arguments change,\n// but at least it's giving correct results now. Will optimize later!\n\n/**\n * Returns all matching entities for a given entity query,\n * and triggers a re-render as new query results come in.\n *\n * @param fragments Query fragments to match against, executed from left to right.\n * @param options.updateOnValueChange False - re-renders only on entity array changes. True (default) - also on component value changes.\n * @returns Set of entities matching the query fragments.\n */\nexport function useEntityQuery(\n    fragments: QueryFragment[],\n    options?: { updateOnValueChange?: boolean }\n) {\n    const updateOnValueChange = options?.updateOnValueChange ?? true;\n\n    const stableFragments = useDeepMemo(fragments);\n    const query = useMemo(\n        () => defineQuery(stableFragments, { runOnInit: true }),\n        [stableFragments]\n    );\n    const [entities, setEntities] = useState([...query.matching]);\n\n    useEffect(() => {\n        setEntities([...query.matching]);\n        let observable = query.update$.pipe(map(() => [...query.matching]));\n        if (!updateOnValueChange) {\n            // re-render only on entity array changes\n            observable = observable.pipe(\n                distinctUntilChanged((a, b) => isEqual(a, b))\n            );\n        }\n        const subscription = observable.subscribe((entities) =>\n            setEntities(entities)\n        );\n        return () => subscription.unsubscribe();\n    }, [query, updateOnValueChange]);\n\n    return entities;\n}\n","import { useEffect, useState } from \"react\";\nimport isEqual from \"fast-deep-equal\";\n\nexport const useDeepMemo = <T>(currentValue: T): T => {\n    const [stableValue, setStableValue] = useState(currentValue);\n\n    useEffect(() => {\n        if (!isEqual(currentValue, stableValue)) {\n            setStableValue(currentValue);\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [currentValue]);\n\n    return stableValue;\n};\n","import {\n    Component,\n    ComponentValue,\n    Entity,\n    Metadata,\n    Schema,\n    setComponent,\n} from \"@dojoengine/recs\";\nimport { useEffect } from \"react\";\nimport { Client } from \"@dojoengine/torii-client\";\nimport { convertValues } from \"./utils\";\n\nexport function useSyncWorld<S extends Schema>(\n    client: Client,\n    components: Component<S, Metadata, undefined>[]\n) {\n    useEffect(() => {\n        getEntities(client, components);\n    }, [client]);\n}\n\nexport const getEntities = async <S extends Schema>(\n    client: Client,\n    components: Component<S, Metadata, undefined>[]\n) => {\n    let cursor = 0;\n    let continueFetching = true;\n\n    while (continueFetching) {\n        let entities = await client.getEntities(100, cursor);\n\n        for (let key in entities) {\n            if (entities.hasOwnProperty(key)) {\n                for (let componentName in entities[key]) {\n                    if (entities[key].hasOwnProperty(componentName)) {\n                        let recsComponent = components[componentName as any];\n\n                        if (recsComponent) {\n                            setComponent(\n                                recsComponent,\n                                key as Entity,\n                                convertValues(\n                                    recsComponent.schema,\n                                    entities[key][componentName]\n                                ) as ComponentValue\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        if (Object.keys(entities).length < 100) {\n            continueFetching = false;\n        } else {\n            cursor += 100;\n        }\n    }\n};\n"],"mappings":"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","names":["getEntityIdFromKeys","setComponent","useEffect","useEffect","fetchAndSetModelValue","setComponent","getEntityIdFromKeys","useEffect","useEffect","useState","setComponent","getEntityIdFromKeys","setComponent","getEntityIdFromKeys","defineQuery","useEffect","useMemo","useState","useEffect","useState","isEqual","useMemo","defineQuery","useState","useEffect","entities","setComponent","useEffect","useEffect","setComponent"]}