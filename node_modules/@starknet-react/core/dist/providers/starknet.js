"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StarknetProvider = exports.useStarknet = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const starknet_1 = require("starknet");
const errors_1 = require("../errors");
const customDefaultProvider = new starknet_1.Provider({
    sequencer: {
        network: starknet_1.constants.NetworkName.SN_MAIN,
    },
});
const STARKNET_INITIAL_STATE = {
    account: undefined,
    connect: () => undefined,
    disconnect: () => undefined,
    library: customDefaultProvider,
    connectors: [],
};
const StarknetContext = (0, react_1.createContext)(STARKNET_INITIAL_STATE);
/**
 * Returns the current Starknet context state.
 *
 * @remarks
 *
 * This hook should be used sparingly and will be deprecated.
 *
 * Use the following hooks:
 *
 *  - `account`: `useAccount`
 *  - `connect`, `disconnect`, `connectors`: `useConnectors`
 *
 * @example
 * This example shows how to access the Starknet provider.
 * ```tsx
 * function Component() {
 *   const { library } = useStarknet()
 *
 *   if (!library.provider) return <span>Account URL: {library.baseUrl}</span>
 *   return <span>Provider URL: {library.provider.baseUrl}</span>
 * }
 * ```
 */
function useStarknet() {
    return (0, react_1.useContext)(StarknetContext);
}
exports.useStarknet = useStarknet;
function reducer(state, action) {
    switch (action.type) {
        case 'set_account': {
            return { ...state, account: action.account };
        }
        case 'set_provider': {
            return { ...state, library: action.provider ?? customDefaultProvider };
        }
        case 'set_connector': {
            return { ...state, connector: action.connector };
        }
        case 'set_error': {
            return { ...state, error: action.error };
        }
        default: {
            return state;
        }
    }
}
function useStarknetManager({ defaultProvider: userDefaultProvider, connectors: userConnectors, autoConnect, }) {
    const connectors = userConnectors ?? [];
    const [state, dispatch] = (0, react_1.useReducer)(reducer, {
        library: userDefaultProvider ? userDefaultProvider : customDefaultProvider,
        connectors,
    });
    const { account, library, error } = state;
    const connect = (0, react_1.useCallback)((connector) => {
        connector.connect().then((account) => {
            dispatch({ type: 'set_account', account: account.address });
            dispatch({ type: 'set_provider', provider: account });
            dispatch({ type: 'set_connector', connector });
            if (autoConnect) {
                localStorage.setItem('lastUsedConnector', connector.id);
            }
        }, (err) => {
            console.error(err);
            dispatch({ type: 'set_error', error: new errors_1.ConnectorNotFoundError() });
        });
    }, [autoConnect]);
    const disconnect = (0, react_1.useCallback)(() => {
        dispatch({ type: 'set_account', account: undefined });
        dispatch({
            type: 'set_provider',
            provider: userDefaultProvider ? userDefaultProvider : customDefaultProvider,
        });
        dispatch({ type: 'set_connector', connector: undefined });
        if (autoConnect) {
            localStorage.removeItem('lastUsedConnector');
        }
        if (!state.connector)
            return;
        state.connector.removeEventListener(handleAccountChanged);
        state.connector.disconnect().catch((err) => {
            console.error(err);
            dispatch({ type: 'set_error', error: new errors_1.ConnectorNotFoundError() });
        });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [autoConnect, state.connector, userDefaultProvider]);
    const handleAccountChanged = (0, react_1.useCallback)(() => {
        disconnect();
        if (state.connector) {
            connect(state.connector);
        }
    }, [state.connector, connect, disconnect]);
    (0, react_1.useEffect)(() => {
        if (state.connector) {
            state.connector?.initEventListener(handleAccountChanged);
        }
    }, [state.connector, handleAccountChanged]);
    (0, react_1.useEffect)(() => {
        async function tryAutoConnect(connectors) {
            const lastConnectedConnectorId = localStorage.getItem('lastUsedConnector');
            if (lastConnectedConnectorId === null) {
                return;
            }
            const lastConnectedConnector = connectors.find((connector) => connector.id === lastConnectedConnectorId);
            if (lastConnectedConnector === undefined) {
                return;
            }
            try {
                if (!(await lastConnectedConnector.ready())) {
                    // Not authorized anymore.
                    return;
                }
                connect(lastConnectedConnector);
            }
            catch {
                // no-op
            }
        }
        if (autoConnect && !account) {
            tryAutoConnect(connectors);
        }
        // Dependencies intentionally omitted since we only want
        // this executed once.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return { account, connect, disconnect, connectors, library, error };
}
/** Root Starknet context provider. */
function StarknetProvider({ children, defaultProvider, connectors, autoConnect, queryClient, }) {
    const state = useStarknetManager({ defaultProvider, connectors, autoConnect });
    return ((0, jsx_runtime_1.jsx)(react_query_1.QueryClientProvider, { client: queryClient ?? new react_query_1.QueryClient(), children: (0, jsx_runtime_1.jsx)(StarknetContext.Provider, { value: state, children: children }) }));
}
exports.StarknetProvider = StarknetProvider;
//# sourceMappingURL=starknet.js.map