"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionManagerProvider = exports.useTransactionManager = exports.TransactionManagerContext = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const immutable_1 = require("immutable");
/** Transaction manager context. */
exports.TransactionManagerContext = (0, react_1.createContext)({
    transactions: [],
    hashes: [],
    addTransaction: ({ hash: _hash, metadata: _metadata }) => undefined,
    removeTransaction: ({ hash: _hash }) => undefined,
});
/**
 * Hook to manage transaction across different components.
 *
 * @remarks
 *
 * This hook only manages the hashes of the transactions, use the
 * `useTransactions` hook to fetch the state of the transactions.
 *
 * @example
 * This example shows how to fetch the state of tracked transactions
 * and how to add new transactions to the manager.
 *
 * Notice that the transaction manager only accepts the same transaction once.
 * ```tsx
 * function Component() {
 *   const { hashes, addTransaction } = useTransactionManager()
 *   const transactions = useTransactions({ hashes })
 *
 *   return (
 *     <>
 *       <button onClick={() => addTransaction({ hash: txHash, metadata: { test: true } })}>
 *         Add transaction
 *       </button>
 *       <ul>
 *         {transactions.map(({ data }, i) => (
 *           <li key={i}>{data && data.transaction_hash}</li>
 *         ))}
 *       </ul>
 *     </>
 *   )
 * }
 * ```
 */
function useTransactionManager() {
    const context = (0, react_1.useContext)(exports.TransactionManagerContext);
    if (!context) {
        throw new Error('useTransactionManager must be used inside TransactionManagerProvider');
    }
    return context;
}
exports.useTransactionManager = useTransactionManager;
/** Context provider for `useTransactionManager`. */
function TransactionManagerProvider({ children, }) {
    const [state, dispatch] = (0, react_1.useReducer)(reducer, {
        hashes: (0, immutable_1.OrderedSet)(),
        transactions: (0, immutable_1.OrderedMap)(),
    });
    const addTransaction = (0, react_1.useCallback)(({ hash, metadata }) => {
        dispatch({ type: 'add_transaction', hash, metadata });
    }, [dispatch]);
    const removeTransaction = (0, react_1.useCallback)(({ hash }) => {
        dispatch({ type: 'remove_transaction', hash });
    }, [dispatch]);
    const Provider = exports.TransactionManagerContext.Provider;
    const transactions = state.transactions;
    return ((0, jsx_runtime_1.jsx)(Provider, { value: {
            transactions: transactions.valueSeq().toArray(),
            hashes: transactions.keySeq().toArray(),
            addTransaction,
            removeTransaction,
        }, children: children }));
}
exports.TransactionManagerProvider = TransactionManagerProvider;
function reducer(state, action) {
    switch (action.type) {
        case 'add_transaction': {
            const hashes = state.hashes.add(action.hash);
            const transactions = state.transactions.set(action.hash, {
                hash: action.hash,
                metadata: action.metadata,
            });
            return { ...state, hashes, transactions };
        }
        case 'remove_transaction': {
            const hashes = state.hashes.remove(action.hash);
            const transactions = state.transactions.delete(action.hash);
            return { ...state, hashes, transactions };
        }
        default: {
            return state;
        }
    }
}
//# sourceMappingURL=transaction.js.map