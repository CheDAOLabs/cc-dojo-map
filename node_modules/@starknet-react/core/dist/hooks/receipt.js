"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useWaitForTransaction = void 0;
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const providers_1 = require("../providers");
const invalidate_1 = require("./invalidate");
const network_1 = require("./network");
/**
 * Hook to fetch a single transaction receipt.
 *
 * @remarks
 *
 * This hook keeps a cache of receipts by chain and transaction hash
 * so that you can use the hook freely in your application without worrying
 * about sending duplicate network requests.
 *
 * If you need to refresh the transaction receipt data, set `watch: true` in
 * the props. The hook will periodically refresh the transaction data in the
 * background.
 *
 * @example
 * This hook shows how to fetch a transaction receipt.
 * ```tsx
 * function Component() {
 *   const { data, loading, error } = useWaitForTransaction({ hash: txHash })
 *
 *   if (loading) return <span>Loading...</span>
 *   if (error) return <span>Error: {JSON.stringify(error)}</span>
 *   return <span>{data && data.status}</span>
 * }
 * ```
 *
 * @example
 * This example shows how to submit a transaction and load its status.
 * ```tsx
 * function Component() {
 *   const { address } = useAccount()
 *   const [hash, setHash] = useState(undefined)
 *
 *   const { data, isLoading, error } = useWaitForTransaction({ hash, watch: true })
 *
 *   const { write } = useContractWrite({
 *     calls: [{
 *       contractAddress: ethAddress,
 *       entrypoint: 'transfer',
 *       calldata: [address, 1, 0]
 *     }]
 *   })
 *
 *   const handleClick = () => {
 *     write().then(tx => setHash(tx.transaction_hash))
 *   }
 *
 *   return (
 *     <div>
 *       <button onClick={handleClick}>Submit tx</button>
 *       <div>Hash: {hash}</div>
 *       {isLoading && <div>Loading...</div>}
 *       {error && <div>Error: {JSON.stringify(error)}</div>}
 *       {data && <div>Status: {data.status}</div>}
 *     </div>
 *   )
 * }
 * ```
 */
function useWaitForTransaction({ hash, watch, onAcceptedOnL1, onAcceptedOnL2, onNotReceived, onPending, onReceived, onRejected, }) {
    const { library } = (0, providers_1.useStarknet)();
    const { chain } = (0, network_1.useNetwork)();
    const queryKey_ = (0, react_1.useMemo)(() => queryKey({ chain, hash }), [chain, hash]);
    const { data, error, isStale: isIdle, isLoading, isFetching, isSuccess, isError, isFetched, isFetchedAfterMount, isRefetching, refetch, status, } = (0, react_query_1.useQuery)(queryKey_, fetchTransactionReceipt({ library, hash }), {
        enabled: !!hash,
        refetchInterval: (data, _query) => (watch ? refetchInterval(data) : false),
        onSuccess: (data) => {
            const { status } = data;
            switch (status) {
                case 'ACCEPTED_ON_L1':
                    if (onAcceptedOnL1) {
                        onAcceptedOnL1(data);
                    }
                    break;
                case 'ACCEPTED_ON_L2':
                    if (onAcceptedOnL2) {
                        onAcceptedOnL2(data);
                    }
                    break;
                case 'NOT_RECEIVED':
                    if (onNotReceived) {
                        onNotReceived(data);
                    }
                    break;
                case 'PENDING':
                    if (onPending) {
                        onPending(data);
                    }
                    break;
                case 'RECEIVED':
                    if (onReceived) {
                        onReceived(data);
                    }
                    break;
                case 'REJECTED':
                    if (onRejected) {
                        onRejected(data);
                    }
                    break;
            }
        },
    });
    (0, invalidate_1.useInvalidateOnBlock)({ enabled: watch, queryKey: queryKey_ });
    return {
        data,
        error: error ?? undefined,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status,
    };
}
exports.useWaitForTransaction = useWaitForTransaction;
function queryKey({ chain, hash }) {
    return [{ entity: 'transactionReceipt', chainId: chain?.id, hash }];
}
function fetchTransactionReceipt({ library, hash }) {
    return async () => {
        if (!hash)
            throw new Error('hash is required');
        return await library.getTransactionReceipt(hash);
    };
}
function refetchInterval(data) {
    if (!data)
        return false;
    const { status } = data;
    switch (status) {
        case 'ACCEPTED_ON_L1':
            return false;
        case 'ACCEPTED_ON_L2':
            return 60000;
        case 'NOT_RECEIVED':
            return 500;
        case 'PENDING':
            return 5000;
        case 'RECEIVED':
            return 5000;
        case 'REJECTED':
            return false;
        default:
            return false;
    }
}
//# sourceMappingURL=receipt.js.map