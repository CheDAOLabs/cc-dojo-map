"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTransactions = exports.useTransaction = void 0;
const react_query_1 = require("@tanstack/react-query");
const providers_1 = require("../providers");
const invalidate_1 = require("./invalidate");
const network_1 = require("./network");
/**
 * Hook to fetch a single transaction.
 *
 * @remarks
 *
 * This hook keeps a cache of transactions by chain and transaction hash
 * so that you can use the hook freely in your application without worrying
 * about sending duplicate network requests.
 *
 * @example
 * This hook shows how to fetch a transaction.
 * ```tsx
 * function Component() {
 *   const { data, isLoading, error } = useTransaction({
 *     hash: txHash,
 *     watch: true,
 *   })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (error) return <span>Error: {JSON.stringify(error)}</span>
 *   return <span>{data.transaction_hash}</span>
 * }
 */
function useTransaction({ hash, watch = false }) {
    const { library } = (0, providers_1.useStarknet)();
    const { chain } = (0, network_1.useNetwork)();
    const queryKey_ = queryKey({ chain, hash });
    const { data, error, isStale: isIdle, isLoading, isFetching, isSuccess, isError, isFetched, isFetchedAfterMount, isRefetching, refetch, status, } = (0, react_query_1.useQuery)(queryKey_, fetchTransaction({
        library,
        hash,
    }));
    (0, invalidate_1.useInvalidateOnBlock)({ enabled: watch, queryKey: queryKey_ });
    return {
        data,
        error: error ?? undefined,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status,
    };
}
exports.useTransaction = useTransaction;
/**
 * Hook to fetch a list of transactions in parallel.
 *
 * @remarks
 *
 * This hook fetches a dynamic list of transactions without
 * violating the rules of hooks.
 *
 * @example
 * This example shows how to fetch a list of transactions.
 * ```tsx
 * function Component() {
 *   const results = useTransactions({
 *     hashes: [txHash, txHash2],
 *     watch: true,
 *   })
 *
 *   return (
 *     <ul>
 *       {results.map(({ data }, i) => (
 *         <li key={i}>
 *         {data ? data.transaction_hash : 'Loading...'}
 *         </li>
 *       ))}
 *     </ul>
 *   )
 * }
 * ```
 */
function useTransactions({ hashes, watch = false, }) {
    const { library } = (0, providers_1.useStarknet)();
    const { chain } = (0, network_1.useNetwork)();
    const result = (0, react_query_1.useQueries)({
        queries: hashes.map((hash) => ({
            queryKey: queryKey({ chain, hash }),
            queryFn: fetchTransaction({
                library,
                hash,
            }),
        })),
    });
    (0, invalidate_1.useInvalidateOnBlock)({
        enabled: watch,
        queryKey: [{ entity: 'transaction', chainId: chain?.id }],
    });
    return result.map(({ data, error, isStale: isIdle, isLoading, isFetching, isSuccess, isError, isFetched, isFetchedAfterMount, isRefetching, refetch, status, }) => ({
        data,
        error: error ?? undefined,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status,
    }));
}
exports.useTransactions = useTransactions;
function queryKey({ chain, hash }) {
    return [
        {
            entity: 'transaction',
            chainId: chain?.id,
            hash: hash,
        },
    ];
}
function fetchTransaction({ library, hash }) {
    return async () => {
        if (!hash)
            throw new Error('hash is required');
        return await library.getTransaction(hash);
    };
}
//# sourceMappingURL=transaction.js.map