"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useContractRead = void 0;
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const contract_1 = require("./contract");
const invalidate_1 = require("./invalidate");
const network_1 = require("./network");
/**
 * Hook to perform a read-only contract call.
 *
 * @remarks
 *
 * The hook only performs a call if the target `abi`, `address`,
 * `functionName`, and `args` are not undefined.
 *
 * @example
 * This example shows how to fetch the user ERC-20 balance.
 * ```tsx
 * function Component() {
 *   const { address } = useAccount()
 *   const { data, isLoading, error, refetch } = useContractRead({
 *     address: ethAddress,
 *     abi: compiledErc20.abi,
 *     functionName: 'balanceOf',
 *     args: [address],
 *     watch: false
 *   })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (error) return <span>Error: {JSON.stringify(error)}</span>
 *
 *   return (
 *     <div>
 *       <button onClick={refetch}>Refetch</button>
 *       <p>U256 high: {data.balance.high.toString()}</p>
 *       <p>U256 low: {data.balance.low.toString()}</p>
 *     </div>
 *   )
 * }
 * ```
 */
function useContractRead({ abi, address, functionName, args, watch = false, blockIdentifier = 'pending', }) {
    const { chain } = (0, network_1.useNetwork)();
    const { contract } = (0, contract_1.useContract)({ abi, address });
    const queryKey_ = (0, react_1.useMemo)(() => queryKey({ chain, args: { contract, functionName, args, blockIdentifier } }), [chain, contract, functionName, args, blockIdentifier]);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data, error, isStale: isIdle, isLoading, isFetching, isSuccess, isError, isFetched, isFetchedAfterMount, isRefetching, refetch, status,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     } = (0, react_query_1.useQuery)(queryKey_, readContract({ args: { contract, functionName, args, blockIdentifier } }));
    (0, invalidate_1.useInvalidateOnBlock)({ enabled: watch, queryKey: queryKey_ });
    return {
        data,
        error: error ?? undefined,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status,
    };
}
exports.useContractRead = useContractRead;
function readContract({ args }) {
    return async () => {
        if (!args.args || !args.contract || !args.functionName)
            return null;
        const canCall = args.contract && args.functionName;
        if (!canCall)
            return null;
        const call = args.contract[args.functionName];
        if (!call)
            throw new Error(`Function ${args.functionName} not found on contract`);
        return await call(...args.args, {
            blockIdentifier: args.blockIdentifier,
        });
    };
}
function queryKey({ chain, args }) {
    const { contract, functionName, args: callArgs, blockIdentifier } = args;
    return [
        {
            entity: 'readContract',
            chain,
            contract: contract?.address,
            functionName,
            args: callArgs,
            blockIdentifier,
        },
    ];
}
//# sourceMappingURL=call.js.map