"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSignTypedData = void 0;
const starknet_1 = require("starknet");
const react_1 = require("react");
const account_1 = require("./account");
const connectors_1 = require("./connectors");
function starknetSignReducer(state, action) {
    if (action.type === 'start_signing') {
        return {
            ...state,
            isLoading: true,
        };
    }
    else if (action.type === 'set_signature') {
        return {
            ...state,
            data: starknet_1.stark.formatSignature(action.data),
            isLoading: false,
        };
    }
    else if (action.type === 'set_error') {
        return {
            ...state,
            error: action.error,
            isLoading: false,
        };
    }
    else if (action.type === 'reset') {
        return {
            ...state,
            data: undefined,
            error: undefined,
            isLoading: false,
        };
    }
    return state;
}
/**
 * Hook to sign typed data.
 *
 * @remarks
 *
 * This hook signs a JSON object for off-chain use with the current
 * wallet private key.
 *
 * @example
 * This example shows how to sign some data. The message must follow
 * EIP712 (https://www.starknetjs.com/docs/guides/signature).
 *
 * ```tsx
 * function Component() {
 *   const message = {
 *     types: {
 *      StarkNetDomain: [
 *         { name: "name", type: "felt" },
 *         { name: "version", type: "felt" },
 *         { name: "chainId", type: "felt" },
 *       ],
 *       Person: [
 *         { name: 'name', type: 'felt' }
 *       ],
 *       Mail: [
 *         { name: 'from', type: 'Person' }
 *       ]
 *     },
 *     primaryType: 'Mail',
 *     domain: {
 *       name: 'Starknet Mail',
 *       version: '1',
 *       chainId: 1,
 *     },
 *     message: {
 *       from: {
 *         name: 'Alice'
 *       }
 *     }
 *   }
 *
 *  const { data, signTypedData } = useSignTypedData(message)
 *
 *   return (
 *     <>
 *       <p>
 *         <button onClick={signTypedData}>Sign</button>
 *       </p>
 *       {data && <p>Signed: {JSON.stringify(data)}</p>}
 *     </>
 *   )
 * }
 * ```
 */
function useSignTypedData(typedData) {
    const [state, dispatch] = (0, react_1.useReducer)(starknetSignReducer, {
        isLoading: false,
    });
    const { address: accountAddress } = (0, account_1.useAccount)();
    const { connectors } = (0, connectors_1.useConnectors)();
    const reset = (0, react_1.useCallback)(() => {
        dispatch({ type: 'reset' });
    }, [dispatch]);
    const { data, error, isLoading } = state;
    const signTypedData = (0, react_1.useCallback)(async () => {
        dispatch({ type: 'reset' });
        dispatch({ type: 'start_signing' });
        try {
            let accountInterface = null;
            const availableConnectors = connectors.filter((conn) => conn.available());
            for (const connector of availableConnectors) {
                const account = await connector.account();
                if (account && account.address === accountAddress) {
                    accountInterface = account;
                    break;
                }
            }
            if (!accountInterface) {
                throw new Error(`No connector for address ${accountAddress}`);
            }
            const response = await accountInterface.signMessage(typedData);
            dispatch({ type: 'set_signature', data: response });
            return response;
        }
        catch (err) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            dispatch({ type: 'set_error', error: errorMessage });
            console.error(err);
        }
    }, [accountAddress, connectors, typedData]);
    return {
        data,
        error,
        isLoading,
        isError: error ? true : false,
        signTypedData,
        reset,
    };
}
exports.useSignTypedData = useSignTypedData;
//# sourceMappingURL=sign.js.map