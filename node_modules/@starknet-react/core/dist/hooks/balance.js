"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useBalance = void 0;
const starknet_1 = require("starknet");
const react_1 = require("react");
const react_query_1 = require("@tanstack/react-query");
const invalidate_1 = require("./invalidate");
const __1 = require("..");
const balanceSchema_1 = require("./balanceSchema");
const ETHTokenAddress = '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7';
const balanceABIFragment = [
    {
        members: [
            {
                name: 'low',
                offset: 0,
                type: 'felt',
            },
            {
                name: 'high',
                offset: 1,
                type: 'felt',
            },
        ],
        name: 'Uint256',
        size: 2,
        type: 'struct',
    },
    {
        name: 'balanceOf',
        type: 'function',
        inputs: [
            {
                name: 'account',
                type: 'felt',
            },
        ],
        outputs: [
            {
                name: 'balance',
                type: 'Uint256',
            },
        ],
        stateMutability: 'view',
    },
    {
        inputs: [],
        name: 'symbol',
        outputs: [
            {
                name: 'symbol',
                type: 'felt',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'decimals',
        outputs: [
            {
                name: 'decimals',
                type: 'felt',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];
/**
 * Hook for fetching balance information for ERC-20 tokens.
 *
 * @remarks
 *
 * The hook only performs a call if the target `address` is defined.
 *
 * @example
 * This example shows how to fetch the user Ethereum token balance.
 * ```tsx
 * function Component() {
 *   const { address } = useAccount()
 *   const { data, isLoading, error, refetch } = useBalance({
 *     address
 *   })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (error) return <span>Error: {error}</span>
 *
 *   return (
 *     <div>
 *       <button onClick={refetch}>Refetch</button>
 *       <p>Balance: {data.formatted} {data.symbol}</p>
 *     </div>
 *   )
 * }
 * ```
 */
function useBalance({ token = ETHTokenAddress, address, formatUnits, watch = false, blockIdentifier = 'pending', }) {
    const { chain } = (0, __1.useNetwork)();
    const { contract } = (0, __1.useContract)({ abi: balanceABIFragment, address: token });
    const queryKey_ = (0, react_1.useMemo)(() => queryKey({ chain, args: { contract, address, blockIdentifier } }), [chain, contract, address, blockIdentifier]);
    const { data: contractData, error, isStale: isIdle, isLoading, isFetching, isSuccess, isError, isFetched, isFetchedAfterMount, isRefetching, refetch, status, } = (0, react_query_1.useQuery)(queryKey_, readContract({ args: { contract, address, blockIdentifier } }), {
        enabled: !!address,
    });
    (0, invalidate_1.useInvalidateOnBlock)({ enabled: watch, queryKey: queryKey_ });
    const data = (0, react_1.useMemo)(() => {
        if (!contractData) {
            return undefined;
        }
        const { decimals: { decimals: contractDecimals }, balance: { balance: balanceUint256 }, symbol: { symbol }, } = contractData;
        const decimals = Number(contractDecimals);
        const balanceAsBN = starknet_1.uint256.uint256ToBN(balanceUint256);
        const formatted = (Number(balanceAsBN.toString()) / 10 ** (formatUnits || decimals)).toString();
        const formattedSymbol = starknet_1.shortString.decodeShortString(starknet_1.num.toHex(symbol));
        return {
            decimals,
            formatted,
            symbol: formattedSymbol,
            value: balanceAsBN,
        };
    }, [contractData, formatUnits]);
    return {
        data,
        error: error ?? undefined,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status,
    };
}
exports.useBalance = useBalance;
function readContract({ args }) {
    return async () => {
        if (!args.address || !args.contract)
            return null;
        try {
            const [balance, symbol, decimals] = await Promise.all([
                args.contract.call('balanceOf', [args.address], {
                    parseResponse: true,
                }),
                args.contract.call('symbol', []),
                args.contract.call('decimals', []),
            ]);
            const parsedBalance = balanceSchema_1.balanceSchema.parse(balance);
            const parsedSymbol = balanceSchema_1.symbolSchema.parse(symbol);
            const parsedDecimals = balanceSchema_1.decimalsSchema.parse(decimals);
            return { balance: parsedBalance, symbol: parsedSymbol, decimals: parsedDecimals };
        }
        catch {
            return null;
        }
    };
}
function queryKey({ chain, args }) {
    const { contract, address: callArgs, blockIdentifier } = args;
    return [
        {
            entity: 'balance',
            chainId: chain?.id,
            contract: contract?.address,
            args: callArgs,
            blockIdentifier,
        },
    ];
}
//# sourceMappingURL=balance.js.map