import{a as W,b as v,c as te,d as ne,e as S,f as V,g as re,h as oe,i as ie,j as g,k as pe,l as ae,m as ye,n as C,o as ue,p as E,q as s,r as l,s as me,t as h,u as de,v as O,w as b,x as se,y as le,z as ce}from"./chunk-77ZVBT6M.js";import{concat as K,EMPTY as X,from as Z}from"rxjs";import{filterNullish as R}from"@latticexyz/utils";import{observable as B}from"mobx";import{concat as $,concatMap as q,filter as F,from as D,map as j,merge as L,of as z,share as Y}from"rxjs";var N=(o=>(o[o.Has=0]="Has",o[o.HasValue=1]="HasValue",o[o.Not=2]="Not",o[o.NotValue=3]="NotValue",o[o.ProxyRead=4]="ProxyRead",o[o.ProxyExpand=5]="ProxyExpand",o))(N||{});function xe(e){return[2,4,6,14,16,8,10,12].includes(e)}function Te(e){return[7,8,9,10,11,12,15,16].includes(e)}function Se(e){return[1,2].includes(e)}function ge(e){return[13,14].includes(e)}function Ye(e){return{type:0,component:e}}function Ge(e){return{type:2,component:e}}function Je(e,t){return{type:1,component:e,value:t}}function Ke(e,t){return{type:3,component:e,value:t}}function Xe(e,t){return{type:4,component:e,depth:t}}function Ze(e,t){return{type:5,component:e,depth:t}}function c(e,t){if(t.type===0)return s(t.component,e);if(t.type===1)return h(t.value,l(t.component,e));if(t.type===2)return!s(t.component,e);if(t.type===3)return!h(t.value,l(t.component,e));throw new Error("Unknown query fragment")}function G(e){return e.type===0||e.type==1}function P(e){return e.type===2||e.type==3}function J(e){return e.type===5||e.type==4}function U(e,t){return e&&G(t)||!e&&P(t)}function I(e,t,n){let r=e,a=!1;for(let y=0;y<n.depth;y++){let o=l(n.component,r);if(!o)return null;let p=o.value;if(!p)return null;if(r=p,a=c(r,t),U(a,t))return a}return a}function Q(e,t,n){if(n===0)return new Set;let r=O(t,{value:e});if(n===1)return r;let a=[...r].map(y=>[...Q(y,t,n-1)]).flat();return new Set([...r,...a])}function A(e,t){let n=t?new Set([...t]):void 0,r,a;for(let y=0;y<e.length;y++){let o=e[y];if(J(o))o.type===4&&(r=o),o.type===5&&(a=o);else if(n)for(let p of[...n]){let m=c(p,o);if(r&&r.depth>0&&!U(m,o)&&(m=I(p,o,r)??m),m||n.delete(p),a&&a.depth>0){let d=Q(p,a.component,a.depth);for(let i of d)(c(i,o)||r&&r.depth>0&&I(i,o,r))&&n.add(i)}}else{if(P(o))throw new Error("First EntityQueryFragment must be Has or HasValue");if(n=o.type===0?new Set([...b(o.component)]):O(o.component,o.value),a&&a.depth>0)for(let p of[...n])for(let m of Q(p,a.component,a.depth))n.add(m)}}return n??new Set}function f(e,t){let n=t?.runOnInit||t?.initialSet?A(e,t.initialSet):new Set,r=B(n),a=D(r).pipe(g(e[0].component)),y=e.findIndex(p=>[5,4].includes(p.type))!==-1,o=L(...e.map(p=>p.component.update$)).pipe(y?q(p=>{let m=A(e,t?.initialSet),d=[];for(let i of r)m.has(i)||(r.delete(i),d.push({entity:i,type:1,component:p.component,value:[void 0,void 0]}));for(let i of m)r.has(i)?d.push({entity:i,type:2,component:p.component,value:[l(p.component,i),void 0]}):(r.add(i),d.push({entity:i,type:0,component:p.component,value:[l(p.component,i),void 0]}));return z(...d)}):j(p=>{if(r.has(p.entity))return e.filter(u=>u.component.id===p.component.id).every(u=>c(p.entity,u))?{...p,type:2}:(r.delete(p.entity),{...p,type:1});if(e.every(d=>c(p.entity,d)))return r.add(p.entity),{...p,type:0}}),R());return{matching:r,update$:$(a,o).pipe(Y())}}function k(e,t){return f(e,t).update$.pipe(F(n=>n.type===2))}function H(e,t){return f(e,t).update$.pipe(F(n=>n.type===0))}function w(e,t){return f(e,t).update$.pipe(F(n=>n.type===1))}function x(e,t,n){let r=t.subscribe(n);e.registerDisposer(()=>r?.unsubscribe())}function pt(e,t,n,r={runOnInit:!0}){x(e,k(t,r),n)}function at(e,t,n,r={runOnInit:!0}){x(e,H(t,r),n)}function yt(e,t,n,r={runOnInit:!0}){x(e,w(t,r),n)}function _(e,t,n,r={runOnInit:!0}){x(e,f(t,r).update$,n)}function ut(e,t,n,r={runOnInit:!0}){let a=r?.runOnInit?Z(b(t)).pipe(g(t)):X;x(e,K(a,t.update$),n)}function mt(e,t,n,r,a={update:!1,runOnInit:!0}){_(e,t,({entity:y,type:o})=>{o===0&&C(n(y),y,r(y)),o===1&&E(n(y),y),a?.update&&o===2&&C(n(y),y,r(y))},a)}import{transformIterator as ee}from"@latticexyz/utils";function ft(){let e=new Set,t=[],n=[];function r({id:i,idSuffix:u}={}){let T=i||e.size+(u?"-"+u:""),M=S(T);return e.add(M),T}function a(){return ee(e.values(),V)}function y(i){t.push(i)}function o(i){for(let[,u]of n.filter(T=>!i||T[0]===i))u();n=n.filter(u=>i&&u[0]!==i)}function p(i,u=""){n.push([u,i])}function m(i){let u=S(i);return e.has(u)}function d(i){for(let u of t)s(u,i)&&E(u,i);e.delete(S(i))}return{registerEntity:r,components:t,registerComponent:y,dispose:o,registerDisposer:p,hasEntity:m,getEntities:a,entitySymbols:e,deleteEntity:d}}function xt(e,t){return{...e,registerDisposer:n=>e.registerDisposer(n,t),dispose:()=>e.dispose(t)}}function Tt(e,t){return e.components.filter(n=>s(n,t))}export{Ye as Has,Je as HasValue,Ge as Not,Ke as NotValue,te as OptionalTypes,Ze as ProxyExpand,Xe as ProxyRead,N as QueryFragmentType,W as Type,v as UpdateType,le as clearLocalCache,h as componentValueEquals,ne as createEntity,re as createIndexer,ce as createLocalCache,ft as createWorld,ye as defineComponent,ut as defineComponentSystem,H as defineEnterQuery,at as defineEnterSystem,w as defineExitQuery,yt as defineExitSystem,f as defineQuery,x as defineRxSystem,mt as defineSyncSystem,_ as defineSystem,k as defineUpdateQuery,pt as defineUpdateSystem,Q as getChildEntities,b as getComponentEntities,l as getComponentValue,me as getComponentValueStrict,O as getEntitiesWithValue,Tt as getEntityComponents,V as getEntityString,S as getEntitySymbol,s as hasComponent,Te as isArrayType,oe as isComponentUpdate,ge as isEntityType,ae as isFullComponentValue,pe as isIndexer,Se as isNumberType,xe as isOptionalType,xt as namespaceWorld,se as overridableComponent,E as removeComponent,A as runQuery,C as setComponent,ie as toUpdate,g as toUpdateStream,ue as updateComponent,de as withValue};
//# sourceMappingURL=index.js.map