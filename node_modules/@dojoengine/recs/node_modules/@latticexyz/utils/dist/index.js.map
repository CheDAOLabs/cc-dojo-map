{"version":3,"sources":["../src/arrays.ts","../src/deferred.ts","../src/mobx.ts","../src/guards.ts","../src/proxy.ts","../src/enums.ts","../src/objects.ts","../src/random.ts","../src/rx.ts","../src/uuid.ts","../src/sleep.ts","../src/promise.ts","../src/iterable.ts","../src/area.ts","../src/hash.ts","../src/worker.ts","../src/pack.ts","../src/CoordMap.ts","../src/VoxelCoordMap.ts","../src/eth.ts","../src/cubic.ts","../src/console.ts","../src/distance.ts","../src/math.ts","../src/v2/arrayToHex.ts","../src/v2/bytesToString.ts","../src/v2/isHex.ts","../src/v2/hexToArray.ts","../src/v2/stringToBytes.ts","../src/bytes.ts"],"sourcesContent":["/**\n * TypeScript type guard to assert the type of a non-empty array\n * @param array Any array to check for non-emptiness\n * @returns True if the empty is non-empty, else false. TypeScript accepts the array as non-empty after the assertion.\n */\nexport function isNotEmpty<T>(array: T[]): array is [T, ...T[]] {\n  if (array.length === 0) return false;\n  return true;\n}\n\n/**\n * Filters undefined values from an array and lets TypeScript know the resulting array\n * does not have undefined values\n * @param array Array potentially including undefined values\n * @returns Array without undefined values\n */\nexport function filterNullishValues<T>(array: (T | undefined)[]): T[] {\n  return array.filter((value) => value != null) as T[];\n}\n","/**\n * A convenient way to create a promise with resolve and reject functions.\n * @returns Tuple with resolve function, reject function and promise.\n */\nexport function deferred<T>(): [(t: T) => void, (t: Error) => void, Promise<T>] {\n  let resolve: ((t: T) => void) | null = null;\n  let reject: ((t: Error) => void) | null = null;\n  const promise = new Promise<T>((r, rj) => {\n    resolve = (t: T) => r(t);\n    reject = (e: Error) => rj(e);\n  });\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return [resolve as any, reject as any, promise];\n}\n","import { IComputedValue, IObservableValue, reaction } from \"mobx\";\nimport { deferred } from \"./deferred\";\n\n/**\n * @param comp Computed/Observable value that is either defined or undefined\n * @returns promise that resolves with the first truthy computed value\n */\nexport async function awaitValue<T>(comp: IComputedValue<T | undefined> | IObservableValue<T | undefined>): Promise<T> {\n  const [resolve, , promise] = deferred<T>();\n\n  const dispose = reaction(\n    () => comp.get(),\n    (value) => {\n      if (value) {\n        resolve(value);\n      }\n    },\n    { fireImmediately: true }\n  );\n\n  const value = await promise;\n  // Dispose the reaction once the promise is resolved\n  dispose();\n\n  return value;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Func } from \"./types\";\n\nexport function isObject(c: unknown): c is Record<string, any> {\n  return typeof c === \"object\" && !Array.isArray(c) && c !== null;\n}\n\nexport function isFunction(c: unknown): c is Func<any, any> {\n  return c instanceof Function;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { IComputedValue, IObservableValue, reaction } from \"mobx\";\nimport DeepProxy from \"proxy-deep\";\nimport { deferred } from \"./deferred\";\nimport { isFunction, isObject } from \"./guards\";\nimport { Cached } from \"./types\";\n\nfunction deepAccess(target: Record<string, unknown>, path: string[]): any {\n  if (path.length === 0) return target;\n  if (path.length === 1) return target[path[0]];\n  const [next, ...rest] = path;\n  const nextTarget = target[next];\n  if (!isObject(nextTarget)) throw new Error(\"Path does not exist on the target\");\n  return deepAccess(nextTarget, rest);\n}\n\n/**\n * Caches any function calls to the target until the target is ready.\n * @param target T extends Cachable\n * @returns Cached<T>\n */\nexport function cacheUntilReady<T extends Record<string, any>>(\n  target: IObservableValue<T | undefined> | IComputedValue<T | undefined>\n): Cached<T> {\n  // The call queue contains the path and arguments of calls to the\n  // proxiedTarget while the target was not available yet.\n  // It also contains resolve and reject methods to fulfil the promise\n  // returned when calling the proxiedTarget once the target becomes available.\n  const callQueue: {\n    path: string[];\n    args?: any[];\n    resolve: (result: any) => void;\n    reject: (e: Error) => void;\n  }[] = [];\n\n  // The proxiedTarget proxies all calls to the target.\n  // If a function is called on the proxiedTarget while the target is not\n  // available, a promise is returned and the call will be stored in the callQueue\n  // until the target becomes available and the promise is fulfilled.\n  const proxiedTarget = new DeepProxy(\n    {},\n    {\n      get(_t, prop) {\n        const targetReady = target.get();\n        if (targetReady) {\n          // If the target is ready, relay all calls directly to the target\n          // (Except for the \"proxied\" key, which indicates whether the object is currently proxied)\n          if (prop === \"proxied\") return false;\n          return Reflect.get(targetReady, prop);\n        } else {\n          // Note: if the target is not available, accessing a property returns another proxy,\n          // not a Promise. It is possible to check whether a value is currently proxied using the proxied key.\n          if (prop === \"proxied\") return true;\n          if (prop === \"name\") return \"ProxiedTarget\";\n          if (prop === \"toJSON\") return () => ({ proxied: true });\n          return this.nest(() => void 0);\n        }\n      },\n      apply(_, thisArg, args) {\n        const targetReady = target.get();\n        if (targetReady) {\n          // If the target is ready, relay all calls directly to the target\n          const targetFunc = deepAccess(targetReady, this.path);\n          if (!isFunction(targetFunc)) throw new Error(\"Target is not callable\");\n          return Reflect.apply(targetFunc, thisArg, args);\n        } else {\n          // Otherwise store the call and relay it to the target later once it's ready.\n          // The return value of this call is a promise, that gets resolved once the target is ready.\n          const [resolve, reject, promise] = deferred();\n          callQueue.push({ path: this.path, args, resolve, reject });\n          return promise;\n        }\n      },\n    }\n  );\n\n  reaction(\n    () => target.get(),\n    (targetReady) => {\n      if (!targetReady) return;\n      // Move all entries from callQueue to queuedCalls\n      const queuedCalls = callQueue.splice(0);\n      for (const { path, args, resolve, reject } of queuedCalls) {\n        const target = deepAccess(targetReady, path);\n        if (args && isFunction(target)) {\n          (async () => {\n            try {\n              resolve(await target(...args));\n            } catch (e: any) {\n              reject(e);\n            }\n          })();\n        } else {\n          resolve(target);\n        }\n      }\n    }\n  );\n\n  return proxiedTarget as Cached<T>;\n}\n","/**\n * @param enm Numeric enum\n * @returns Number array containing the enum values\n */\nexport function numValues(enm: object): number[] {\n  const nums: number[] = [];\n  for (const val of Object.values(enm)) {\n    if (!isNaN(Number(val))) {\n      nums.push(Number(val));\n    }\n  }\n  return nums;\n}\n","/**\n * Utility function to map a source object to an object with the same keys but mapped values\n * @param source Source object to be mapped\n * @param valueMap Mapping values of the source object to values of the target object\n * @returns An object with the same keys as the source object but mapped values\n */\nexport function mapObject<S extends { [key: string]: unknown }, T extends { [key in keyof S]: unknown }>(\n  source: S,\n  valueMap: (value: S[keyof S], key: keyof S) => T[keyof S]\n): T {\n  const target: Partial<{ [key in keyof typeof source]: T[keyof S] }> = {};\n  for (const key in source) {\n    target[key] = valueMap(source[key], key);\n  }\n  return target as T;\n}\n","/**\n *\n * @param to Upper bound (included)\n * @param from Lower bound (included). Default 0.\n * @returns A random integer between from and to.\n */\nexport function random(to: number, from = 0): number {\n  return Math.floor(Math.random() * (to - from + 1)) + from;\n}\n\n/**\n * @param array Array to pick a random element from.\n * @returns Random element from the given array.\n */\nexport function pickRandom<T>(array: [T, ...T[]]): T {\n  return array[random(array.length - 1)];\n}\n","import {\n  concatMap,\n  delay,\n  filter,\n  first,\n  mergeMap,\n  Observable,\n  of,\n  OperatorFunction,\n  pipe,\n  ReplaySubject,\n  scan,\n  Timestamp,\n  timestamp,\n} from \"rxjs\";\nimport { computed, IComputedValue, IObservableValue, observable, reaction, runInAction, toJS } from \"mobx\";\nimport { deferred } from \"./deferred\";\nimport { awaitValue } from \"./mobx\";\n\nexport function filterNullish<T>(): OperatorFunction<T, NonNullable<T>> {\n  return pipe<Observable<T>, Observable<NonNullable<T>>>(\n    filter<T>((x: T) => x != null) as OperatorFunction<T, NonNullable<T>>\n  );\n}\n\nexport function awaitPromise<T extends Promise<unknown>>(): OperatorFunction<T, Awaited<T>> {\n  return pipe(concatMap((x: T) => x)) as OperatorFunction<T, Awaited<T>>;\n}\n\n/**\n * RxJS operator to stretch out an event stream by a given delay per event\n * @param spacingDelayMs Delay between each event in ms\n * @returns stream of events with at least spacingDelayMs spaceing between event\n */\nexport function stretch<T>(spacingDelayMs: number) {\n  return pipe(\n    timestamp<T>(),\n    scan((acc: (Timestamp<T> & { delay: number }) | null, curr: Timestamp<T>) => {\n      // calculate delay needed to offset next emission\n      let delay = 0;\n      if (acc !== null) {\n        const timeDelta = curr.timestamp - acc.timestamp;\n        delay = timeDelta > spacingDelayMs ? 0 : spacingDelayMs - timeDelta;\n      }\n\n      return {\n        timestamp: curr.timestamp,\n        delay: delay,\n        value: curr.value,\n      };\n    }, null),\n    filterNullish(),\n    mergeMap((i) => of(i.value).pipe(delay(i.delay)), 1)\n  );\n}\n\nexport function observableToComputed<T>(obs: IObservableValue<T>): IComputedValue<T> {\n  return computed(() => obs.get());\n}\n\nexport function computedToStream<T>(comp: IComputedValue<T> | IObservableValue<T>): Observable<T> {\n  const stream = new ReplaySubject<T>(1);\n  reaction(\n    () => comp.get(),\n    (value) => {\n      if (value != null) stream.next(value);\n    },\n    { fireImmediately: true }\n  );\n  return stream;\n}\n\nexport function observableToStream<T>(obs: T): Observable<T> {\n  const stream = new ReplaySubject<T>(1);\n  reaction(\n    () => toJS(obs),\n    (value) => {\n      if (value != null) stream.next(value);\n    },\n    { fireImmediately: true }\n  );\n  return stream;\n}\n\nexport function streamToComputed<T>(stream$: Observable<T>): IComputedValue<T | undefined> {\n  const value = observable.box<T | undefined>();\n  stream$.subscribe((val) => runInAction(() => value.set(val)));\n  return computed(() => value.get());\n}\n\nexport async function streamToDefinedComputed<T>(stream$: Observable<T>): Promise<IComputedValue<T>> {\n  const value = observable.box<T>();\n  stream$.subscribe((val) => runInAction(() => value.set(val)));\n  const computedValue = computed(() => value.get());\n  await awaitValue(computedValue);\n  return computedValue as IComputedValue<T>;\n}\n\n/**\n *\n * @param stream$ RxJS observable to check for the given value\n * @param predicate Predicate to check\n * @returns A promise that resolves with the requested value once the predicate is true\n */\nexport async function awaitStreamValue<T>(\n  stream$: Observable<T>,\n  predicate: (value: T) => boolean = (value) => value != null\n): Promise<T> {\n  const [resolve, , promise] = deferred<T>();\n  stream$.pipe(first(predicate)).subscribe(resolve);\n  return promise;\n}\n\n/**\n * Turns a stream into an updating object for easy access outside of rxjs\n * @param stream$ Stream to turn into a wrapped value\n * @returns Object with `current` key corresponding to last stream value\n */\nexport async function streamToWrappedValue<T>(stream$: Observable<T>): Promise<{ current: T }> {\n  const value: { current?: T } = {};\n  stream$.subscribe((v) => (value.current = v));\n  value.current = await awaitStreamValue(stream$);\n  return value as { current: T };\n}\n","/**\n * UUID.core.js - UUID.js for Minimalists\n *\n * @file\n * @author  LiosK\n * @version v4.2.0\n * @license Apache License 2.0: Copyright (c) 2010-2018 LiosK\n * @url https://github.com/LiosK/UUID.js/blob/master/src/uuid.core.js\n */\n\n/**\n * @class\n * @classdesc {@link UUID} object.\n * @hideconstructor\n */\n\n// Core Component {{{\n\n/**\n * Generates a version 4 UUID as a hexadecimal string.\n * @returns {string} Hexadecimal UUID string.\n */\nexport const uuid = function () {\n  const rand = _getRandomInt,\n    hex = _hexAligner;\n  return (\n    hex(rand(32), 8) + // time_low\n    \"-\" +\n    hex(rand(16), 4) + // time_mid\n    \"-\" +\n    hex(0x4000 | rand(12), 4) + // time_hi_and_version\n    \"-\" +\n    hex(0x8000 | rand(14), 4) + // clock_seq_hi_and_reserved clock_seq_low\n    \"-\" +\n    hex(rand(48), 12)\n  ); // node\n};\n\n/**\n * Returns an unsigned x-bit random integer.\n * @private\n * @param {number} x Unsigned integer ranging from 0 to 53, inclusive.\n * @returns {number} Unsigned x-bit random integer (0 <= f(x) < 2^x).\n */\nconst _getRandomInt = function (x: number) {\n  if (x < 0 || x > 53) {\n    return NaN;\n  }\n  const n = 0 | (Math.random() * 0x40000000); // 1 << 30\n  return x > 30 ? n + (0 | (Math.random() * (1 << (x - 30)))) * 0x40000000 : n >>> (30 - x);\n};\n\n/**\n * Converts an integer to a zero-filled hexadecimal string.\n * @private\n * @param {number} num\n * @param {number} length\n * @returns {string}\n */\nconst _hexAligner = function (num: number, length: number) {\n  let str = num.toString(16),\n    i = length - str.length,\n    z = \"0\";\n  for (; i > 0; i >>>= 1, z += z) {\n    if (i & 1) {\n      str = z + str;\n    }\n  }\n  return str;\n};\n","export function sleep<T>(timeout: number, returns?: T): Promise<T> {\n  return new Promise<T>((resolve) => setTimeout(() => resolve(returns as T), timeout));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { deferred } from \"./deferred\";\nimport { sleep } from \"./sleep\";\n\nexport const range = function* (total = 0, step = 1, from = 0) {\n  // eslint-disable-next-line no-empty\n  for (let i = 0; i < total; yield from + i++ * step) {}\n};\n\nexport async function rejectAfter<T>(ms: number, msg: string): Promise<T> {\n  await sleep(ms);\n  throw new Error(msg);\n}\n\nexport const timeoutAfter = async <T>(promise: Promise<T>, ms: number, timeoutMsg: string) => {\n  return Promise.race([promise, rejectAfter<T>(ms, timeoutMsg)]);\n};\n\nexport const callWithRetry = <T>(\n  fn: (...args: any[]) => Promise<T>,\n  args: any[] = [],\n  maxRetries = 10,\n  retryInterval = 1000\n): Promise<T> => {\n  const [resolve, reject, promise] = deferred<T>();\n  const process = async () => {\n    let res: T;\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        res = await fn(...args);\n        resolve(res);\n        break;\n      } catch (e) {\n        if (i < maxRetries - 1) {\n          console.info(\"[CallWithRetry Failed] attempt number=\" + i, fn);\n          console.error(e);\n          await sleep(Math.min(retryInterval * 2 ** i + Math.random() * 100, 15000));\n        } else {\n          reject(e as unknown as Error);\n        }\n      }\n    }\n  };\n  process();\n  return promise;\n};\n","export function makeIterable<T>(iterator: Iterator<T>): IterableIterator<T> {\n  const iterable: IterableIterator<T> = {\n    ...iterator,\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n\n  return iterable;\n}\n\nexport function concatIterators<T>(first: Iterator<T>, second?: Iterator<T>): IterableIterator<T> {\n  if (!second) return makeIterable(first);\n  return makeIterable({\n    next() {\n      const next = first.next();\n      if (!next.done) return next;\n      return second.next();\n    },\n  });\n}\n\nexport function mergeIterators<A, B>(iteratorA: Iterator<A>, iteratorB: Iterator<B>): IterableIterator<[A, B]> {\n  const iterator: Iterator<[A, B]> = {\n    next() {\n      const nextA = iteratorA.next();\n      const nextB = iteratorB.next();\n      if (nextA.done && nextB.done) return { done: true, value: null };\n      return { value: [nextA.value, nextB.value] };\n    },\n  };\n  return makeIterable(iterator);\n}\n\nexport function transformIterator<A, B>(iterator: Iterator<A>, transform: (value: A) => B): IterableIterator<B> {\n  return makeIterable({\n    next() {\n      const { done, value } = iterator.next();\n      return { done, value: done ? value : transform(value) };\n    },\n  });\n}\n\n/**\n * Turns an array into an iterator. NOTE: an iterator can only be iterated once.\n * @param array Array to be turned into an iterator\n * @returns Iterator to iterate through the array\n */\nexport function arrayToIterator<T>(array: T[]): IterableIterator<T> {\n  let i = 0;\n  const iterator: Iterator<T> = {\n    next() {\n      const done = i >= array.length;\n      if (done) return { done, value: null };\n      return { value: array[i++] };\n    },\n  };\n  return makeIterable(iterator);\n}\n","import { Area, Coord } from \"./types\";\n\nexport function areaContains(area: Area, coord: Coord) {\n  return coord.x >= area.x && coord.y >= area.y && coord.x < area.x + area.width && coord.y < area.y + area.height;\n}\n\nexport function coordsOf(area: Area) {\n  const coords: Coord[] = [];\n  for (let dx = 0; dx < area.width; dx++) {\n    for (let dy = 0; dy < area.height; dy++) {\n      coords.push({ x: area.x + dx, y: area.y + dy });\n    }\n  }\n  return coords;\n}\n","import { BigNumber } from \"ethers\";\nimport { keccak256 as keccak256Bytes, toUtf8Bytes } from \"ethers/lib/utils.js\";\nimport { Coord } from \"./types\";\n\nimport { defaultAbiCoder as abi } from \"ethers/lib/utils.js\";\n\n/**\n * Compute keccak256 hash from given string and remove padding from the resulting hex string\n * @param data String to be hashed\n * @returns Hash of the given string as hex string without padding\n */\nexport function keccak256(data: string) {\n  return BigNumber.from(keccak256Bytes(toUtf8Bytes(data))).toHexString();\n}\n\nexport function keccak256Coord(coord: Coord): string {\n  // TODO: make faster by implementing in wasm\n  const bytes = abi.encode([\"int32\", \"int32\"], [coord.x, coord.y]);\n  return keccak256Bytes(bytes);\n}\n","import { fromEvent, map, Observable } from \"rxjs\";\n\nexport interface DoWork<In, Out> {\n  work(input$: Observable<In>): Observable<Out>;\n}\n\nexport function fromWorker<I, O>(worker: Worker, input$: Observable<I>): Observable<O> {\n  input$.subscribe((event) => worker.postMessage(event));\n  return fromEvent<MessageEvent<O>>(worker, \"message\").pipe(map((e) => e.data));\n}\n\nexport function runWorker<I, O>(worker: DoWork<I, O>) {\n  const input$ = fromEvent<MessageEvent<I>>(self, \"message\");\n  const output$ = worker.work(input$.pipe(map((event) => event.data)));\n  output$.subscribe((event) => self.postMessage(event));\n}\n","function rightMask(input: number, keep: number): number {\n  return input & (2 ** keep - 1);\n}\n\n/**\n * Packs two unsigned integers in one 32 bit unsigned integer\n * @param numbers Unsigned integers to be packed in 32 bit integer\n * @param bitsPerNumber Bits for each number\n * @returns Packed 32 bit unsigned integer\n */\nexport function pack(numbers: number[], bitsPerNumber: number[]): number {\n  // Total number of bits must be 32\n  if (bitsPerNumber.reduce((acc, curr) => acc + curr, 0) > 32) {\n    throw new Error(\"JS pretends integers are 32 bit when bitshifts are involved\");\n  }\n\n  // Array lengths must match\n  if (numbers.length !== bitsPerNumber.length) throw new Error(\"Arrays' lengths must match\");\n\n  // Numbers must fit in number of bits and must be unsigned\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < 0) {\n      throw new Error(\"Underflow: can only pack unsigned integer\");\n    }\n    if (numbers[i] > 2 ** bitsPerNumber[i] - 1) {\n      const error = `Overflow: ${numbers[i]} does not fit in ${bitsPerNumber[i]} bits`;\n      throw new Error(error);\n    }\n  }\n\n  // Pack number\n  let packed = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    packed = (packed << bitsPerNumber[i]) | numbers[i];\n  }\n  return packed;\n}\n\n/**\n * Unpacks a packed 32 bit unsigned integer into the original unsigned integers\n * @param packed Packed 32 bit unsigned integer\n * @param bitsPerNumber Bits for each unsigned integer\n * @returns Array of unpacked unsignd integers\n */\nexport function unpack(packed: number, bitsPerNumber: number[]): number[] {\n  const numbers: number[] = [];\n  let shiftedPacked = packed;\n  for (let i = bitsPerNumber.length - 1; i >= 0; i--) {\n    numbers.unshift(rightMask(shiftedPacked, bitsPerNumber[i]));\n    shiftedPacked = shiftedPacked >>> bitsPerNumber[i];\n  }\n  return numbers;\n}\n\nexport function packTuple(numbers: [number, number]): number {\n  return pack(numbers, [8, 24]);\n}\n\nexport function unpackTuple(packed: number): [number, number] {\n  return unpack(packed, [8, 24]) as [number, number];\n}\n","import { Coord } from \"./types\";\nimport { transformIterator } from \"./iterable\";\n\nconst LOWER_HALF_MASK = 2 ** 16 - 1;\nconst MAX_SUPPORTED = 2 ** 15 - 1;\n\nexport function subtract(from: CoordMap<boolean>, subtract: CoordMap<boolean>): CoordMap<boolean> {\n  const result = new CoordMap<boolean>();\n\n  for (const coord of from.coords()) {\n    if (subtract.get(coord)) continue;\n    result.set(coord, true);\n  }\n\n  return result;\n}\n\nexport function coordToKey(coord: Coord) {\n  const key = (coord.x << 16) | (coord.y & LOWER_HALF_MASK);\n  return key;\n\n  // Old version using strings:\n  // return `${coord.x}/${coord.y}`;\n}\n\nexport function keyToCoord(key: number): Coord {\n  const x = key >> 16;\n  const y = (key << 16) >> 16;\n  return { x, y };\n\n  // Old version using strings:\n  // const fragments = key.split(\"/\");\n  // return { x: Number(fragments[0]), y: Number(fragments[1]) };\n}\n\nexport class CoordMap<T> {\n  map: Map<number, T>;\n  defaultValue?: T;\n\n  constructor(props?: { defaultValue?: T }) {\n    this.map = new Map<number, T>();\n    this.defaultValue = props?.defaultValue;\n  }\n\n  static from<T>(coordMapLike: { map: Map<number, T>; defaultValue?: T }): CoordMap<T> {\n    const coordMap = new CoordMap<T>();\n    coordMap.map = coordMapLike.map;\n    coordMap.defaultValue = coordMapLike.defaultValue;\n    return coordMap;\n  }\n\n  set(coord: Coord, value: T) {\n    if (\n      coord.x > MAX_SUPPORTED ||\n      coord.x < -1 * MAX_SUPPORTED ||\n      coord.y > MAX_SUPPORTED ||\n      coord.y < -1 * MAX_SUPPORTED\n    ) {\n      throw new Error(`CoordMap only supports coords up to ${MAX_SUPPORTED}`);\n    }\n    return this.map.set(coordToKey(coord), value);\n  }\n\n  get(coord: Coord) {\n    return this.map.get(coordToKey(coord)) ?? this.defaultValue;\n  }\n\n  keys() {\n    return this.map.keys();\n  }\n\n  coords(): IterableIterator<Coord> {\n    return transformIterator(this.map.keys(), (key) => keyToCoord(key));\n  }\n\n  entries() {\n    return this.map.entries();\n  }\n\n  toArray(): [Coord, T][] {\n    const entries = Array.from(this.map.entries());\n    return entries.map(([key, value]) => [keyToCoord(key), value]);\n  }\n\n  values() {\n    return this.map.values();\n  }\n\n  delete(coord: Coord) {\n    return this.map.delete(coordToKey(coord));\n  }\n\n  has(coord: Coord): boolean {\n    return this.map.has(coordToKey(coord));\n  }\n\n  clear() {\n    for (const key of this.map.keys()) {\n      this.map.delete(key);\n    }\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n}\n","import { VoxelCoord } from \"./types\";\nimport { transformIterator } from \"./iterable\";\n\nfunction coordToKey(coord: VoxelCoord) {\n  // TODO: find a more memory efficient way to store these keys\n  return `${coord.x}/${coord.y}/${coord.z}`;\n}\n\nfunction keyToCoord(key: string): VoxelCoord {\n  const fragments = key.split(\"/\");\n  return { x: Number(fragments[0]), y: Number(fragments[1]), z: Number(fragments[2]) };\n}\n\nexport class VoxelCoordMap<T> {\n  map: Map<string, T>;\n  defaultValue?: T;\n\n  constructor(props?: { defaultValue?: T }) {\n    this.map = new Map<string, T>();\n    this.defaultValue = props?.defaultValue;\n  }\n\n  static from<T>(coordMapLike: { map: Map<string, T>; defaultValue?: T }): VoxelCoordMap<T> {\n    const coordMap = new VoxelCoordMap<T>();\n    coordMap.map = coordMapLike.map;\n    coordMap.defaultValue = coordMapLike.defaultValue;\n    return coordMap;\n  }\n\n  set(coord: VoxelCoord, value: T) {\n    return this.map.set(coordToKey(coord), value);\n  }\n\n  get(coord: VoxelCoord) {\n    return this.map.get(coordToKey(coord)) ?? this.defaultValue;\n  }\n\n  keys() {\n    return this.map.keys();\n  }\n\n  coords(): IterableIterator<VoxelCoord> {\n    return transformIterator(this.map.keys(), (key) => keyToCoord(key));\n  }\n\n  entries() {\n    return this.map.entries();\n  }\n\n  toArray(): [VoxelCoord, T][] {\n    const entries = Array.from(this.map.entries());\n    return entries.map(([key, value]) => [keyToCoord(key), value]);\n  }\n\n  values() {\n    return this.map.values();\n  }\n\n  delete(coord: VoxelCoord) {\n    return this.map.delete(coordToKey(coord));\n  }\n\n  has(coord: VoxelCoord): boolean {\n    return this.map.has(coordToKey(coord));\n  }\n\n  clear() {\n    for (const key of this.map.keys()) {\n      this.map.delete(key);\n    }\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n}\n","/**\n * Pads start of a hex string with 0 to create a bit string of the given length\n * @param input Hex string\n * @param bits Number of bits in the output hex string\n * @returns Hex string of specified length\n */\nexport function padToBitLength(input: string, bits: number) {\n  // Cut off 0x prefix\n  if (input.substring(0, 2) == \"0x\") input = input.substring(2);\n  // Pad start with 0 to get desired bit length\n  const length = bits / 4;\n  input = input.padStart(length, \"0\");\n  input = input.substring(input.length - length);\n  // Prefix with 0x\n  return `0x${input}`;\n}\n\n/**\n * Pads start of a hex string with 0 to create a 160 bit hex string\n * which can be used as an Ethereum address\n * @param input Hex string\n * @returns 160 bit hex string\n */\nexport function toEthAddress(input: string) {\n  return padToBitLength(input, 160);\n}\n\n/**\n * Pads start of a hex string with 0 to create a 256bit hex string\n * which can be used as an Ethereum address\n * @param input Hex string\n * @returns 256 bit hex string\n */\nexport function to256BitString(input: string) {\n  return padToBitLength(input, 256);\n}\n\nexport function extractEncodedArguments(input: string) {\n  // Cutting off the first 4 bytes, which represent the function selector\n  if (input[0] !== \"0\" && input[1] !== \"x\") throw new Error(\"Invalid hex string\");\n  return \"0x\" + input.substring(10);\n}\n","const RND_A = 134775813;\nconst RND_B = 1103515245;\nconst ACCURACY = 1000;\n\nexport function randomize(seed: number, x: number, y: number) {\n  return (((((x ^ y) * RND_A) ^ (seed + x)) * (((RND_B * x) << 16) ^ (RND_B * y - RND_A))) >>> 0) / 4294967295;\n}\n\nexport function tile(coordinate: number, period: number) {\n  if (coordinate < 0) while (coordinate < 0) coordinate += period;\n  return coordinate % period;\n}\n\nexport function interpolate(a: number, b: number, c: number, d: number, x: number, s: number, scale: number) {\n  const p = d - c - (a - b);\n  return (b * Math.pow(s, 3) + x * (c * Math.pow(s, 2) + a * s * (-s + x) + x * (-(b + p) * s + p * x))) * scale;\n\n  // return (x) * ((x ) * ((x ) * p + (a - b - p)) + (c - a)) + b;\n}\n\n/**\n * Config a cubic noise.\n * @param {Number} seed A seed in the range [0, 1].\n * @param {Number} [periodX] The number of units after which the x coordinate repeats.\n * @param {Number} [periodY] The number of units after which the y coordinate repeats.\n * @returns {Object} A configuration object used by noise functions.\n */\nexport function cubicNoiseConfig(\n  seed: number,\n  octave: number,\n  scale: number,\n  periodX = Number.MAX_SAFE_INTEGER,\n  periodY = Number.MAX_SAFE_INTEGER\n) {\n  return {\n    seed: Math.floor(seed * Number.MAX_SAFE_INTEGER),\n    periodX: periodX,\n    periodY: periodY,\n    octave,\n    scale,\n  };\n}\n\n/**\n * Sample 1D cubic noise.\n * @param {Object} config A valid noise configuration.\n * @param {Number} x The X position to sample at.\n * @returns {Number} A noise value in the range [0, 1].\n */\nexport function cubicNoiseSample1(config: ReturnType<typeof cubicNoiseConfig>, x: number) {\n  const xi = Math.floor(x);\n  const lerp = x - xi;\n\n  return (\n    interpolate(\n      randomize(config.seed, tile(xi - 1, config.periodX), 0),\n      randomize(config.seed, tile(xi, config.periodX), 0),\n      randomize(config.seed, tile(xi + 1, config.periodX), 0),\n      randomize(config.seed, tile(xi + 2, config.periodX), 0),\n      lerp,\n      1,\n      1\n    ) *\n      0.666666 +\n    0.166666\n  );\n}\n\n/**\n * Sample 2D cubic noise.\n * @param {Object} config A valid noise configuration.\n * @param {Number} x The X position to sample at.\n * @param {Number} y The Y position to sample at.\n * @returns {Number} A noise value in the range [0, 1].\n */\nexport function cubicNoiseSample2(\n  { octave, periodX, periodY, seed, scale }: ReturnType<typeof cubicNoiseConfig>,\n  x: number,\n  y: number\n) {\n  const xi = Math.floor(x / octave);\n  const lerpX = Math.floor((x * ACCURACY) / octave) - xi * ACCURACY;\n  const yi = Math.floor(y / octave);\n  const lerpY = Math.floor((y * ACCURACY) / octave) - yi * ACCURACY;\n  const x0 = tile(xi - 1, periodX);\n  const x1 = tile(xi, periodX);\n  const x2 = tile(xi + 1, periodX);\n  const x3 = tile(xi + 2, periodX);\n\n  const xSamples = new Array(4);\n\n  for (let i = 0; i < 4; ++i) {\n    const y = tile(yi - 1 + i, periodY);\n\n    xSamples[i] = interpolate(\n      randomize(seed, x0, y),\n      randomize(seed, x1, y),\n      randomize(seed, x2, y),\n      randomize(seed, x3, y),\n      lerpX,\n      ACCURACY,\n      1\n    );\n  }\n\n  return Math.floor(\n    interpolate(xSamples[0], xSamples[1], xSamples[2], xSamples[3], lerpY, ACCURACY, scale) / Math.pow(ACCURACY, 6)\n  );\n}\n","const TOPICS_KEY = \"mud-logger-topics\";\n\nexport function enableLogger() {\n  const windowConsole = window.console;\n  let filtersActive = Boolean(localStorage.getItem(TOPICS_KEY));\n\n  const topicsString = localStorage.getItem(TOPICS_KEY);\n  let topics: string[] = topicsString ? JSON.parse(topicsString) : [];\n\n  function log(...logs: string[]) {\n    if (filtersActive) return;\n    windowConsole.log(...logs);\n  }\n\n  function logWithTopic(topic: string, ...logs: string[]) {\n    if (!filtersActive || topics.includes(topic)) {\n      windowConsole.log(`--- BETTER CONSOLE / TOPIC ${topic} ---`);\n      windowConsole.log(...logs);\n    }\n  }\n\n  function enableFilters() {\n    localStorage.setItem(TOPICS_KEY, JSON.stringify([]));\n    filtersActive = true;\n  }\n\n  function disableFilters() {\n    localStorage.removeItem(TOPICS_KEY);\n    filtersActive = false;\n  }\n\n  function addTopic(topic: string) {\n    topics.push(topic);\n    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));\n  }\n\n  function removeTopic(topic: string) {\n    topics = topics.filter((t) => t !== topic);\n    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));\n  }\n\n  function resetTopics() {\n    topics = [];\n    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));\n  }\n\n  const logger = {\n    ...windowConsole,\n    log,\n    logWithTopic,\n    enableFilters,\n    disableFilters,\n    addTopic,\n    removeTopic,\n    resetTopics,\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (window as any).logger = logger;\n  window.console = logger;\n  return logger;\n}\n","/**\n * Compute the Euclidean distance between two points\n * https://en.wikipedia.org/wiki/Euclidean_distance\n * @param a\n * @param b\n * @returns Euclidian distance between a and b\n */\nexport function euclidean(a: number[], b: number[]): number {\n  if (a.length !== b.length) throw new Error(\"points must have same dimension\");\n  return Math.sqrt(a.reduce((acc, _, i) => acc + Math.pow(a[i] - b[i], 2), 0));\n}\n","/**\n * For positive inputs: returns the greatest integer less than or equal to its numeric argument.\n * For negative inputs: returns the smallest integer greater than or equal to its numeric argument.\n *\n * @param x A numeric expression.\n * @returns Input rounded towards zero.\n */\nexport function roundTowardsZero(x: number) {\n  const sign = x < 0 ? -1 : 1;\n  return sign * Math.floor(Math.abs(x));\n}\n","// TODO: migrate to viem's toHex()\nexport const arrayToHex = (array: Uint8Array | ArrayBuffer): `0x${string}` =>\n  `0x${[...new Uint8Array(array)].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\")}`;\n","export const bytesToString = (bytes: Uint8Array): string => [...bytes].map((x) => String.fromCharCode(x)).join(\"\");\n","// TODO: migrate to viem's isHex()\n// Note that this assumes hex pairs, but viem does not. We'll need to be careful migrating.\n// Padding an odd-length hex sounds scary (based on how Solidity left/right aligns numbers vs bytes/strings).\nexport function isHex(hex: string): boolean {\n  return /^(0x)?([\\da-f]{2})*$/i.test(hex);\n}\n","import { isHex } from \"./isHex\";\n\n// TODO: migrate to viem's toBytes(hex)\nexport const hexToArray = (hex: string): Uint8Array => {\n  if (!isHex(hex)) {\n    console.error(\"Invalid hex string\", hex);\n    throw new Error(\"Invalid hex string\");\n  }\n  const bytes = hex.match(/[\\da-f]{2}/gi);\n  if (!bytes) return new Uint8Array([]);\n  return new Uint8Array(bytes.map((byte) => parseInt(byte, 16)));\n};\n","export const stringToBytes16 = (str: string): Uint8Array => {\n  if (str.length > 16) throw new Error(\"string too long\");\n  return new Uint8Array(16).map((v, i) => str.charCodeAt(i));\n};\n\nexport const stringToBytes32 = (str: string): Uint8Array => {\n  if (str.length > 32) throw new Error(\"string too long\");\n  return new Uint8Array(32).map((v, i) => str.charCodeAt(i));\n};\n","import { toEthAddress } from \"./eth\";\nimport { hexToArray } from \"./v2\";\n\nexport function formatHex(hex: string): string {\n  if (hex.substring(0, 2) == \"0x\") hex = hex.substring(2);\n  const prefix = hex.length % 2 !== 0 ? \"0x0\" : \"0x\";\n  return prefix + hex;\n}\n\nexport function hexStringToUint8Array(hexString: string): Uint8Array {\n  return hexToArray(hexString);\n}\n\nexport function Uint8ArrayToHexString(data: Uint8Array): string {\n  if (data.length === 0) return \"0x00\";\n  return formatHex(data.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\"));\n}\n\nexport function concatUint8Arrays(...arrays: Uint8Array[]): Uint8Array {\n  return Uint8Array.from(\n    arrays.reduce<number[]>((acc, curr) => {\n      return [...acc, ...curr];\n    }, [])\n  );\n}\n\nexport function splitUint8Arrays(data: Uint8Array, byteLengths: number[]): Uint8Array[] {\n  const arrays: Uint8Array[] = [];\n  let i = 0;\n  for (const length of byteLengths) {\n    const array = new Uint8Array(length);\n    arrays.push(array);\n    for (let j = 0; j < length; j++) {\n      array[j] = data[i];\n      i++;\n    }\n  }\n  return arrays;\n}\n\nexport function Int32ArrayToUint8Array(input: number[]): Uint8Array {\n  const buffer = new ArrayBuffer(input.length * 4);\n  const int32arr = new Int32Array(buffer);\n  for (let i = 0; i < input.length; i++) {\n    int32arr[i] = input[i];\n  }\n  return new Uint8Array(buffer);\n}\n\nexport function Uint8ArrayToInt32Array(input: Uint8Array): number[] {\n  return [...new Int32Array(input.buffer)];\n}\n\nexport function ethAddressToUint8Array(address: string): Uint8Array {\n  return hexStringToUint8Array(toEthAddress(address));\n}\n\n// https://stackoverflow.com/a/55330424\nexport function createToInt(size: number) {\n  if (size < 2) {\n    throw new Error(\"Minimum size is 2\");\n  } else if (size > 64) {\n    throw new Error(\"Maximum size is 64\");\n  }\n\n  // Determine value range\n  const maxValue = 2 ** (size - 1) - 1;\n  const minValue = -maxValue - 1;\n\n  return (value: number) => {\n    value = value << 0;\n    if (value > maxValue || value < minValue) {\n      console.log(\"value\", value, maxValue, minValue, value > maxValue, value < minValue);\n      throw new Error(`Int${size} overflow`);\n    }\n\n    if (value < 0) {\n      return 2 ** size + value;\n    } else {\n      return value;\n    }\n  };\n}\n\nexport const toInt32 = createToInt(32);\n"],"mappings":"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","names":["isNotEmpty","array","filterNullishValues","value","deferred","resolve","reject","promise","r","rj","t","e","reaction","awaitValue","comp","resolve","promise","deferred","dispose","reaction","value","isObject","c","isFunction","reaction","DeepProxy","deepAccess","target","path","next","rest","nextTarget","isObject","cacheUntilReady","callQueue","proxiedTarget","DeepProxy","_t","prop","targetReady","_","thisArg","args","targetFunc","isFunction","resolve","reject","promise","deferred","reaction","queuedCalls","e","numValues","enm","nums","val","mapObject","source","valueMap","target","key","random","to","from","pickRandom","array","concatMap","delay","filter","first","mergeMap","of","pipe","ReplaySubject","scan","timestamp","computed","observable","reaction","runInAction","toJS","filterNullish","pipe","filter","x","awaitPromise","concatMap","stretch","spacingDelayMs","timestamp","scan","acc","curr","delay","timeDelta","mergeMap","i","of","observableToComputed","obs","computed","computedToStream","comp","stream","ReplaySubject","reaction","value","observableToStream","toJS","streamToComputed","stream$","observable","val","runInAction","streamToDefinedComputed","computedValue","awaitValue","awaitStreamValue","predicate","resolve","promise","deferred","first","streamToWrappedValue","v","uuid","rand","_getRandomInt","hex","_hexAligner","x","n","num","length","str","i","z","sleep","timeout","returns","resolve","range","total","step","from","i","rejectAfter","ms","msg","sleep","timeoutAfter","promise","timeoutMsg","callWithRetry","fn","args","maxRetries","retryInterval","resolve","reject","deferred","res","e","makeIterable","iterator","concatIterators","first","second","next","mergeIterators","iteratorA","iteratorB","nextA","nextB","transformIterator","transform","done","value","arrayToIterator","array","i","areaContains","area","coord","coordsOf","coords","dx","dy","BigNumber","keccak256Bytes","toUtf8Bytes","abi","keccak256","data","keccak256Coord","coord","bytes","fromEvent","map","fromWorker","worker","input$","event","e","runWorker","rightMask","input","keep","pack","numbers","bitsPerNumber","acc","curr","i","error","packed","unpack","shiftedPacked","packTuple","unpackTuple","LOWER_HALF_MASK","MAX_SUPPORTED","subtract","from","result","CoordMap","coord","coordToKey","keyToCoord","key","x","y","props","coordMapLike","coordMap","value","transformIterator","coordToKey","coord","keyToCoord","key","fragments","VoxelCoordMap","props","coordMapLike","coordMap","value","transformIterator","padToBitLength","input","bits","length","toEthAddress","to256BitString","extractEncodedArguments","randomize","seed","x","y","tile","coordinate","period","interpolate","a","b","c","d","s","scale","p","cubicNoiseConfig","octave","periodX","periodY","cubicNoiseSample1","config","xi","lerp","cubicNoiseSample2","lerpX","yi","lerpY","x0","x1","x2","x3","xSamples","i","TOPICS_KEY","enableLogger","windowConsole","filtersActive","topicsString","topics","log","logs","logWithTopic","topic","enableFilters","disableFilters","addTopic","removeTopic","t","resetTopics","logger","euclidean","a","b","acc","_","i","roundTowardsZero","x","arrayToHex","array","x","bytesToString","bytes","x","isHex","hex","hexToArray","hex","isHex","bytes","byte","stringToBytes16","str","v","i","stringToBytes32","formatHex","hex","hexStringToUint8Array","hexString","hexToArray","Uint8ArrayToHexString","data","str","byte","concatUint8Arrays","arrays","acc","curr","splitUint8Arrays","byteLengths","i","length","array","j","Int32ArrayToUint8Array","input","buffer","int32arr","Uint8ArrayToInt32Array","ethAddressToUint8Array","address","toEthAddress","createToInt","size","maxValue","minValue","value","toInt32"]}