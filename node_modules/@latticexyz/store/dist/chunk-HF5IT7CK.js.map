{"version":3,"sources":["../ts/config/defaults.ts","../ts/config/storeConfig.ts"],"sourcesContent":["export const PATH_DEFAULTS = {\n  storeImportPath: \"@latticexyz/store/src/\",\n  userTypesFilename: \"common.sol\",\n  codegenDirectory: \"codegen\",\n  codegenIndexFilename: \"index.sol\",\n} as const;\n\nexport const DEFAULTS = {\n  namespace: \"\",\n  enums: {} as Record<string, never>,\n  userTypes: {} as Record<string, never>,\n} as const;\n\nexport const TABLE_DEFAULTS = {\n  directory: \"tables\",\n  keySchema: { key: \"bytes32\" },\n  tableIdArgument: false,\n  storeArgument: true,\n  offchainOnly: false,\n} as const;\n","import { AbiType, AbiTypes, StaticAbiType, StaticAbiTypes, StaticArray } from \"@latticexyz/schema-type/deprecated\";\nimport { RefinementCtx, z, ZodIssueCode } from \"zod\";\nimport type {\n  AsDependent,\n  ExtractUserTypes,\n  OrDefaults,\n  RequireKeys,\n  StringForUnion,\n} from \"@latticexyz/common/type-utils\";\nimport {\n  // validation utils\n  getDuplicates,\n  parseStaticArray,\n  STORE_NAME_MAX_LENGTH,\n  // config\n  MUDCoreUserConfig,\n  // schemas\n  zObjectName,\n  zUserEnum,\n  zValueName,\n  zNamespace,\n  zName,\n} from \"@latticexyz/config\";\nimport { DEFAULTS, PATH_DEFAULTS, TABLE_DEFAULTS } from \"./defaults\";\nimport { UserType } from \"@latticexyz/common/codegen\";\nimport { SchemaAbiType } from \"@latticexyz/schema-type\";\n\nconst zTableName = zObjectName;\nconst zKeyName = zValueName;\nconst zColumnName = zValueName;\nconst zUserEnumName = zObjectName;\nconst zUserTypeName = zObjectName;\n\n// Fields can use AbiType or one of user-defined wrapper types\n// (user types are refined later, based on the appropriate config options)\nconst zFieldData = z.string();\n\nexport type FieldData<UserTypes extends StringForUnion> = AbiType | StaticArray | UserTypes;\n\n// Primary keys allow only static types\n// (user types are refined later, based on the appropriate config options)\nconst zKeyElementSchema = z.string();\nconst zKeySchema = z.record(zKeyName, zKeyElementSchema).default(TABLE_DEFAULTS.keySchema);\n\ntype KeySchema<StaticUserTypes extends StringForUnion> = StaticAbiType | StaticUserTypes;\n\n/************************************************************************\n *\n *    TABLE SCHEMA\n *\n ************************************************************************/\n\nexport type FullSchemaConfig<UserTypes extends StringForUnion = StringForUnion> = Record<string, FieldData<UserTypes>>;\nexport type ShorthandSchemaConfig<UserTypes extends StringForUnion = StringForUnion> = FieldData<UserTypes>;\nexport type SchemaConfig<UserTypes extends StringForUnion = StringForUnion> =\n  | FullSchemaConfig<UserTypes>\n  | ShorthandSchemaConfig<UserTypes>;\n\nexport type ExpandSchemaConfig<TSchemaConfig extends SchemaConfig<string>> =\n  TSchemaConfig extends ShorthandSchemaConfig<string> ? { value: TSchemaConfig } : TSchemaConfig;\n\nconst zFullSchemaConfig = z\n  .record(zColumnName, zFieldData)\n  .refine((arg) => Object.keys(arg).length > 0, \"Table schema may not be empty\");\n\nconst zShorthandSchemaConfig = zFieldData.transform((fieldData) => {\n  return zFullSchemaConfig.parse({\n    value: fieldData,\n  });\n});\n\nexport const zSchemaConfig = zFullSchemaConfig.or(zShorthandSchemaConfig);\n\ntype ResolvedSchema<TSchema extends Record<string, string>, TUserTypes extends Record<string, UserType>> = {\n  [key in keyof TSchema]: TSchema[key] extends keyof TUserTypes\n    ? TUserTypes[TSchema[key]][\"internalType\"]\n    : TSchema[key];\n};\n\n// TODO: add strong types to UserTypes config and use them here\n// (see https://github.com/latticexyz/mud/pull/1588)\nexport function resolveUserTypes<TSchema extends Record<string, string>, TUserTypes extends Record<string, UserType>>(\n  schema: TSchema,\n  userTypes: TUserTypes\n): ResolvedSchema<TSchema, TUserTypes> {\n  const resolvedSchema: Record<string, SchemaAbiType> = {};\n  for (const [key, value] of Object.entries(schema)) {\n    resolvedSchema[key] = (userTypes[value]?.internalType as SchemaAbiType) ?? value;\n  }\n  return resolvedSchema as ResolvedSchema<TSchema, TUserTypes>;\n}\n\n/************************************************************************\n *\n *    TABLE\n *\n ************************************************************************/\n\nexport interface TableConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> {\n  /** Output directory path for the file. Default is \"tables\" */\n  directory?: string;\n  /** Make methods accept `tableId` argument instead of it being a hardcoded constant. Default is false */\n  tableIdArgument?: boolean;\n  /** Include methods that accept a manual `IStore` argument. Default is true. */\n  storeArgument?: boolean;\n  /** Include a data struct and methods for it. Default is false for 1-column tables; true for multi-column tables. */\n  dataStruct?: boolean;\n  /** Offchain tables don't write to onchain storage, but only emit events for offchain clients. Default is false. */\n  offchainOnly?: boolean;\n  /**\n   * Table's key names mapped to their types.\n   * Default is `{ key: \"bytes32\" }`\n   * Key names' first letter should be lowercase.\n   */\n  keySchema?: Record<string, KeySchema<StaticUserTypes>>;\n  /**\n   * Table's field names mapped to their types.\n   * Field names' first letter should be lowercase.\n   */\n  valueSchema: SchemaConfig<UserTypes>;\n}\n\nexport type FullTableConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> = Required<TableConfig<UserTypes, StaticUserTypes>> & {\n  valueSchema: FullSchemaConfig<UserTypes>;\n};\n\nexport interface ExpandTableConfig<T extends TableConfig<string, string>, TableName extends string>\n  extends OrDefaults<\n    T,\n    {\n      directory: typeof TABLE_DEFAULTS.directory;\n      name: TableName;\n      tableIdArgument: typeof TABLE_DEFAULTS.tableIdArgument;\n      storeArgument: typeof TABLE_DEFAULTS.storeArgument;\n      // dataStruct isn't expanded, because its value is conditional on the number of value schema fields\n      dataStruct: boolean;\n      keySchema: typeof TABLE_DEFAULTS.keySchema;\n      offchainOnly: typeof TABLE_DEFAULTS.offchainOnly;\n    }\n  > {\n  valueSchema: ExpandSchemaConfig<T[\"valueSchema\"]>;\n}\n\nconst zFullTableConfig = z\n  .object({\n    directory: z.string().default(TABLE_DEFAULTS.directory),\n    name: zName.optional(),\n    tableIdArgument: z.boolean().default(TABLE_DEFAULTS.tableIdArgument),\n    storeArgument: z.boolean().default(TABLE_DEFAULTS.storeArgument),\n    dataStruct: z.boolean().optional(),\n    keySchema: zKeySchema,\n    valueSchema: zSchemaConfig,\n    offchainOnly: z.boolean().default(TABLE_DEFAULTS.offchainOnly),\n  })\n  .transform((arg) => {\n    // default dataStruct value depends on value schema's length\n    if (Object.keys(arg.valueSchema).length === 1) {\n      arg.dataStruct ??= false;\n    } else {\n      arg.dataStruct ??= true;\n    }\n    return arg as RequireKeys<typeof arg, \"dataStruct\">;\n  });\n\nconst zShorthandTableConfig = zFieldData.transform((fieldData) => {\n  return zFullTableConfig.parse({\n    valueSchema: {\n      value: fieldData,\n    },\n  });\n});\n\nexport const zTableConfig = zFullTableConfig.or(zShorthandTableConfig);\n\n/************************************************************************\n *\n *    TABLES\n *\n ************************************************************************/\n\nexport type TablesConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> = Record<string, TableConfig<UserTypes, StaticUserTypes> | FieldData<UserTypes>>;\n\nexport const zTablesConfig = z.record(zTableName, zTableConfig).transform((tables) => {\n  // default name depends on tableName\n  for (const tableName of Object.keys(tables)) {\n    const table = tables[tableName];\n    table.name = tableName.slice(0, STORE_NAME_MAX_LENGTH);\n\n    tables[tableName] = table;\n  }\n  return tables as Record<string, RequireKeys<(typeof tables)[string], \"name\">>;\n});\n\nexport type FullTablesConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> = Record<string, FullTableConfig<UserTypes, StaticUserTypes>>;\n\nexport type ExpandTablesConfig<T extends TablesConfig<string, string>> = {\n  [TableName in keyof T]: T[TableName] extends FieldData<string>\n    ? ExpandTableConfig<{ valueSchema: { value: T[TableName] } }, TableName extends string ? TableName : never>\n    : T[TableName] extends TableConfig<string, string>\n    ? ExpandTableConfig<T[TableName], TableName extends string ? TableName : never>\n    : // Weakly typed values get a weakly typed expansion.\n      // This shouldn't normally happen within `mudConfig`, but can be manually triggered via `ExpandMUDUserConfig`\n      ExpandTableConfig<TableConfig<string, string>, TableName extends string ? TableName : string>;\n};\n\n/************************************************************************\n *\n *    ENUMS\n *\n ************************************************************************/\n\nexport type EnumsConfig<EnumNames extends StringForUnion> = never extends EnumNames\n  ? {\n      /**\n       * Enum names mapped to lists of their member names\n       *\n       * (enums are inferred to be absent)\n       */\n      enums?: Record<EnumNames, string[]>;\n    }\n  : StringForUnion extends EnumNames\n  ? {\n      /**\n       * Enum names mapped to lists of their member names\n       *\n       * (enums aren't inferred - use `mudConfig` or `storeConfig` helper, and `as const` for variables)\n       */\n      enums?: Record<EnumNames, string[]>;\n    }\n  : {\n      /**\n       * Enum names mapped to lists of their member names\n       *\n       * Enums defined here can be used as types in table schemas/keys\n       */\n      enums: Record<EnumNames, string[]>;\n    };\n\nexport type FullEnumsConfig<EnumNames extends StringForUnion> = {\n  enums: Record<EnumNames, string[]>;\n};\n\nexport const zEnumsConfig = z.object({\n  enums: z.record(zUserEnumName, zUserEnum).default(DEFAULTS.enums),\n});\n\n/************************************************************************\n *\n *    USER TYPES\n *\n ************************************************************************/\n\nexport type UserTypesConfig<UserTypeNames extends StringForUnion = StringForUnion> = never extends UserTypeNames\n  ? {\n      /**\n       * User types mapped to file paths from which to import them.\n       * Paths are treated as relative to root.\n       * Paths that don't start with a \".\" have foundry remappings applied to them first.\n       *\n       * (user types are inferred to be absent)\n       */\n      userTypes?: Record<UserTypeNames, UserType>;\n    }\n  : StringForUnion extends UserTypeNames\n  ? {\n      /**\n       * User types mapped to file paths from which to import them.\n       * Paths are treated as relative to root.\n       * Paths that don't start with a \".\" have foundry remappings applied to them first.\n       *\n       * (user types aren't inferred - use `mudConfig` or `storeConfig` helper, and `as const` for variables)\n       */\n      userTypes?: Record<UserTypeNames, UserType>;\n    }\n  : {\n      /**\n       * User types mapped to file paths from which to import them.\n       * Paths are treated as relative to root.\n       * Paths that don't start with a \".\" have foundry remappings applied to them first.\n       *\n       * User types defined here can be used as types in table schemas/keys\n       */\n      userTypes: Record<UserTypeNames, UserType>;\n    };\n\nexport type FullUserTypesConfig<UserTypeNames extends StringForUnion> = {\n  userTypes: Record<UserTypeNames, string>;\n};\n\nconst zUserTypeConfig = z.object({\n  filePath: z.string(),\n  internalType: z.string(),\n});\n\nexport const zUserTypesConfig = z.object({\n  userTypes: z.record(zUserTypeName, zUserTypeConfig).default(DEFAULTS.userTypes),\n});\n\n/************************************************************************\n *\n *    FINAL\n *\n ************************************************************************/\n\n// zod doesn't preserve doc comments\n/** MUDCoreUserConfig wrapper to use generics in some options for better type inference */\nexport type MUDUserConfig<\n  T extends MUDCoreUserConfig = MUDCoreUserConfig,\n  EnumNames extends StringForUnion = StringForUnion,\n  UserTypeNames extends StringForUnion = StringForUnion,\n  StaticUserTypes extends ExtractUserTypes<EnumNames | UserTypeNames> = ExtractUserTypes<EnumNames | UserTypeNames>\n> = T &\n  EnumsConfig<EnumNames> &\n  UserTypesConfig<UserTypeNames> & {\n    /**\n     * Configuration for each table.\n     *\n     * The key is the table name (capitalized).\n     *\n     * The value:\n     *  - abi or user type for a single-value table.\n     *  - FullTableConfig object for multi-value tables (or for customizable options).\n     */\n    tables: TablesConfig<AsDependent<StaticUserTypes>, AsDependent<StaticUserTypes>>;\n    /** The namespace for table ids. Default is \"\" (ROOT) */\n    namespace?: string;\n    /** Path for store package imports. Default is \"@latticexyz/store/src/\" */\n    storeImportPath?: string;\n    /** Filename where common user types will be generated and imported from. Default is \"common.sol\" */\n    userTypesFilename?: string;\n    /** Path to the directory where generated files will be placed. (Default is \"codegen\") */\n    codegenDirectory?: string;\n    /** Filename where codegen index will be generated. Default is \"index.sol\" */\n    codegenIndexFilename?: string;\n  };\n\nconst StoreConfigUnrefined = z\n  .object({\n    namespace: zNamespace.default(DEFAULTS.namespace),\n    storeImportPath: z.string().default(PATH_DEFAULTS.storeImportPath),\n    tables: zTablesConfig,\n    userTypesFilename: z.string().default(PATH_DEFAULTS.userTypesFilename),\n    codegenDirectory: z.string().default(PATH_DEFAULTS.codegenDirectory),\n    codegenIndexFilename: z.string().default(PATH_DEFAULTS.codegenIndexFilename),\n  })\n  .merge(zEnumsConfig)\n  .merge(zUserTypesConfig);\n\n// finally validate global conditions\nexport const zStoreConfig = StoreConfigUnrefined.superRefine(validateStoreConfig);\n\nexport type StoreUserConfig = z.input<typeof zStoreConfig>;\nexport type StoreConfig = z.output<typeof zStoreConfig>;\n\n// Catchall preserves other plugins' options\nexport const zPluginStoreConfig = StoreConfigUnrefined.catchall(z.any()).superRefine(validateStoreConfig);\n\n/************************************************************************\n *\n *    HELPERS\n *\n ************************************************************************/\n\n// Validate conditions that check multiple different config options simultaneously\nfunction validateStoreConfig(config: z.output<typeof StoreConfigUnrefined>, ctx: RefinementCtx) {\n  // Local table variables must be unique within the table\n  for (const table of Object.values(config.tables)) {\n    const keySchemaNames = Object.keys(table.keySchema);\n    const fieldNames = Object.keys(table.valueSchema);\n    const duplicateVariableNames = getDuplicates([...keySchemaNames, ...fieldNames]);\n    if (duplicateVariableNames.length > 0) {\n      ctx.addIssue({\n        code: ZodIssueCode.custom,\n        message: `Field and key names within one table must be unique: ${duplicateVariableNames.join(\", \")}`,\n      });\n    }\n  }\n  // Global names must be unique\n  const tableLibraryNames = Object.keys(config.tables);\n  const staticUserTypeNames = [...Object.keys(config.enums), ...Object.keys(config.userTypes)];\n  const userTypeNames = staticUserTypeNames;\n  const globalNames = [...tableLibraryNames, ...userTypeNames];\n  const duplicateGlobalNames = getDuplicates(globalNames);\n  if (duplicateGlobalNames.length > 0) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Table library names, enum names, user type names must be globally unique: ${duplicateGlobalNames.join(\n        \", \"\n      )}`,\n    });\n  }\n  // Table names used for tableId must be unique\n  const tableNames = Object.values(config.tables).map(({ name }) => name);\n  const duplicateTableNames = getDuplicates(tableNames);\n  if (duplicateTableNames.length > 0) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Table names must be unique: ${duplicateTableNames.join(\", \")}`,\n    });\n  }\n  // User types must exist\n  for (const table of Object.values(config.tables)) {\n    for (const keySchemaType of Object.values(table.keySchema)) {\n      validateStaticAbiOrUserType(staticUserTypeNames, keySchemaType, ctx);\n    }\n    for (const fieldType of Object.values(table.valueSchema)) {\n      validateAbiOrUserType(userTypeNames, staticUserTypeNames, fieldType, ctx);\n    }\n  }\n}\n\nfunction validateAbiOrUserType(\n  userTypeNames: string[],\n  staticUserTypeNames: string[],\n  type: string,\n  ctx: RefinementCtx\n) {\n  if (!(AbiTypes as string[]).includes(type) && !userTypeNames.includes(type)) {\n    const staticArray = parseStaticArray(type);\n    if (staticArray) {\n      validateStaticArray(staticUserTypeNames, staticArray.elementType, staticArray.staticLength, ctx);\n    } else {\n      ctx.addIssue({\n        code: ZodIssueCode.custom,\n        message: `${type} is not a valid abi type, and is not defined in userTypes`,\n      });\n    }\n  }\n}\n\nfunction validateStaticAbiOrUserType(staticUserTypeNames: string[], type: string, ctx: RefinementCtx) {\n  if (!(StaticAbiTypes as string[]).includes(type) && !staticUserTypeNames.includes(type)) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `${type} is not a static type`,\n    });\n  }\n}\n\nfunction validateStaticArray(\n  staticUserTypeNames: string[],\n  elementType: string,\n  staticLength: number,\n  ctx: RefinementCtx\n) {\n  validateStaticAbiOrUserType(staticUserTypeNames, elementType, ctx);\n\n  if (staticLength === 0) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Static array length must not be 0`,\n    });\n  } else if (staticLength >= 2 ** 16) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Static array length must be less than 2**16`,\n    });\n  }\n}\n"],"mappings":"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","names":["PATH_DEFAULTS","DEFAULTS","TABLE_DEFAULTS","AbiTypes","StaticAbiTypes","z","ZodIssueCode","getDuplicates","parseStaticArray","STORE_NAME_MAX_LENGTH","zObjectName","zUserEnum","zValueName","zNamespace","zName","zTableName","zObjectName","zKeyName","zValueName","zColumnName","zUserEnumName","zUserTypeName","zFieldData","z","zKeyElementSchema","zKeySchema","TABLE_DEFAULTS","zFullSchemaConfig","arg","zShorthandSchemaConfig","fieldData","zSchemaConfig","resolveUserTypes","schema","userTypes","resolvedSchema","key","value","zFullTableConfig","zName","zShorthandTableConfig","zTableConfig","zTablesConfig","tables","tableName","table","STORE_NAME_MAX_LENGTH","zEnumsConfig","zUserEnum","DEFAULTS","zUserTypeConfig","zUserTypesConfig","StoreConfigUnrefined","zNamespace","PATH_DEFAULTS","zStoreConfig","validateStoreConfig","zPluginStoreConfig","config","ctx","keySchemaNames","fieldNames","duplicateVariableNames","getDuplicates","ZodIssueCode","tableLibraryNames","staticUserTypeNames","userTypeNames","globalNames","duplicateGlobalNames","tableNames","name","duplicateTableNames","keySchemaType","validateStaticAbiOrUserType","fieldType","validateAbiOrUserType","type","AbiTypes","staticArray","parseStaticArray","validateStaticArray","StaticAbiTypes","elementType","staticLength"]}