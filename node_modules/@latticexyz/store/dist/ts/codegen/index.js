import{renderArguments as T,renderCommonData as oe,renderWithFieldSuffix as S,renderWithStore as D}from"@latticexyz/common/codegen";function W(e){let n=e.storeArgument,{_typedTableId:r,_typedKeyArgs:t,_keyTupleDefinition:a}=oe(e),o="";for(let[c,d]of e.fields.entries()){if(!e.withDynamicFieldMethods&&d.isDynamic)continue;let l=`${d.typeWithLocation} ${d.name}`;if(e.withGetters&&(o+=S(e.withSuffixlessFieldMethods,d.name,i=>D(n,(s,m,p,$,f)=>`
            /** Get ${d.name}${p} */
            function ${f}get${i}(${T([s,r,t])}) internal view returns (${l}) {
              ${a}
              ${d.isDynamic?`bytes memory _blob = ${m}.getDynamicField(
                      _tableId,
                      _keyTuple,
                      ${c-e.staticFields.length}
                    );`:`bytes32 _blob = ${m}.getStaticField(
                      _tableId,
                      _keyTuple,
                      ${c},
                      _fieldLayout
                    );`}
              return ${O(d)};
            }
        `))),o+=S(e.withSuffixlessFieldMethods,d.name,i=>D(n,(s,m,p,$,f)=>{let u=T([s,r,t,l]),y=d.isDynamic?"setDynamicField":"setStaticField",g=A(d),_=d.isDynamic?`_tableId, _keyTuple, ${c-e.staticFields.length}, ${g}`:`_tableId, _keyTuple, ${c}, ${g}, _fieldLayout`;return`
          /** Set ${d.name}${p} */
          function ${f}set${i}(${u}) internal {
            ${a}
            ${m}.${y}(${_});
          }
        `})),d.isDynamic){let i=ie(d),s=c-e.staticFields.length;e.withGetters&&(o+=S(e.withSuffixlessFieldMethods,d.name,m=>D(n,(p,$,f,u,y)=>`
              /** Get the length of ${d.name}${f} */
              function ${y}length${m}(${T([p,r,t])}) internal view returns (uint256) {
                ${a}
                uint256 _byteLength = ${$}.getDynamicFieldLength(_tableId, _keyTuple, ${s});
                unchecked {
                  return _byteLength / ${i.elementLength};
                }
              }
          `)),o+=S(e.withSuffixlessFieldMethods,d.name,m=>D(n,(p,$,f,u,y)=>`
              /**
               * Get an item of ${d.name}${f}
               * (unchecked, returns invalid data if index overflows)
              */
              function ${y}getItem${m}(${T([p,r,t,"uint256 _index"])}) internal view returns (${i.typeWithLocation}) {
              ${a}
              unchecked {
                bytes memory _blob = ${$}.getDynamicFieldSlice(
                  _tableId,
                  _keyTuple,
                  ${s},
                  _index * ${i.elementLength},
                  (_index + 1) * ${i.elementLength}
                  );
                  return ${i.decoded};
                }
              }
            `))),o+=S(e.withSuffixlessFieldMethods,d.name,m=>D(n,(p,$,f,u,y)=>`
              /** Push ${i.title} to ${d.name}${f} */
              function ${y}push${m}(${T([p,r,t,`${i.typeWithLocation} ${i.name}`])}) internal {
              ${a}
              ${$}.pushToDynamicField(_tableId, _keyTuple, ${s}, ${i.encoded});
            }
            `)),o+=S(e.withSuffixlessFieldMethods,d.name,m=>D(n,(p,$,f,u,y)=>`
            /** Pop ${i.title} from ${d.name}${f} */
            function ${y}pop${m}(${T([p,r,t])}) internal {
              ${a}
              ${$}.popFromDynamicField(_tableId, _keyTuple, ${s}, ${i.elementLength});
            }
          `)),o+=S(e.withSuffixlessFieldMethods,d.name,m=>D(n,(p,$,f,u,y)=>{let g=T([p,r,t,"uint256 _index",`${i.typeWithLocation} ${i.name}`]),_=`
            _tableId,
            _keyTuple,
            ${s},
            uint40(_index * ${i.elementLength}),
            uint40(_encoded.length),
            _encoded 
          `;return`
            /**
             * Update ${i.title} of ${d.name}${f} at \`_index\`
             * (checked only to prevent modifying other tables; can corrupt own data if index overflows)
             */
            function ${y}update${m}(${g}) internal {
              ${a}
              unchecked {
                bytes memory _encoded = ${i.encoded};
                ${$}.spliceDynamicData(${_});
              }
            }
          `}))}}return o}function A(e){let n;return e.arrayElement?n="EncodeArray.encode":e.isDynamic?n="bytes":n="abi.encodePacked",`${n}(${e.typeUnwrap}(${e.name}))`}function U(e,n){let{staticByteLength:r}=e,t=`Bytes.slice${r}(_blob, ${n})`;return G(e,t)}function G(e,n){let{staticByteLength:r,internalTypeId:t}=e,a=r*8,o;if(t.match(/^uint\d{1,3}$/)||t==="address")o=`${t}(${n})`;else if(t.match(/^int\d{1,3}$/))o=`${t}(uint${a}(${n}))`;else if(t.match(/^bytes\d{1,2}$/))o=n;else if(t==="bool")o=`_toBool(uint8(${n}))`;else throw new Error(`Unknown value type id ${t}`);return`${e.typeWrap}(${o})`}function ie(e){let n="";if(e.arrayElement){let r="_element",t={...e.arrayElement,arrayElement:void 0,name:r,methodNameSuffix:n};return{typeWithLocation:e.arrayElement.typeWithLocation,name:"_element",encoded:A(t),decoded:O(t),title:"an element",elementLength:e.arrayElement.staticByteLength}}else{let r="_slice",t={...e,name:r,methodNameSuffix:n};return{typeWithLocation:`${e.typeId} memory`,name:r,encoded:A(t),decoded:O(t),title:"a slice",elementLength:1}}}function O(e){let{isDynamic:n,arrayElement:r}=e;return r?`${e.typeWrap}(
      SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_${r.internalTypeId}()
    )`:n?`${e.typeWrap}(${e.internalTypeId}(_blob))`:G(e,`bytes${e.staticByteLength}(_blob)`)}import{renderArguments as h,renderCommonData as H,renderList as j,renderWithStore as k}from"@latticexyz/common/codegen";function Y(e){let{structName:n,storeArgument:r}=e,{_typedTableId:t,_typedKeyArgs:a,_keyTupleDefinition:o}=H(e),c="";return e.withGetters&&(c+=k(r,(d,l,i,s,m)=>`
        /** Get the full data${i} */
        function ${m}get(${h([d,t,a])}) internal view returns (${de(e)}) {
          ${o}
          
          (
            bytes memory _staticData,
            PackedCounter _encodedLengths,
            bytes memory _dynamicData
            ) = ${l}.getRecord(_tableId, _keyTuple, _fieldLayout);
            return decode(_staticData, _encodedLengths, _dynamicData);
          }
        `)),c+=k(r,(d,l,i,s,m,p)=>{let $=h([d,t,a,h(e.fields.map(({name:u,typeWithLocation:y})=>`${y} ${u}`))]),f="_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData"+(p?", _fieldLayout":"");return`
        /** Set the full data using individual values${i} */
        function ${m}set(${$}) internal {
          ${E(e)}

          ${o}

          ${l}.setRecord(${f});
        }
    `}),n!==void 0&&(c+=k(r,(d,l,i,s,m,p)=>{let $=h([d,t,a,`${n} memory _table`]),f="_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData"+(p?", _fieldLayout":"");return`
          /** Set the full data using the data struct${i} */
          function ${m}set(${$}) internal {
            ${E(e,"_table.")}

            ${o}

            ${l}.setRecord(${f});
          }
      `})),c+=ae(e),c}function E(e,n=""){let r="";return e.staticFields.length>0?r+=`
      bytes memory _staticData = encodeStatic(
        ${h(e.staticFields.map(({name:t})=>`${n}${t}`))}
      );
    `:r+="bytes memory _staticData;",e.dynamicFields.length>0?r+=`
      PackedCounter _encodedLengths = encodeLengths(
        ${h(e.dynamicFields.map(({name:t})=>`${n}${t}`))}
      );
      bytes memory _dynamicData = encodeDynamic(
        ${h(e.dynamicFields.map(({name:t})=>`${n}${t}`))}
      );
    `:r+=`
      PackedCounter _encodedLengths;
      bytes memory _dynamicData;
    `,r}function X(e){let{storeArgument:n}=e,{_typedTableId:r,_typedKeyArgs:t,_keyTupleDefinition:a}=H(e);return k(n,(o,c,d,l,i,s)=>{let m=h([o,r,t]),p="_tableId, _keyTuple"+(s?", _fieldLayout":"");return`
      /** Delete all data for given keys${d} */
      function ${i}deleteRecord(${m}) internal {
        ${a}
        ${c}.deleteRecord(${p});
      }
    `})}function ae({structName:e,fields:n,staticFields:r,dynamicFields:t}){let a=e?`${e} memory _table`:h(n.map(({name:i,typeWithLocation:s})=>`${s} ${i}`)),o=e?"_table.":"",c=r.map(()=>0),d=0;for(let[i,s]of r.entries())c[i]=d,d+=s.staticByteLength;let l="";return r.length>0&&(l+=`
      /**
       * Decode the tightly packed blob of static data using this table's field layout
       * Undefined behaviour for invalid blobs
       */
      function decodeStatic(bytes memory _blob) internal pure returns (${h(r.map(({name:i,typeWithLocation:s})=>`${s} ${i}`))}) {
        ${j(r,(i,s)=>`
          ${i.name} = ${U(i,c[s])};
          `)}
      }
    `),t.length>0&&(l+=`
      /**
       * Decode the tightly packed blob of static data using this table's field layout
       * Undefined behaviour for invalid blobs
       */
      function decodeDynamic(PackedCounter _encodedLengths, bytes memory _blob) internal pure returns (${h(t.map(({name:i,typeWithLocation:s})=>`${s} ${i}`))}) {
        ${j(t,(i,s)=>s===0?`
                uint256 _start;
                uint256 _end;
                unchecked {
                  _end = _encodedLengths.atIndex(${s});
                }
                ${i.name} = ${K(i)};
              `:`
                _start = _end;
                unchecked {
                  _end += _encodedLengths.atIndex(${s});
                }
                ${i.name} = ${K(i)};
              `)}
      }
    `),l+=`
    /**
     * Decode the tightly packed blob using this table's field layout.
     * Undefined behaviour for invalid blobs.
     */
    function decode(
      bytes memory ${r.length>0?"_staticData":""},
      PackedCounter ${t.length>0?"_encodedLengths":""},
      bytes memory ${t.length>0?"_dynamicData":""}
    ) internal pure returns (${a}) {
  `,r.length>0&&(l+=`
      (${h(r.map(i=>`${o}${i.name}`))}) = decodeStatic(_staticData);
    `),t.length>0&&(l+=`
      (${h(t.map(i=>`${o}${i.name}`))}) = decodeDynamic(_encodedLengths, _dynamicData);
    `),l+=`
    }
  `,l}function de({structName:e,fields:n}){return e?`${e} memory _table`:h(n.map(({name:r,typeWithLocation:t})=>`${t} ${r}`))}function K(e){let{typeId:n,arrayElement:r,typeWrap:t}=e;return r?`${t}(
      SliceLib.getSubslice(_blob, _start, _end).decodeArray_${r.typeId}()
    )`:`${t}(
      ${n}(
        SliceLib.getSubslice(_blob, _start, _end).toBytes()
      )
    )`}import{renderArguments as b,renderCommonData as ye,renderList as x,renderImports as pe,renderTableId as fe,renderTypeHelpers as $e,renderWithStore as he,renderedSolidityHeader as ge}from"@latticexyz/common/codegen";var w={TOTAL_LENGTH:240,NUM_STATIC_FIELDS:232,NUM_DYNAMIC_FIELDS:224};function q(e){return`FieldLayout constant _fieldLayout = FieldLayout.wrap(${ue(e)});`}function ue(e){let n=e.filter(({isDynamic:c})=>!c),r=e.length-n.length,t=0n,a=0,o=e.length;if(o>28)throw new Error(`FieldLayout: invalid length ${o}`);if(r>5)throw new Error(`FieldLayout: invalid length ${r}`);for(let c=0;c<n.length;c++){let{isDynamic:d,staticByteLength:l}=e[c];if(d)throw new Error("FieldLayout: static type after dynamic type");a+=l,t|=BigInt(l)<<BigInt((31-4-c)*8)}return t|=BigInt(a)<<BigInt(w.TOTAL_LENGTH),t|=BigInt(n.length)<<BigInt(w.NUM_STATIC_FIELDS),t|=BigInt(r)<<BigInt(w.NUM_DYNAMIC_FIELDS),`0x${t.toString(16).padStart(64,"0")}`}function V(e){let{imports:n,libraryName:r,structName:t,staticResourceData:a,storeImportPath:o,fields:c,staticFields:d,dynamicFields:l,withRecordMethods:i,storeArgument:s,keyTuple:m}=e,{_typedTableId:p,_typedKeyArgs:$,_keyTupleDefinition:f}=ye(e);return`
    ${ge}

    // Import schema type
    import { SchemaType } from "@latticexyz/schema-type/src/solidity/SchemaType.sol";

    // Import store internals
    import { IStore } from "${o}IStore.sol";
    import { StoreSwitch } from "${o}StoreSwitch.sol";
    import { StoreCore } from "${o}StoreCore.sol";
    import { Bytes } from "${o}Bytes.sol";
    import { Memory } from "${o}Memory.sol";
    import { SliceLib } from "${o}Slice.sol";
    import { EncodeArray } from "${o}tightcoder/EncodeArray.sol";
    import { FieldLayout, FieldLayoutLib } from "${o}FieldLayout.sol";
    import { Schema, SchemaLib } from "${o}Schema.sol";
    import { PackedCounter, PackedCounterLib } from "${o}PackedCounter.sol";
    import { ResourceId } from "${o}ResourceId.sol";
    import { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from "${o}storeResourceTypes.sol";

    ${n.length>0?`
          // Import user types
          ${pe(n)}
          `:""}

    ${a?fe(a).tableIdDefinition:""}

    ${q(c)}

    ${t?`
          struct ${t} {
            ${x(c,({name:u,typeId:y})=>`${y} ${u};`)}
          }
          `:""}

    library ${r} {
      /** Get the table values' field layout */
      function getFieldLayout() internal pure returns (FieldLayout) {
        return _fieldLayout;
      }

      /** Get the table's key schema */
      function getKeySchema() internal pure returns (Schema) {
        SchemaType[] memory _keySchema = new SchemaType[](${m.length});
        ${x(m,({enumName:u},y)=>`_keySchema[${y}] = SchemaType.${u};`)}

        return SchemaLib.encode(_keySchema);
      }

      /** Get the table's value schema */
      function getValueSchema() internal pure returns (Schema) {
        SchemaType[] memory _valueSchema = new SchemaType[](${c.length});
        ${x(c,({enumName:u},y)=>`_valueSchema[${y}] = SchemaType.${u};`)}

        return SchemaLib.encode(_valueSchema);
      }

      /** Get the table's key names */
      function getKeyNames() internal pure returns (string[] memory keyNames) {
        keyNames = new string[](${m.length});
        ${x(m,(u,y)=>`keyNames[${y}] = "${u.name}";`)}
      }

      /** Get the table's field names */
      function getFieldNames() internal pure returns (string[] memory fieldNames) {
        fieldNames = new string[](${c.length});
        ${x(c,(u,y)=>`fieldNames[${y}] = "${u.name}";`)}
      }

      ${he(s,(u,y,g,_,I)=>`
          /** Register the table with its config${g} */
          function ${I}register(${b([u,p])}) internal {
            ${y}.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());
          }
        `)}

      ${W(e)}

      ${i?Y(e):""}

      ${X(e)}

      ${_e(d)}

      ${be(l)}

      ${Te(l)}

      /** Tightly pack full data using this table's field layout */
      function encode(${b(e.fields.map(({name:u,typeWithLocation:y})=>`${y} ${u}`))}) internal pure returns (bytes memory, PackedCounter, bytes memory) {
        ${E(e)}

        return (_staticData, _encodedLengths, _dynamicData);
      }
      
      /** Encode keys as a bytes32 array using this table's field layout */
      function encodeKeyTuple(${b([$])}) internal pure returns (bytes32[] memory) {
        ${f}
        return _keyTuple;
      }
    }

    ${$e(e)}
  `}function _e(e){return e.length===0?"":`
    /** Tightly pack static data using this table's schema */
    function encodeStatic(${b(e.map(({name:n,typeWithLocation:r})=>`${r} ${n}`))}) internal pure returns (bytes memory) {
      return abi.encodePacked(${b(e.map(({name:n})=>n))});
    }
  `}function be(e){return e.length===0?"":`
    /** Tightly pack dynamic data using this table's schema */
    function encodeLengths(${b(e.map(({name:n,typeWithLocation:r})=>`${r} ${n}`))}) internal pure returns (PackedCounter _encodedLengths) {
      // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits
      unchecked {
        _encodedLengths = PackedCounterLib.pack(
          ${b(e.map(({name:n,arrayElement:r})=>r?`${n}.length * ${r.staticByteLength}`:`bytes(${n}).length`))}
        );
      }
    }
  `}function Te(e){return e.length===0?"":`
    /** Tightly pack dynamic data using this table's schema */
    function encodeDynamic(${b(e.map(({name:n,typeWithLocation:r})=>`${r} ${n}`))}) internal pure returns (bytes memory) {
      return abi.encodePacked(${b(e.map(n=>A(n)))});
    }
  `}import{renderEnums as Se}from"@latticexyz/common/codegen";function Z(e){let n=Object.keys(e.enums).map(r=>({name:r,memberNames:e.enums[r]}));return Se(n)}import R from"path";import{formatAndWriteSolidity as M,loadAndExtractUserTypes as ke}from"@latticexyz/common/codegen";import Ie from"path";import{SchemaTypeArrayToElement as Ae}from"@latticexyz/schema-type/deprecated";import{AbiTypeToSchemaType as L,getStaticByteLength as C,SchemaType as F,SchemaTypeToAbiType as z}from"@latticexyz/schema-type/deprecated";import{parseStaticArray as J}from"@latticexyz/config";function v(e,n,r){if(e in L){let a=L[e];return{schemaType:a,renderType:P(a)}}let t=J(e);if(t){if(t.elementType in L)return Le(e,t.elementType,t.staticLength);throw new Error("Static arrays of user types are not supported")}return De(e,n,r)}function B(e,n,r,t){if(!(e in L||J(e))){if(e in t){let o=t[e],c=o.importSymbol;return o.isRelativePath?{symbol:c,fromPath:o.fromPath,usedInPath:n}:{symbol:c,path:o.fromPath}}return{symbol:e,fromPath:r.userTypesFilename,usedInPath:n}}}function P(e){let n=C(e),r=n===0,t=z[e];return{typeId:t,typeWithLocation:r?t+" memory":t,enumName:F[e],staticByteLength:n,isDynamic:r,typeWrap:"",typeUnwrap:"",internalTypeId:t}}function De(e,n,r){if(e in n.enums){let t=F.UINT8,a=C(t),o=a===0,c=e;return{schemaType:t,renderType:{typeId:c,typeWithLocation:c,enumName:F[t],staticByteLength:a,isDynamic:o,typeWrap:`${e}`,typeUnwrap:"uint8",internalTypeId:`${z[t]}`}}}if(e in r){if(!(e in r))throw new Error(`User type "${e}" not found in MUD config`);let t=r[e],a=t.typeId,o=L[t.internalTypeId];return{schemaType:o,renderType:{typeId:a,typeWithLocation:a,enumName:F[o],staticByteLength:C(o),isDynamic:!1,typeWrap:`${a}.wrap`,typeUnwrap:`${a}.unwrap`,internalTypeId:`${t.internalTypeId}`}}}throw new Error(`User type "${e}" does not exist`)}function Le(e,n,r){let t=n+"[]",a=L[t];return{schemaType:a,renderType:{typeId:e,typeWithLocation:`${e} memory`,enumName:F[a],staticByteLength:0,isDynamic:!0,typeWrap:`toStaticArray_${n}_${r}`,typeUnwrap:`fromStaticArray_${n}_${r}`,typeWrappingData:{kind:"staticArray",elementType:n,staticLength:r},internalTypeId:t}}}function Q(e,n){let r=e.storeImportPath,t=[];for(let a of Object.keys(e.tables)){let o=e.tables[a],c=o.dataStruct,d=c||o.offchainOnly||Object.keys(o.valueSchema).length>1,l=!d&&Object.keys(o.valueSchema).length===1,i=[],s=Object.keys(o.keySchema).map(u=>{let y=o.keySchema[u],{renderType:g}=v(y,e,n),_=B(y,o.directory,e,n);if(_&&i.push(_),g.isDynamic)throw new Error(`Parsing error: found dynamic key ${u} in table ${a}`);return{...g,name:u,isDynamic:!1}}),m=Object.keys(o.valueSchema).map(u=>{let y=o.valueSchema[u],{renderType:g,schemaType:_}=v(y,e,n),I=B(y,o.directory,e,n);I&&i.push(I);let N=Ae[_];return{...g,arrayElement:N!==void 0?P(N):void 0,name:u}}),p=m.filter(({isDynamic:u})=>!u),$=m.filter(({isDynamic:u})=>u),f=(()=>{if(!o.tableIdArgument)return{tableIdName:a+"TableId",namespace:e.namespace,name:o.name,offchainOnly:o.offchainOnly}})();t.push({outputPath:Ie.join(o.directory,`${a}.sol`),tableName:a,renderOptions:{imports:i,libraryName:a,structName:c?a+"Data":void 0,staticResourceData:f,storeImportPath:r,keyTuple:s,fields:m,staticFields:p,dynamicFields:$,withGetters:!o.offchainOnly,withRecordMethods:d,withDynamicFieldMethods:!o.offchainOnly,withSuffixlessFieldMethods:l,storeArgument:o.storeArgument}})}return t}import{posixPath as xe,renderList as Fe,renderedSolidityHeader as Re}from"@latticexyz/common/codegen";function ee(e){return`
    ${Re}

    ${Fe(e,({outputPath:n,tableName:r,renderOptions:{structName:t,staticResourceData:a}})=>{let o=[r];return t&&o.push(t),a&&o.push(`${r}TableId`),`import { ${o.join(", ")} } from "./${xe(n)}";`})}
  `}import{rmSync as Ee}from"fs";async function Lt(e,n,r){let t=ke(e.userTypes,n,r),a=Q(e,t),o=new Set(a.map(({outputPath:l})=>R.dirname(l)));for(let l of o)Ee(R.join(n,l),{recursive:!0,force:!0});for(let{outputPath:l,renderOptions:i}of a){let s=R.join(n,l),m=V(i);await M(m,s,"Generated table")}if(Object.keys(e.enums).length>0){let l=R.join(n,e.userTypesFilename),i=Z(e);await M(i,l,"Generated types file")}let c=R.join(n,e.codegenIndexFilename),d=ee(a);await M(d,c,"Generated table index")}import{renderedSolidityHeader as we}from"@latticexyz/common/codegen";import{staticAbiTypeToByteLength as Oe,staticAbiTypes as Ce}from"@latticexyz/schema-type";import{getLeftPaddingBits as te}from"@latticexyz/common/codegen";function ne(e){return`
    function decodeArray_${e.internalTypeId}(
      Slice _input
    ) internal pure returns (
      ${e.internalTypeId}[] memory _output
    ) {
      bytes32[] memory _genericArray = TightCoder.decode(
        _input,
        ${e.staticByteLength},
        ${te(e)}
      );
      assembly {
        _output := _genericArray
      }
    }
  `}function re(e){return`
    function encode(${e.internalTypeId}[] memory _input) internal pure returns (bytes memory) {
      bytes32[] memory _genericArray;
      assembly {
        _genericArray := _input
      }
      return TightCoder.encode(
        _genericArray,
        ${e.staticByteLength},
        ${te(e)}
      );
    }
  `}function Et(){return`
    ${we}
    import { TightCoder } from "./TightCoder.sol";
    import { Slice } from "../Slice.sol";
    library DecodeSlice {
      ${Ce.map(e=>ne({internalTypeId:e,staticByteLength:Oe[e]})).join(`
`)}
    }
  `}import{renderedSolidityHeader as ve}from"@latticexyz/common/codegen";import{staticAbiTypeToByteLength as Be,staticAbiTypes as Pe}from"@latticexyz/schema-type";function Bt(){return`
    ${ve}
    import { TightCoder } from "./TightCoder.sol";
    library EncodeArray {
      ${Pe.map(e=>re({internalTypeId:e,staticByteLength:Be[e]})).join(`
`)}
      }
  `}import{renderedSolidityHeader as Me}from"@latticexyz/common/codegen";import{staticAbiTypes as Ne}from"@latticexyz/schema-type";function We({typeId:e}){return`
    function testEncodeDecodeArray_${e}(
      ${e} val0,
      ${e} val1,
      ${e} val2
    ) public {
      ${e}[] memory input = new ${e}[](3);
      input[0] = val0;
      input[1] = val1;
      input[2] = val2;

      bytes memory encoded = EncodeArray.encode(input);
      assertEq(encoded, abi.encodePacked(val0, val1, val2));

      ${e}[] memory decoded = SliceLib.fromBytes(encoded).decodeArray_${e}();
      assertEq(decoded.length, 3);
      assertEq(decoded[0], val0);
      assertEq(decoded[1], val1);
      assertEq(decoded[2], val2);
    }
  `}function Wt(){return`
    ${Me}

    import { Test } from "forge-std/Test.sol";
    import { EncodeArray } from "../../src/tightcoder/EncodeArray.sol";
    import { SliceLib } from "../../src/Slice.sol";

    contract TightCoderAutoTest is Test {
      ${Ne.map(e=>We({typeId:e})).join("")}
    }
  `}export{P as getSchemaTypeInfo,Q as getTableOptions,De as getUserTypeInfo,B as importForAbiOrUserType,Et as renderDecodeSlice,U as renderDecodeValueType,X as renderDeleteRecordMethods,Bt as renderEncodeArray,A as renderEncodeFieldSingle,W as renderFieldMethods,E as renderRecordData,Y as renderRecordMethods,V as renderTable,Wt as renderTightCoderAutoTest,We as renderTightCoderAutoTestFunction,ne as renderTightCoderDecode,re as renderTightCoderEncode,Z as renderTypesFromConfig,v as resolveAbiOrUserType,Lt as tablegen};
//# sourceMappingURL=index.js.map