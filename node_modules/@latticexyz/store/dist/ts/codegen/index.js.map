{"version":3,"sources":["../../../ts/codegen/field.ts","../../../ts/codegen/record.ts","../../../ts/codegen/renderTable.ts","../../../ts/constants.ts","../../../ts/codegen/renderFieldLayout.ts","../../../ts/codegen/renderTypesFromConfig.ts","../../../ts/codegen/tablegen.ts","../../../ts/codegen/tableOptions.ts","../../../ts/codegen/userType.ts","../../../ts/codegen/renderTableIndex.ts","../../../ts/codegen/tightcoder/renderDecodeSlice.ts","../../../ts/codegen/tightcoder/renderFunctions.ts","../../../ts/codegen/tightcoder/renderEncodeArray.ts","../../../ts/codegen/tightcoder/renderTightCoderAutoTest.ts"],"sourcesContent":["import {\n  renderArguments,\n  renderCommonData,\n  RenderField,\n  RenderType,\n  renderWithFieldSuffix,\n  renderWithStore,\n} from \"@latticexyz/common/codegen\";\nimport { RenderTableOptions } from \"./types\";\n\nexport function renderFieldMethods(options: RenderTableOptions) {\n  const storeArgument = options.storeArgument;\n  const { _typedTableId, _typedKeyArgs, _keyTupleDefinition } = renderCommonData(options);\n\n  let result = \"\";\n  for (const [schemaIndex, field] of options.fields.entries()) {\n    if (!options.withDynamicFieldMethods && field.isDynamic) {\n      continue;\n    }\n\n    // For dynamic fields, compute the field index relative to the end of the static fields\n    const _typedFieldName = `${field.typeWithLocation} ${field.name}`;\n\n    if (options.withGetters) {\n      result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n        renderWithStore(\n          storeArgument,\n          (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n            /** Get ${field.name}${_commentSuffix} */\n            function ${_methodNamePrefix}get${_methodNameSuffix}(${renderArguments([\n            _typedStore,\n            _typedTableId,\n            _typedKeyArgs,\n          ])}) internal view returns (${_typedFieldName}) {\n              ${_keyTupleDefinition}\n              ${\n                field.isDynamic\n                  ? `bytes memory _blob = ${_store}.getDynamicField(\n                      _tableId,\n                      _keyTuple,\n                      ${schemaIndex - options.staticFields.length}\n                    );`\n                  : `bytes32 _blob = ${_store}.getStaticField(\n                      _tableId,\n                      _keyTuple,\n                      ${schemaIndex},\n                      _fieldLayout\n                    );`\n              }\n              return ${renderDecodeFieldSingle(field)};\n            }\n        `\n        )\n      );\n    }\n\n    result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n      renderWithStore(storeArgument, (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => {\n        const externalArguments = renderArguments([_typedStore, _typedTableId, _typedKeyArgs, _typedFieldName]);\n        const setFieldMethod = field.isDynamic ? \"setDynamicField\" : \"setStaticField\";\n        const encodeFieldSingle = renderEncodeFieldSingle(field);\n        const internalArguments = field.isDynamic\n          ? `_tableId, _keyTuple, ${schemaIndex - options.staticFields.length}, ${encodeFieldSingle}`\n          : `_tableId, _keyTuple, ${schemaIndex}, ${encodeFieldSingle}, _fieldLayout`;\n\n        return `\n          /** Set ${field.name}${_commentSuffix} */\n          function ${_methodNamePrefix}set${_methodNameSuffix}(${externalArguments}) internal {\n            ${_keyTupleDefinition}\n            ${_store}.${setFieldMethod}(${internalArguments});\n          }\n        `;\n      })\n    );\n\n    if (field.isDynamic) {\n      const portionData = fieldPortionData(field);\n      const dynamicSchemaIndex = schemaIndex - options.staticFields.length;\n\n      if (options.withGetters) {\n        result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n          renderWithStore(\n            storeArgument,\n            (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n              /** Get the length of ${field.name}${_commentSuffix} */\n              function ${_methodNamePrefix}length${_methodNameSuffix}(${renderArguments([\n              _typedStore,\n              _typedTableId,\n              _typedKeyArgs,\n            ])}) internal view returns (uint256) {\n                ${_keyTupleDefinition}\n                uint256 _byteLength = ${_store}.getDynamicFieldLength(_tableId, _keyTuple, ${dynamicSchemaIndex});\n                unchecked {\n                  return _byteLength / ${portionData.elementLength};\n                }\n              }\n          `\n          )\n        );\n\n        result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n          renderWithStore(\n            storeArgument,\n            (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n              /**\n               * Get an item of ${field.name}${_commentSuffix}\n               * (unchecked, returns invalid data if index overflows)\n              */\n              function ${_methodNamePrefix}getItem${_methodNameSuffix}(${renderArguments([\n              _typedStore,\n              _typedTableId,\n              _typedKeyArgs,\n              \"uint256 _index\",\n            ])}) internal view returns (${portionData.typeWithLocation}) {\n              ${_keyTupleDefinition}\n              unchecked {\n                bytes memory _blob = ${_store}.getDynamicFieldSlice(\n                  _tableId,\n                  _keyTuple,\n                  ${dynamicSchemaIndex},\n                  _index * ${portionData.elementLength},\n                  (_index + 1) * ${portionData.elementLength}\n                  );\n                  return ${portionData.decoded};\n                }\n              }\n            `\n          )\n        );\n      }\n\n      result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n        renderWithStore(\n          storeArgument,\n          (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n              /** Push ${portionData.title} to ${field.name}${_commentSuffix} */\n              function ${_methodNamePrefix}push${_methodNameSuffix}(${renderArguments([\n            _typedStore,\n            _typedTableId,\n            _typedKeyArgs,\n            `${portionData.typeWithLocation} ${portionData.name}`,\n          ])}) internal {\n              ${_keyTupleDefinition}\n              ${_store}.pushToDynamicField(_tableId, _keyTuple, ${dynamicSchemaIndex}, ${portionData.encoded});\n            }\n            `\n        )\n      );\n\n      result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n        renderWithStore(\n          storeArgument,\n          (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n            /** Pop ${portionData.title} from ${field.name}${_commentSuffix} */\n            function ${_methodNamePrefix}pop${_methodNameSuffix}(${renderArguments([\n            _typedStore,\n            _typedTableId,\n            _typedKeyArgs,\n          ])}) internal {\n              ${_keyTupleDefinition}\n              ${_store}.popFromDynamicField(_tableId, _keyTuple, ${dynamicSchemaIndex}, ${portionData.elementLength});\n            }\n          `\n        )\n      );\n\n      result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n        renderWithStore(storeArgument, (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => {\n          const externalArguments = renderArguments([\n            _typedStore,\n            _typedTableId,\n            _typedKeyArgs,\n            \"uint256 _index\",\n            `${portionData.typeWithLocation} ${portionData.name}`,\n          ]);\n\n          const internalArguments = `\n            _tableId,\n            _keyTuple,\n            ${dynamicSchemaIndex},\n            uint40(_index * ${portionData.elementLength}),\n            uint40(_encoded.length),\n            _encoded \n          `;\n\n          return `\n            /**\n             * Update ${portionData.title} of ${field.name}${_commentSuffix} at \\`_index\\`\n             * (checked only to prevent modifying other tables; can corrupt own data if index overflows)\n             */\n            function ${_methodNamePrefix}update${_methodNameSuffix}(${externalArguments}) internal {\n              ${_keyTupleDefinition}\n              unchecked {\n                bytes memory _encoded = ${portionData.encoded};\n                ${_store}.spliceDynamicData(${internalArguments});\n              }\n            }\n          `;\n        })\n      );\n    }\n  }\n  return result;\n}\n\nexport function renderEncodeFieldSingle(field: RenderField) {\n  let func;\n  if (field.arrayElement) {\n    func = \"EncodeArray.encode\";\n  } else if (field.isDynamic) {\n    func = \"bytes\";\n  } else {\n    func = \"abi.encodePacked\";\n  }\n  return `${func}(${field.typeUnwrap}(${field.name}))`;\n}\n\nexport function renderDecodeValueType(field: RenderType, offset: number) {\n  const { staticByteLength } = field;\n\n  const innerSlice = `Bytes.slice${staticByteLength}(_blob, ${offset})`;\n\n  return renderCastStaticBytesToType(field, innerSlice);\n}\n\nfunction renderCastStaticBytesToType(field: RenderType, staticBytes: string) {\n  const { staticByteLength, internalTypeId } = field;\n  const bits = staticByteLength * 8;\n\n  let result;\n  if (internalTypeId.match(/^uint\\d{1,3}$/) || internalTypeId === \"address\") {\n    result = `${internalTypeId}(${staticBytes})`;\n  } else if (internalTypeId.match(/^int\\d{1,3}$/)) {\n    result = `${internalTypeId}(uint${bits}(${staticBytes}))`;\n  } else if (internalTypeId.match(/^bytes\\d{1,2}$/)) {\n    result = staticBytes;\n  } else if (internalTypeId === \"bool\") {\n    result = `_toBool(uint8(${staticBytes}))`;\n  } else {\n    throw new Error(`Unknown value type id ${internalTypeId}`);\n  }\n  return `${field.typeWrap}(${result})`;\n}\n\n/** bytes/string are dynamic, but aren't really arrays */\nfunction fieldPortionData(field: RenderField) {\n  const methodNameSuffix = \"\";\n  if (field.arrayElement) {\n    const name = \"_element\";\n    const elementFieldData = { ...field.arrayElement, arrayElement: undefined, name, methodNameSuffix };\n    return {\n      typeWithLocation: field.arrayElement.typeWithLocation,\n      name: \"_element\",\n      encoded: renderEncodeFieldSingle(elementFieldData),\n      decoded: renderDecodeFieldSingle(elementFieldData),\n      title: \"an element\",\n      elementLength: field.arrayElement.staticByteLength,\n    };\n  } else {\n    const name = \"_slice\";\n    const elementFieldData = { ...field, name, methodNameSuffix };\n    return {\n      typeWithLocation: `${field.typeId} memory`,\n      name,\n      encoded: renderEncodeFieldSingle(elementFieldData),\n      decoded: renderDecodeFieldSingle(elementFieldData),\n      title: \"a slice\",\n      elementLength: 1,\n    };\n  }\n}\n\nfunction renderDecodeFieldSingle(field: RenderField) {\n  const { isDynamic, arrayElement } = field;\n  if (arrayElement) {\n    // arrays\n    return `${field.typeWrap}(\n      SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_${arrayElement.internalTypeId}()\n    )`;\n  } else if (isDynamic) {\n    // bytes/string\n    return `${field.typeWrap}(${field.internalTypeId}(_blob))`;\n  } else {\n    return renderCastStaticBytesToType(field, `bytes${field.staticByteLength}(_blob)`);\n  }\n}\n","import {\n  RenderDynamicField,\n  renderArguments,\n  renderCommonData,\n  renderList,\n  renderWithStore,\n} from \"@latticexyz/common/codegen\";\nimport { renderDecodeValueType } from \"./field\";\nimport { RenderTableOptions } from \"./types\";\n\nexport function renderRecordMethods(options: RenderTableOptions) {\n  const { structName, storeArgument } = options;\n  const { _typedTableId, _typedKeyArgs, _keyTupleDefinition } = renderCommonData(options);\n\n  let result = \"\";\n\n  if (options.withGetters) {\n    result += renderWithStore(\n      storeArgument,\n      (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n        /** Get the full data${_commentSuffix} */\n        function ${_methodNamePrefix}get(${renderArguments([\n        _typedStore,\n        _typedTableId,\n        _typedKeyArgs,\n      ])}) internal view returns (${renderDecodedRecord(options)}) {\n          ${_keyTupleDefinition}\n          \n          (\n            bytes memory _staticData,\n            PackedCounter _encodedLengths,\n            bytes memory _dynamicData\n            ) = ${_store}.getRecord(_tableId, _keyTuple, _fieldLayout);\n            return decode(_staticData, _encodedLengths, _dynamicData);\n          }\n        `\n    );\n  }\n\n  result += renderWithStore(\n    storeArgument,\n    (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix, _internal) => {\n      const externalArguments = renderArguments([\n        _typedStore,\n        _typedTableId,\n        _typedKeyArgs,\n        renderArguments(options.fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)),\n      ]);\n\n      const internalArguments =\n        \"_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData\" + (_internal ? \", _fieldLayout\" : \"\");\n\n      return `\n        /** Set the full data using individual values${_commentSuffix} */\n        function ${_methodNamePrefix}set(${externalArguments}) internal {\n          ${renderRecordData(options)}\n\n          ${_keyTupleDefinition}\n\n          ${_store}.setRecord(${internalArguments});\n        }\n    `;\n    }\n  );\n\n  if (structName !== undefined) {\n    result += renderWithStore(\n      storeArgument,\n      (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix, _internal) => {\n        const externalArguments = renderArguments([\n          _typedStore,\n          _typedTableId,\n          _typedKeyArgs,\n          `${structName} memory _table`,\n        ]);\n\n        const internalArguments =\n          \"_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData\" + (_internal ? \", _fieldLayout\" : \"\");\n\n        return `\n          /** Set the full data using the data struct${_commentSuffix} */\n          function ${_methodNamePrefix}set(${externalArguments}) internal {\n            ${renderRecordData(options, \"_table.\")}\n\n            ${_keyTupleDefinition}\n\n            ${_store}.setRecord(${internalArguments});\n          }\n      `;\n      }\n    );\n  }\n\n  result += renderDecodeFunctions(options);\n\n  return result;\n}\n\nexport function renderRecordData(options: RenderTableOptions, namePrefix = \"\") {\n  let result = \"\";\n  if (options.staticFields.length > 0) {\n    result += `\n      bytes memory _staticData = encodeStatic(\n        ${renderArguments(options.staticFields.map(({ name }) => `${namePrefix}${name}`))}\n      );\n    `;\n  } else {\n    result += `bytes memory _staticData;`;\n  }\n\n  if (options.dynamicFields.length > 0) {\n    result += `\n      PackedCounter _encodedLengths = encodeLengths(\n        ${renderArguments(options.dynamicFields.map(({ name }) => `${namePrefix}${name}`))}\n      );\n      bytes memory _dynamicData = encodeDynamic(\n        ${renderArguments(options.dynamicFields.map(({ name }) => `${namePrefix}${name}`))}\n      );\n    `;\n  } else {\n    result += `\n      PackedCounter _encodedLengths;\n      bytes memory _dynamicData;\n    `;\n  }\n\n  return result;\n}\n\nexport function renderDeleteRecordMethods(options: RenderTableOptions) {\n  const { storeArgument } = options;\n  const { _typedTableId, _typedKeyArgs, _keyTupleDefinition } = renderCommonData(options);\n\n  return renderWithStore(\n    storeArgument,\n    (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix, _internal) => {\n      const externalArguments = renderArguments([_typedStore, _typedTableId, _typedKeyArgs]);\n      const internalArguments = \"_tableId, _keyTuple\" + (_internal ? \", _fieldLayout\" : \"\");\n\n      return `\n      /** Delete all data for given keys${_commentSuffix} */\n      function ${_methodNamePrefix}deleteRecord(${externalArguments}) internal {\n        ${_keyTupleDefinition}\n        ${_store}.deleteRecord(${internalArguments});\n      }\n    `;\n    }\n  );\n}\n\n// Renders the `decode` function that parses a bytes blob into the table data\nfunction renderDecodeFunctions({ structName, fields, staticFields, dynamicFields }: RenderTableOptions) {\n  // either set struct properties, or just variables\n  const renderedDecodedRecord = structName\n    ? `${structName} memory _table`\n    : renderArguments(fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));\n  const fieldNamePrefix = structName ? \"_table.\" : \"\";\n\n  // Static field offsets\n  const staticOffsets = staticFields.map(() => 0);\n  let _acc = 0;\n  for (const [index, field] of staticFields.entries()) {\n    staticOffsets[index] = _acc;\n    _acc += field.staticByteLength;\n  }\n\n  let result = \"\";\n\n  if (staticFields.length > 0) {\n    result += `\n      /**\n       * Decode the tightly packed blob of static data using this table's field layout\n       * Undefined behaviour for invalid blobs\n       */\n      function decodeStatic(bytes memory _blob) internal pure returns (${renderArguments(\n        staticFields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)\n      )}) {\n        ${renderList(\n          staticFields,\n          (field, index) => `\n          ${field.name} = ${renderDecodeValueType(field, staticOffsets[index])};\n          `\n        )}\n      }\n    `;\n  }\n\n  if (dynamicFields.length > 0) {\n    result += `\n      /**\n       * Decode the tightly packed blob of static data using this table's field layout\n       * Undefined behaviour for invalid blobs\n       */\n      function decodeDynamic(PackedCounter _encodedLengths, bytes memory _blob) internal pure returns (${renderArguments(\n        dynamicFields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)\n      )}) {\n        ${renderList(\n          dynamicFields,\n          // unchecked is only dangerous if _encodedLengths (and _blob) is invalid,\n          // but it's assumed to be valid, and this function is meant to be mostly used internally\n          (field, index) => {\n            if (index === 0) {\n              return `\n                uint256 _start;\n                uint256 _end;\n                unchecked {\n                  _end = _encodedLengths.atIndex(${index});\n                }\n                ${field.name} = ${renderDecodeDynamicFieldPartial(field)};\n              `;\n            } else {\n              return `\n                _start = _end;\n                unchecked {\n                  _end += _encodedLengths.atIndex(${index});\n                }\n                ${field.name} = ${renderDecodeDynamicFieldPartial(field)};\n              `;\n            }\n          }\n        )}\n      }\n    `;\n  }\n\n  result += `\n    /**\n     * Decode the tightly packed blob using this table's field layout.\n     * Undefined behaviour for invalid blobs.\n     */\n    function decode(\n      bytes memory ${staticFields.length > 0 ? \"_staticData\" : \"\"},\n      PackedCounter ${dynamicFields.length > 0 ? \"_encodedLengths\" : \"\"},\n      bytes memory ${dynamicFields.length > 0 ? \"_dynamicData\" : \"\"}\n    ) internal pure returns (${renderedDecodedRecord}) {\n  `;\n\n  if (staticFields.length > 0) {\n    result += `\n      (${renderArguments(staticFields.map((field) => `${fieldNamePrefix}${field.name}`))}) = decodeStatic(_staticData);\n    `;\n  }\n  if (dynamicFields.length > 0) {\n    result += `\n      (${renderArguments(\n        dynamicFields.map((field) => `${fieldNamePrefix}${field.name}`)\n      )}) = decodeDynamic(_encodedLengths, _dynamicData);\n    `;\n  }\n\n  result += `\n    }\n  `;\n\n  return result;\n}\n\n// contents of `returns (...)` for record getter/decoder\nfunction renderDecodedRecord({ structName, fields }: RenderTableOptions) {\n  if (structName) {\n    return `${structName} memory _table`;\n  } else {\n    return renderArguments(fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));\n  }\n}\n\nfunction renderDecodeDynamicFieldPartial(field: RenderDynamicField) {\n  const { typeId, arrayElement, typeWrap } = field;\n  if (arrayElement) {\n    // arrays\n    return `${typeWrap}(\n      SliceLib.getSubslice(_blob, _start, _end).decodeArray_${arrayElement.typeId}()\n    )`;\n  } else {\n    // bytes/string\n    return `${typeWrap}(\n      ${typeId}(\n        SliceLib.getSubslice(_blob, _start, _end).toBytes()\n      )\n    )`;\n  }\n}\n","import {\n  RenderDynamicField,\n  renderArguments,\n  renderCommonData,\n  renderList,\n  renderImports,\n  renderTableId,\n  renderTypeHelpers,\n  renderWithStore,\n  renderedSolidityHeader,\n  RenderStaticField,\n} from \"@latticexyz/common/codegen\";\nimport { renderEncodeFieldSingle, renderFieldMethods } from \"./field\";\nimport { renderDeleteRecordMethods, renderRecordData, renderRecordMethods } from \"./record\";\nimport { renderFieldLayout } from \"./renderFieldLayout\";\nimport { RenderTableOptions } from \"./types\";\n\nexport function renderTable(options: RenderTableOptions) {\n  const {\n    imports,\n    libraryName,\n    structName,\n    staticResourceData,\n    storeImportPath,\n    fields,\n    staticFields,\n    dynamicFields,\n    withRecordMethods,\n    storeArgument,\n    keyTuple,\n  } = options;\n\n  const { _typedTableId, _typedKeyArgs, _keyTupleDefinition } = renderCommonData(options);\n\n  return `\n    ${renderedSolidityHeader}\n\n    // Import schema type\n    import { SchemaType } from \"@latticexyz/schema-type/src/solidity/SchemaType.sol\";\n\n    // Import store internals\n    import { IStore } from \"${storeImportPath}IStore.sol\";\n    import { StoreSwitch } from \"${storeImportPath}StoreSwitch.sol\";\n    import { StoreCore } from \"${storeImportPath}StoreCore.sol\";\n    import { Bytes } from \"${storeImportPath}Bytes.sol\";\n    import { Memory } from \"${storeImportPath}Memory.sol\";\n    import { SliceLib } from \"${storeImportPath}Slice.sol\";\n    import { EncodeArray } from \"${storeImportPath}tightcoder/EncodeArray.sol\";\n    import { FieldLayout, FieldLayoutLib } from \"${storeImportPath}FieldLayout.sol\";\n    import { Schema, SchemaLib } from \"${storeImportPath}Schema.sol\";\n    import { PackedCounter, PackedCounterLib } from \"${storeImportPath}PackedCounter.sol\";\n    import { ResourceId } from \"${storeImportPath}ResourceId.sol\";\n    import { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"${storeImportPath}storeResourceTypes.sol\";\n\n    ${\n      imports.length > 0\n        ? `\n          // Import user types\n          ${renderImports(imports)}\n          `\n        : \"\"\n    }\n\n    ${staticResourceData ? renderTableId(staticResourceData).tableIdDefinition : \"\"}\n\n    ${renderFieldLayout(fields)}\n\n    ${\n      !structName\n        ? \"\"\n        : `\n          struct ${structName} {\n            ${renderList(fields, ({ name, typeId }) => `${typeId} ${name};`)}\n          }\n          `\n    }\n\n    library ${libraryName} {\n      /** Get the table values' field layout */\n      function getFieldLayout() internal pure returns (FieldLayout) {\n        return _fieldLayout;\n      }\n\n      /** Get the table's key schema */\n      function getKeySchema() internal pure returns (Schema) {\n        SchemaType[] memory _keySchema = new SchemaType[](${keyTuple.length});\n        ${renderList(keyTuple, ({ enumName }, index) => `_keySchema[${index}] = SchemaType.${enumName};`)}\n\n        return SchemaLib.encode(_keySchema);\n      }\n\n      /** Get the table's value schema */\n      function getValueSchema() internal pure returns (Schema) {\n        SchemaType[] memory _valueSchema = new SchemaType[](${fields.length});\n        ${renderList(fields, ({ enumName }, index) => `_valueSchema[${index}] = SchemaType.${enumName};`)}\n\n        return SchemaLib.encode(_valueSchema);\n      }\n\n      /** Get the table's key names */\n      function getKeyNames() internal pure returns (string[] memory keyNames) {\n        keyNames = new string[](${keyTuple.length});\n        ${renderList(keyTuple, (keyElement, index) => `keyNames[${index}] = \"${keyElement.name}\";`)}\n      }\n\n      /** Get the table's field names */\n      function getFieldNames() internal pure returns (string[] memory fieldNames) {\n        fieldNames = new string[](${fields.length});\n        ${renderList(fields, (field, index) => `fieldNames[${index}] = \"${field.name}\";`)}\n      }\n\n      ${renderWithStore(\n        storeArgument,\n        (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n          /** Register the table with its config${_commentSuffix} */\n          function ${_methodNamePrefix}register(${renderArguments([_typedStore, _typedTableId])}) internal {\n            ${_store}.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());\n          }\n        `\n      )}\n\n      ${renderFieldMethods(options)}\n\n      ${withRecordMethods ? renderRecordMethods(options) : \"\"}\n\n      ${renderDeleteRecordMethods(options)}\n\n      ${renderEncodeStatic(staticFields)}\n\n      ${renderEncodedLengths(dynamicFields)}\n\n      ${renderEncodeDynamic(dynamicFields)}\n\n      /** Tightly pack full data using this table's field layout */\n      function encode(${renderArguments(\n        options.fields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)\n      )}) internal pure returns (bytes memory, PackedCounter, bytes memory) {\n        ${renderRecordData(options)}\n\n        return (_staticData, _encodedLengths, _dynamicData);\n      }\n      \n      /** Encode keys as a bytes32 array using this table's field layout */\n      function encodeKeyTuple(${renderArguments([_typedKeyArgs])}) internal pure returns (bytes32[] memory) {\n        ${_keyTupleDefinition}\n        return _keyTuple;\n      }\n    }\n\n    ${renderTypeHelpers(options)}\n  `;\n}\n\nfunction renderEncodeStatic(staticFields: RenderStaticField[]) {\n  if (staticFields.length === 0) return \"\";\n\n  return `\n    /** Tightly pack static data using this table's schema */\n    function encodeStatic(${renderArguments(\n      staticFields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)\n    )}) internal pure returns (bytes memory) {\n      return abi.encodePacked(${renderArguments(staticFields.map(({ name }) => name))});\n    }\n  `;\n}\n\nfunction renderEncodedLengths(dynamicFields: RenderDynamicField[]) {\n  if (dynamicFields.length === 0) return \"\";\n\n  return `\n    /** Tightly pack dynamic data using this table's schema */\n    function encodeLengths(${renderArguments(\n      dynamicFields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)\n    )}) internal pure returns (PackedCounter _encodedLengths) {\n      // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits\n      unchecked {\n        _encodedLengths = PackedCounterLib.pack(\n          ${renderArguments(\n            dynamicFields.map(({ name, arrayElement }) => {\n              if (arrayElement) {\n                return `${name}.length * ${arrayElement.staticByteLength}`;\n              } else {\n                return `bytes(${name}).length`;\n              }\n            })\n          )}\n        );\n      }\n    }\n  `;\n}\n\nfunction renderEncodeDynamic(dynamicFields: RenderDynamicField[]) {\n  if (dynamicFields.length === 0) return \"\";\n\n  return `\n    /** Tightly pack dynamic data using this table's schema */\n    function encodeDynamic(${renderArguments(\n      dynamicFields.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`)\n    )}) internal pure returns (bytes memory) {\n      return abi.encodePacked(${renderArguments(dynamicFields.map((field) => renderEncodeFieldSingle(field)))});\n    }\n  `;\n}\n","/* Shared constants */\n// Make sure these stay aligned with @latticexyz/store/src/constants.sol\n\n// Total byte length of an EVM word\nexport const WORD_SIZE = 32;\n// Index of the last byte in an EVM word\nexport const WORD_LAST_INDEX = 31;\n// Conversion for bit shifting\nexport const BYTE_TO_BITS = 8;\n\n// Schema's capacity\nexport const MAX_TOTAL_FIELDS = 28;\n// FieldLayout's capacity\nexport const MAX_STATIC_FIELDS = 28;\n// PackedCounter's capacity\nexport const MAX_DYNAMIC_FIELDS = 5;\n\n// FieldLayout and Schema have the same offsets for metadata\nexport const LayoutOffsets = {\n  TOTAL_LENGTH: (WORD_SIZE - 2) * BYTE_TO_BITS,\n  NUM_STATIC_FIELDS: (WORD_SIZE - 2 - 1) * BYTE_TO_BITS,\n  NUM_DYNAMIC_FIELDS: (WORD_SIZE - 2 - 1 - 1) * BYTE_TO_BITS,\n};\n","import { RenderType } from \"@latticexyz/common/codegen\";\nimport { BYTE_TO_BITS, LayoutOffsets, MAX_DYNAMIC_FIELDS, MAX_TOTAL_FIELDS, WORD_LAST_INDEX } from \"../constants\";\n\nexport function renderFieldLayout(fields: RenderType[]) {\n  return `FieldLayout constant _fieldLayout = FieldLayout.wrap(${encodeFieldLayout(fields)});`;\n}\n\n// Make sure this logic stays aligned with @latticexyz/store/src/FieldLayout.sol\nexport function encodeFieldLayout(fields: RenderType[]) {\n  const staticFields = fields.filter(({ isDynamic }) => !isDynamic);\n  const numDynamicFields = fields.length - staticFields.length;\n\n  let fieldLayout = 0n;\n  let totalLength = 0;\n  const totalFields = fields.length;\n\n  if (totalFields > MAX_TOTAL_FIELDS) throw new Error(`FieldLayout: invalid length ${totalFields}`);\n  if (numDynamicFields > MAX_DYNAMIC_FIELDS) throw new Error(`FieldLayout: invalid length ${numDynamicFields}`);\n\n  for (let i = 0; i < staticFields.length; i++) {\n    const { isDynamic, staticByteLength } = fields[i];\n    if (isDynamic) throw new Error(`FieldLayout: static type after dynamic type`);\n\n    totalLength += staticByteLength;\n    fieldLayout |= BigInt(staticByteLength) << BigInt((WORD_LAST_INDEX - 4 - i) * BYTE_TO_BITS);\n  }\n\n  fieldLayout |= BigInt(totalLength) << BigInt(LayoutOffsets.TOTAL_LENGTH);\n  fieldLayout |= BigInt(staticFields.length) << BigInt(LayoutOffsets.NUM_STATIC_FIELDS);\n  fieldLayout |= BigInt(numDynamicFields) << BigInt(LayoutOffsets.NUM_DYNAMIC_FIELDS);\n\n  return `0x${fieldLayout.toString(16).padStart(64, \"0\")}`;\n}\n","import { renderEnums } from \"@latticexyz/common/codegen\";\nimport { StoreConfig } from \"../config\";\n\nexport function renderTypesFromConfig(config: StoreConfig) {\n  const enums = Object.keys(config.enums).map((name) => ({\n    name,\n    memberNames: config.enums[name],\n  }));\n\n  return renderEnums(enums);\n}\n","import path from \"path\";\nimport { formatAndWriteSolidity, loadAndExtractUserTypes } from \"@latticexyz/common/codegen\";\nimport { getTableOptions } from \"./tableOptions\";\nimport { renderTable } from \"./renderTable\";\nimport { renderTypesFromConfig } from \"./renderTypesFromConfig\";\nimport { renderTableIndex } from \"./renderTableIndex\";\nimport { rmSync } from \"fs\";\nimport { StoreConfig } from \"../config\";\n\nexport async function tablegen(config: StoreConfig, outputBaseDirectory: string, remappings: [string, string][]) {\n  const solidityUserTypes = loadAndExtractUserTypes(config.userTypes, outputBaseDirectory, remappings);\n  const allTableOptions = getTableOptions(config, solidityUserTypes);\n\n  const uniqueTableDirectories = new Set(allTableOptions.map(({ outputPath }) => path.dirname(outputPath)));\n  for (const tableDir of uniqueTableDirectories) {\n    rmSync(path.join(outputBaseDirectory, tableDir), { recursive: true, force: true });\n  }\n\n  // write tables to files\n  for (const { outputPath, renderOptions } of allTableOptions) {\n    const fullOutputPath = path.join(outputBaseDirectory, outputPath);\n    const output = renderTable(renderOptions);\n    await formatAndWriteSolidity(output, fullOutputPath, \"Generated table\");\n  }\n\n  // write types to file\n  if (Object.keys(config.enums).length > 0) {\n    const fullOutputPath = path.join(outputBaseDirectory, config.userTypesFilename);\n    const output = renderTypesFromConfig(config);\n    await formatAndWriteSolidity(output, fullOutputPath, \"Generated types file\");\n  }\n\n  const fullOutputPath = path.join(outputBaseDirectory, config.codegenIndexFilename);\n  const output = renderTableIndex(allTableOptions);\n  await formatAndWriteSolidity(output, fullOutputPath, \"Generated table index\");\n}\n","import path from \"path\";\nimport { SchemaTypeArrayToElement } from \"@latticexyz/schema-type/deprecated\";\nimport {\n  ImportDatum,\n  RenderDynamicField,\n  RenderField,\n  RenderKeyTuple,\n  RenderStaticField,\n  SolidityUserDefinedType,\n} from \"@latticexyz/common/codegen\";\nimport { RenderTableOptions } from \"./types\";\nimport { StoreConfig } from \"../config\";\nimport { getSchemaTypeInfo, importForAbiOrUserType, resolveAbiOrUserType } from \"./userType\";\n\nexport interface TableOptions {\n  outputPath: string;\n  tableName: string;\n  renderOptions: RenderTableOptions;\n}\n\nexport function getTableOptions(\n  config: StoreConfig,\n  solidityUserTypes: Record<string, SolidityUserDefinedType>\n): TableOptions[] {\n  const storeImportPath = config.storeImportPath;\n\n  const options = [];\n  for (const tableName of Object.keys(config.tables)) {\n    const tableData = config.tables[tableName];\n\n    // struct adds methods to get/set all values at once\n    const withStruct = tableData.dataStruct;\n    // operate on all fields at once; always render for offchain tables; for only 1 field keep them if struct is also kept\n    const withRecordMethods = withStruct || tableData.offchainOnly || Object.keys(tableData.valueSchema).length > 1;\n    // field methods can include simply get/set if there's only 1 field and no record methods\n    const withSuffixlessFieldMethods = !withRecordMethods && Object.keys(tableData.valueSchema).length === 1;\n    // list of any symbols that need to be imported\n    const imports: ImportDatum[] = [];\n\n    const keyTuple = Object.keys(tableData.keySchema).map((name) => {\n      const abiOrUserType = tableData.keySchema[name];\n      const { renderType } = resolveAbiOrUserType(abiOrUserType, config, solidityUserTypes);\n\n      const importDatum = importForAbiOrUserType(abiOrUserType, tableData.directory, config, solidityUserTypes);\n      if (importDatum) imports.push(importDatum);\n\n      if (renderType.isDynamic) throw new Error(`Parsing error: found dynamic key ${name} in table ${tableName}`);\n\n      const keyTuple: RenderKeyTuple = {\n        ...renderType,\n        name,\n        isDynamic: false,\n      };\n      return keyTuple;\n    });\n\n    const fields = Object.keys(tableData.valueSchema).map((name) => {\n      const abiOrUserType = tableData.valueSchema[name];\n      const { renderType, schemaType } = resolveAbiOrUserType(abiOrUserType, config, solidityUserTypes);\n\n      const importDatum = importForAbiOrUserType(abiOrUserType, tableData.directory, config, solidityUserTypes);\n      if (importDatum) imports.push(importDatum);\n\n      const elementType = SchemaTypeArrayToElement[schemaType];\n      const field: RenderField = {\n        ...renderType,\n        arrayElement: elementType !== undefined ? getSchemaTypeInfo(elementType) : undefined,\n        name,\n      };\n      return field;\n    });\n\n    const staticFields = fields.filter(({ isDynamic }) => !isDynamic) as RenderStaticField[];\n    const dynamicFields = fields.filter(({ isDynamic }) => isDynamic) as RenderDynamicField[];\n\n    // With tableIdArgument: tableId is a dynamic argument for each method\n    // Without tableIdArgument: tableId is a file-level constant generated from `staticResourceData`\n    const staticResourceData = (() => {\n      if (tableData.tableIdArgument) {\n        return;\n      } else {\n        return {\n          tableIdName: tableName + \"TableId\",\n          namespace: config.namespace,\n          name: tableData.name,\n          offchainOnly: tableData.offchainOnly,\n        };\n      }\n    })();\n\n    options.push({\n      outputPath: path.join(tableData.directory, `${tableName}.sol`),\n      tableName,\n      renderOptions: {\n        imports,\n        libraryName: tableName,\n        structName: withStruct ? tableName + \"Data\" : undefined,\n        staticResourceData,\n        storeImportPath,\n        keyTuple,\n        fields,\n        staticFields,\n        dynamicFields,\n        withGetters: !tableData.offchainOnly,\n        withRecordMethods,\n        withDynamicFieldMethods: !tableData.offchainOnly,\n        withSuffixlessFieldMethods,\n        storeArgument: tableData.storeArgument,\n      },\n    });\n  }\n  return options;\n}\n","import {\n  AbiTypeToSchemaType,\n  getStaticByteLength,\n  SchemaType,\n  SchemaTypeToAbiType,\n} from \"@latticexyz/schema-type/deprecated\";\nimport { parseStaticArray } from \"@latticexyz/config\";\nimport { ImportDatum, RenderType, SolidityUserDefinedType } from \"@latticexyz/common/codegen\";\nimport { StoreConfig } from \"../config\";\n\nexport type UserTypeInfo = ReturnType<typeof getUserTypeInfo>;\n\n/**\n * Resolve an abi or user type into a SchemaType and RenderType\n */\nexport function resolveAbiOrUserType(\n  abiOrUserType: string,\n  config: StoreConfig,\n  solidityUserTypes: Record<string, SolidityUserDefinedType>\n): {\n  schemaType: SchemaType;\n  renderType: RenderType;\n} {\n  // abi types which directly mirror a SchemaType\n  if (abiOrUserType in AbiTypeToSchemaType) {\n    const schemaType = AbiTypeToSchemaType[abiOrUserType];\n    return {\n      schemaType,\n      renderType: getSchemaTypeInfo(schemaType),\n    };\n  }\n  // static arrays\n  const staticArray = parseStaticArray(abiOrUserType);\n  if (staticArray) {\n    if (staticArray.elementType in AbiTypeToSchemaType) {\n      return getStaticArrayTypeInfo(abiOrUserType, staticArray.elementType, staticArray.staticLength);\n    } else {\n      throw new Error(\"Static arrays of user types are not supported\");\n    }\n  }\n  // user types\n  return getUserTypeInfo(abiOrUserType, config, solidityUserTypes);\n}\n\n/**\n * Get the required import for SchemaType|userType (`undefined` means that no import is required)\n */\nexport function importForAbiOrUserType(\n  abiOrUserType: string,\n  usedInDirectory: string,\n  config: StoreConfig,\n  solidityUserTypes: Record<string, SolidityUserDefinedType>\n): ImportDatum | undefined {\n  // abi types which directly mirror a SchemaType\n  if (abiOrUserType in AbiTypeToSchemaType) {\n    return undefined;\n  }\n  // static arrays\n  const staticArray = parseStaticArray(abiOrUserType);\n  if (staticArray) {\n    return undefined;\n  }\n  // user-defined types in a user-provided file\n  if (abiOrUserType in solidityUserTypes) {\n    // these types can have a library name as their import symbol\n    const solidityUserType = solidityUserTypes[abiOrUserType];\n    const symbol = solidityUserType.importSymbol;\n    if (solidityUserType.isRelativePath) {\n      return {\n        symbol,\n        fromPath: solidityUserType.fromPath,\n        usedInPath: usedInDirectory,\n      };\n    } else {\n      return {\n        symbol,\n        path: solidityUserType.fromPath,\n      };\n    }\n  }\n  // other user types\n  return {\n    symbol: abiOrUserType,\n    fromPath: config.userTypesFilename,\n    usedInPath: usedInDirectory,\n  };\n}\n\nexport function getSchemaTypeInfo(schemaType: SchemaType): RenderType {\n  const staticByteLength = getStaticByteLength(schemaType);\n  const isDynamic = staticByteLength === 0;\n  const typeId = SchemaTypeToAbiType[schemaType];\n  return {\n    typeId,\n    typeWithLocation: isDynamic ? typeId + \" memory\" : typeId,\n    enumName: SchemaType[schemaType],\n    staticByteLength,\n    isDynamic,\n    typeWrap: \"\",\n    typeUnwrap: \"\",\n    internalTypeId: typeId,\n  };\n}\n\nexport function getUserTypeInfo(\n  userType: string,\n  config: StoreConfig,\n  solidityUserTypes: Record<string, SolidityUserDefinedType>\n): {\n  schemaType: SchemaType;\n  renderType: RenderType;\n} {\n  // enums\n  if (userType in config.enums) {\n    const schemaType = SchemaType.UINT8;\n    const staticByteLength = getStaticByteLength(schemaType);\n    const isDynamic = staticByteLength === 0;\n    const typeId = userType;\n    return {\n      schemaType,\n      renderType: {\n        typeId,\n        typeWithLocation: typeId,\n        enumName: SchemaType[schemaType],\n        staticByteLength,\n        isDynamic,\n        typeWrap: `${userType}`,\n        typeUnwrap: `uint8`,\n        internalTypeId: `${SchemaTypeToAbiType[schemaType]}`,\n      },\n    };\n  }\n  // user-defined types\n  if (userType in solidityUserTypes) {\n    if (!(userType in solidityUserTypes)) {\n      throw new Error(`User type \"${userType}\" not found in MUD config`);\n    }\n    const solidityUserType = solidityUserTypes[userType];\n    const typeId = solidityUserType.typeId;\n    const schemaType = AbiTypeToSchemaType[solidityUserType.internalTypeId];\n    return {\n      schemaType,\n      renderType: {\n        typeId,\n        typeWithLocation: typeId,\n        enumName: SchemaType[schemaType],\n        staticByteLength: getStaticByteLength(schemaType),\n        isDynamic: false,\n        typeWrap: `${typeId}.wrap`,\n        typeUnwrap: `${typeId}.unwrap`,\n        internalTypeId: `${solidityUserType.internalTypeId}`,\n      },\n    };\n  }\n  // invalid\n  throw new Error(`User type \"${userType}\" does not exist`);\n}\n\nfunction getStaticArrayTypeInfo(abiType: string, elementType: string, staticLength: number) {\n  const internalTypeId = elementType + \"[]\";\n  const schemaType = AbiTypeToSchemaType[internalTypeId];\n  return {\n    schemaType,\n    renderType: {\n      typeId: abiType,\n      typeWithLocation: `${abiType} memory`,\n      enumName: SchemaType[schemaType],\n      staticByteLength: 0,\n      isDynamic: true,\n      typeWrap: `toStaticArray_${elementType}_${staticLength}`,\n      typeUnwrap: `fromStaticArray_${elementType}_${staticLength}`,\n      typeWrappingData: {\n        kind: \"staticArray\",\n        elementType,\n        staticLength,\n      },\n      internalTypeId,\n    },\n  } as const;\n}\n","import { posixPath, renderList, renderedSolidityHeader } from \"@latticexyz/common/codegen\";\nimport { TableOptions } from \"./tableOptions\";\n\nexport function renderTableIndex(options: TableOptions[]) {\n  return `\n    ${renderedSolidityHeader}\n\n    ${renderList(options, ({ outputPath, tableName, renderOptions: { structName, staticResourceData } }) => {\n      const imports = [tableName];\n      if (structName) imports.push(structName);\n      if (staticResourceData) imports.push(`${tableName}TableId`);\n\n      return `import { ${imports.join(\", \")} } from \"./${posixPath(outputPath)}\";`;\n    })}\n  `;\n}\n","import { renderedSolidityHeader } from \"@latticexyz/common/codegen\";\nimport { staticAbiTypeToByteLength, staticAbiTypes } from \"@latticexyz/schema-type\";\nimport { renderTightCoderDecode } from \"./renderFunctions\";\n\nexport function renderDecodeSlice() {\n  return `\n    ${renderedSolidityHeader}\n    import { TightCoder } from \"./TightCoder.sol\";\n    import { Slice } from \"../Slice.sol\";\n    library DecodeSlice {\n      ${staticAbiTypes\n        .map((staticAbiType) =>\n          renderTightCoderDecode({\n            internalTypeId: staticAbiType,\n            staticByteLength: staticAbiTypeToByteLength[staticAbiType],\n          })\n        )\n        .join(\"\\n\")}\n    }\n  `;\n}\n","import { getLeftPaddingBits } from \"@latticexyz/common/codegen\";\n\nexport function renderTightCoderDecode(element: { internalTypeId: string; staticByteLength: number }) {\n  return `\n    function decodeArray_${element.internalTypeId}(\n      Slice _input\n    ) internal pure returns (\n      ${element.internalTypeId}[] memory _output\n    ) {\n      bytes32[] memory _genericArray = TightCoder.decode(\n        _input,\n        ${element.staticByteLength},\n        ${getLeftPaddingBits(element)}\n      );\n      assembly {\n        _output := _genericArray\n      }\n    }\n  `;\n}\n\nexport function renderTightCoderEncode(element: { internalTypeId: string; staticByteLength: number }) {\n  return `\n    function encode(${element.internalTypeId}[] memory _input) internal pure returns (bytes memory) {\n      bytes32[] memory _genericArray;\n      assembly {\n        _genericArray := _input\n      }\n      return TightCoder.encode(\n        _genericArray,\n        ${element.staticByteLength},\n        ${getLeftPaddingBits(element)}\n      );\n    }\n  `;\n}\n","import { renderedSolidityHeader } from \"@latticexyz/common/codegen\";\nimport { staticAbiTypeToByteLength, staticAbiTypes } from \"@latticexyz/schema-type\";\nimport { renderTightCoderEncode } from \"./renderFunctions\";\n\nexport function renderEncodeArray() {\n  return `\n    ${renderedSolidityHeader}\n    import { TightCoder } from \"./TightCoder.sol\";\n    library EncodeArray {\n      ${staticAbiTypes\n        .map((staticAbiType) =>\n          renderTightCoderEncode({\n            internalTypeId: staticAbiType,\n            staticByteLength: staticAbiTypeToByteLength[staticAbiType],\n          })\n        )\n        .join(\"\\n\")}\n      }\n  `;\n}\n","import { renderedSolidityHeader } from \"@latticexyz/common/codegen\";\nimport { staticAbiTypes } from \"@latticexyz/schema-type\";\n\nexport function renderTightCoderAutoTestFunction({ typeId }: { typeId: string }) {\n  return `\n    function testEncodeDecodeArray_${typeId}(\n      ${typeId} val0,\n      ${typeId} val1,\n      ${typeId} val2\n    ) public {\n      ${typeId}[] memory input = new ${typeId}[](3);\n      input[0] = val0;\n      input[1] = val1;\n      input[2] = val2;\n\n      bytes memory encoded = EncodeArray.encode(input);\n      assertEq(encoded, abi.encodePacked(val0, val1, val2));\n\n      ${typeId}[] memory decoded = SliceLib.fromBytes(encoded).decodeArray_${typeId}();\n      assertEq(decoded.length, 3);\n      assertEq(decoded[0], val0);\n      assertEq(decoded[1], val1);\n      assertEq(decoded[2], val2);\n    }\n  `;\n}\n\nexport function renderTightCoderAutoTest() {\n  return `\n    ${renderedSolidityHeader}\n\n    import { Test } from \"forge-std/Test.sol\";\n    import { EncodeArray } from \"../../src/tightcoder/EncodeArray.sol\";\n    import { SliceLib } from \"../../src/Slice.sol\";\n\n    contract TightCoderAutoTest is Test {\n      ${staticAbiTypes.map((staticAbiType) => renderTightCoderAutoTestFunction({ typeId: staticAbiType })).join(\"\")}\n    }\n  `;\n}\n"],"mappings":"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","names":["renderArguments","renderCommonData","renderWithFieldSuffix","renderWithStore","renderFieldMethods","options","storeArgument","_typedTableId","_typedKeyArgs","_keyTupleDefinition","result","schemaIndex","field","_typedFieldName","_methodNameSuffix","_typedStore","_store","_commentSuffix","_untypedStore","_methodNamePrefix","renderDecodeFieldSingle","externalArguments","setFieldMethod","encodeFieldSingle","renderEncodeFieldSingle","internalArguments","portionData","fieldPortionData","dynamicSchemaIndex","func","renderDecodeValueType","offset","staticByteLength","innerSlice","renderCastStaticBytesToType","staticBytes","internalTypeId","bits","methodNameSuffix","name","elementFieldData","isDynamic","arrayElement","renderArguments","renderCommonData","renderList","renderWithStore","renderRecordMethods","options","structName","storeArgument","_typedTableId","_typedKeyArgs","_keyTupleDefinition","renderCommonData","result","renderWithStore","_typedStore","_store","_commentSuffix","_untypedStore","_methodNamePrefix","renderArguments","renderDecodedRecord","_internal","externalArguments","name","typeWithLocation","internalArguments","renderRecordData","renderDecodeFunctions","namePrefix","renderDeleteRecordMethods","fields","staticFields","dynamicFields","renderedDecodedRecord","fieldNamePrefix","staticOffsets","_acc","index","field","renderList","renderDecodeValueType","renderDecodeDynamicFieldPartial","typeId","arrayElement","typeWrap","renderArguments","renderCommonData","renderList","renderImports","renderTableId","renderTypeHelpers","renderWithStore","renderedSolidityHeader","LayoutOffsets","renderFieldLayout","fields","encodeFieldLayout","staticFields","isDynamic","numDynamicFields","fieldLayout","totalLength","totalFields","i","staticByteLength","LayoutOffsets","renderTable","options","imports","libraryName","structName","staticResourceData","storeImportPath","fields","staticFields","dynamicFields","withRecordMethods","storeArgument","keyTuple","_typedTableId","_typedKeyArgs","_keyTupleDefinition","renderCommonData","renderedSolidityHeader","renderImports","renderTableId","renderFieldLayout","renderList","name","typeId","enumName","index","keyElement","field","renderWithStore","_typedStore","_store","_commentSuffix","_untypedStore","_methodNamePrefix","renderArguments","renderFieldMethods","renderRecordMethods","renderDeleteRecordMethods","renderEncodeStatic","renderEncodedLengths","renderEncodeDynamic","typeWithLocation","renderRecordData","renderTypeHelpers","arrayElement","renderEncodeFieldSingle","renderEnums","renderTypesFromConfig","config","enums","name","path","formatAndWriteSolidity","loadAndExtractUserTypes","path","SchemaTypeArrayToElement","AbiTypeToSchemaType","getStaticByteLength","SchemaType","SchemaTypeToAbiType","parseStaticArray","resolveAbiOrUserType","abiOrUserType","config","solidityUserTypes","schemaType","getSchemaTypeInfo","staticArray","getStaticArrayTypeInfo","getUserTypeInfo","importForAbiOrUserType","usedInDirectory","solidityUserType","symbol","staticByteLength","isDynamic","typeId","userType","abiType","elementType","staticLength","internalTypeId","getTableOptions","config","solidityUserTypes","storeImportPath","options","tableName","tableData","withStruct","withRecordMethods","withSuffixlessFieldMethods","imports","keyTuple","name","abiOrUserType","renderType","resolveAbiOrUserType","importDatum","importForAbiOrUserType","fields","schemaType","elementType","SchemaTypeArrayToElement","getSchemaTypeInfo","staticFields","isDynamic","dynamicFields","staticResourceData","path","posixPath","renderList","renderedSolidityHeader","renderTableIndex","options","outputPath","tableName","structName","staticResourceData","imports","rmSync","tablegen","config","outputBaseDirectory","remappings","solidityUserTypes","loadAndExtractUserTypes","allTableOptions","getTableOptions","uniqueTableDirectories","outputPath","path","tableDir","renderOptions","fullOutputPath","output","renderTable","formatAndWriteSolidity","renderTypesFromConfig","renderTableIndex","renderedSolidityHeader","staticAbiTypeToByteLength","staticAbiTypes","getLeftPaddingBits","renderTightCoderDecode","element","renderTightCoderEncode","renderDecodeSlice","renderedSolidityHeader","staticAbiTypes","staticAbiType","renderTightCoderDecode","staticAbiTypeToByteLength","renderedSolidityHeader","staticAbiTypeToByteLength","staticAbiTypes","renderEncodeArray","renderedSolidityHeader","staticAbiTypes","staticAbiType","renderTightCoderEncode","staticAbiTypeToByteLength","renderedSolidityHeader","staticAbiTypes","renderTightCoderAutoTestFunction","typeId","renderTightCoderAutoTest","staticAbiType"]}