{"version":3,"sources":["../../src/deprecated/constants.ts","../../src/deprecated/createActionSystem.ts","../../src/deprecated/defineActionComponent.ts"],"sourcesContent":["export enum ActionState {\n  Requested = \"Requested\",\n  Executing = \"Executing\",\n  WaitingForTxEvents = \"WaitingForTxEvents\",\n  Complete = \"Complete\",\n  Failed = \"Failed\",\n  Cancelled = \"Cancelled\",\n  TxReduced = \"TxReduced\",\n}\n","import { merge, Observable } from \"rxjs\";\nimport { mapObject, awaitStreamValue, uuid } from \"@latticexyz/utils\";\nimport { ActionState } from \"./constants\";\nimport { ActionData, ActionRequest } from \"./types\";\nimport { defineActionComponent } from \"./defineActionComponent\";\nimport { overridableComponent, setComponent, getComponentValue, updateComponent } from \"../Component\";\nimport { createEntity } from \"../Entity\";\nimport { World, OverridableComponent, Metadata, Component, Components, Entity, Schema } from \"../types\";\n\nexport type ActionSystem = ReturnType<typeof createActionSystem>;\n\n/**\n * @deprecated For now, we suggest using `overridableComponent(Component)` and `addOverride`/`removeOverride` to manage overrides yourself.\n */\nexport function createActionSystem<M = unknown>(\n  world: World,\n  txReduced$: Observable<string>,\n  waitForTransaction?: (tx: string) => Promise<void>\n) {\n  // Action component\n  const Action = defineActionComponent<M>(world);\n\n  // Components that scheduled actions depend on including pending updates\n  const componentsWithOptimisticUpdates: { [id: string]: OverridableComponent<Schema> } = {};\n\n  // ActionData contains requirements and execute logic of scheduled actions.\n  // We also store the relevant subset of all componentsWithOptimisticUpdates in the action data,\n  // to recheck requirements only if relevant components updated.\n  const actionData = new Map<string, ActionData>();\n\n  // Disposers of requirement check autoruns for all pending actions\n  const disposer = new Map<string, { dispose: () => void }>();\n  world.registerDisposer(() => {\n    for (const { dispose } of disposer.values()) dispose();\n  });\n\n  /**\n   * Maps all components in a given components map to the respective components including pending updates\n   * @param component Component to be mapped to components including pending updates\n   * @returns Components including pending updates\n   */\n  function withOptimisticUpdates<S extends Schema, M extends Metadata, T>(\n    component: Component<S, M, T>\n  ): OverridableComponent<S, M, T> {\n    const optimisticComponent = componentsWithOptimisticUpdates[component.id] || overridableComponent(component);\n\n    // If the component is not tracked yet, add it to the map of overridable components\n    if (!componentsWithOptimisticUpdates[component.id]) {\n      componentsWithOptimisticUpdates[component.id] = optimisticComponent;\n    }\n\n    // Typescript can't know that the optimistic component with this id has the same type as C\n    return optimisticComponent as OverridableComponent<S, M, T>;\n  }\n\n  /**\n   * Schedules an action. The action will be executed once its requirement is fulfilled.\n   * Note: the requirement will only be rechecked automatically if the requirement is based on components\n   * (or other mobx-observable values).\n   * @param actionRequest Action to be scheduled\n   * @returns index of the entity created for the action\n   */\n  function add<C extends Components, T>(actionRequest: ActionRequest<C, T, M>): Entity {\n    // Prevent the same actions from being scheduled multiple times\n    const existingAction = world.hasEntity(actionRequest.id as Entity);\n    if (existingAction) {\n      console.warn(`Action with id ${actionRequest.id} is already requested.`);\n      return actionRequest.id as Entity;\n    }\n\n    // Set the action component\n    const entity = createEntity(world, undefined, {\n      id: actionRequest.id,\n    });\n\n    setComponent(Action, entity, {\n      state: ActionState.Requested,\n      on: actionRequest.on,\n      metadata: actionRequest.metadata,\n      overrides: undefined,\n      txHash: undefined,\n    });\n\n    // Add components that are not tracked yet to internal overridable component map.\n    // Pending updates will be applied to internal overridable components.\n    for (const component of Object.values(actionRequest.components)) {\n      if (!componentsWithOptimisticUpdates[component.id])\n        componentsWithOptimisticUpdates[component.id] = overridableComponent(component);\n    }\n\n    // Store relevant components with pending updates along the action's requirement and execution logic\n    const action = {\n      ...actionRequest,\n      entity,\n      componentsWithOptimisticUpdates: mapObject(actionRequest.components, (c) => withOptimisticUpdates(c)),\n    } as unknown as ActionData;\n    actionData.set(action.id, action);\n\n    // This subscriotion makes sure the action requirement is checked again every time\n    // one of the referenced components changes or the pending updates map changes\n    const subscription = merge(\n      ...Object.values(action.componentsWithOptimisticUpdates).map((c) => c.update$)\n    ).subscribe(() => checkRequirement(action));\n    checkRequirement(action);\n    disposer.set(action.id, { dispose: () => subscription?.unsubscribe() });\n\n    return entity;\n  }\n\n  /**\n   * Checks the requirement of a given action and executes the action if the requirement is fulfilled\n   * @param action Action to check the requirement of\n   * @returns void\n   */\n  function checkRequirement(action: ActionData) {\n    // Only check requirements of requested actions\n    if (getComponentValue(Action, action.entity)?.state !== ActionState.Requested) return;\n\n    // Check requirement on components including pending updates\n    const requirementResult = action.requirement(action.componentsWithOptimisticUpdates);\n\n    // Execute the action if the requirements are met\n    if (requirementResult) executeAction(action, requirementResult);\n  }\n\n  /**\n   * Executes the given action and sets the corresponding Action component\n   * @param action ActionData of the action to be executed\n   * @param requirementResult Result of the action's requirement function\n   * @returns void\n   */\n  async function executeAction<T>(action: ActionData, requirementResult: T) {\n    // Only execute actions that were requested before\n    if (getComponentValue(Action, action.entity)?.state !== ActionState.Requested) return;\n\n    // Update the action state\n    updateComponent(Action, action.entity, { state: ActionState.Executing });\n\n    // Compute overrides\n    const overrides = action\n      .updates(action.componentsWithOptimisticUpdates, requirementResult)\n      .map((o) => ({ ...o, id: uuid() }));\n\n    // Store overrides on Action component to be able to remove when action is done\n    updateComponent(Action, action.entity, { overrides: overrides.map((o) => `${o.id}/${o.component.id}`) });\n\n    // Set all pending updates of this action\n    for (const { component, value, entity, id } of overrides) {\n      componentsWithOptimisticUpdates[component.id].addOverride(id, { entity, value });\n    }\n\n    try {\n      // Execute the action\n      const tx = await action.execute(requirementResult);\n\n      // If the result includes a hash key (single tx) or hashes (multiple tx) key, wait for the transactions to complete before removing the pending actions\n      if (tx) {\n        // Wait for all tx events to be reduced\n        updateComponent(Action, action.entity, { state: ActionState.WaitingForTxEvents, txHash: tx });\n        await awaitStreamValue(txReduced$, (v) => v === tx);\n        updateComponent(Action, action.entity, { state: ActionState.TxReduced });\n        // TODO: extend ActionData type to be aware of whether waitForTransaction is set\n        if (action.awaitConfirmation) {\n          if (waitForTransaction) {\n            await waitForTransaction(tx);\n          } else {\n            throw new Error(\"action has awaitConfirmation but no waitForTransaction specified in createActionSystem\");\n          }\n        }\n      }\n\n      updateComponent(Action, action.entity, { state: ActionState.Complete });\n    } catch (e) {\n      handleError(e, action);\n    }\n\n    // After the action is done executing (failed or completed), remove its actionData and remove the Action component\n    remove(action.id);\n  }\n\n  // Set the action's state to ActionState.Failed\n  function handleError(e: unknown, action: ActionData) {\n    console.error(e);\n    updateComponent(Action, action.entity, { state: ActionState.Failed });\n    remove(action.id);\n  }\n\n  /**\n   * Cancels the action with the given ID if it is in the \"Requested\" state.\n   * @param actionId ID of the action to be cancelled\n   * @returns void\n   */\n  function cancel(actionId: string): boolean {\n    const action = actionData.get(actionId);\n    if (!action || getComponentValue(Action, action.entity)?.state !== ActionState.Requested) {\n      console.warn(`Action ${actionId} was not found or is not in the \"Requested\" state.`);\n      return false;\n    }\n    updateComponent(Action, action.entity, { state: ActionState.Cancelled });\n    remove(actionId);\n    return true;\n  }\n\n  /**\n   * Removes actionData disposer of the action with the given ID and removes its pending updates.\n   * @param actionId ID of the action to be removed\n   */\n  function remove(actionId: string) {\n    const action = actionData.get(actionId);\n    if (!action) {\n      console.warn(`Trying to remove action ${actionId} that does not exist.`);\n      return;\n    }\n\n    // Remove this action's pending updates\n    const actionEntity = actionId as Entity;\n    const overrides = (actionEntity != null && getComponentValue(Action, actionEntity)?.overrides) || [];\n    for (const override of overrides) {\n      const [id, componentId] = override.split(\"/\");\n      const component = componentsWithOptimisticUpdates[componentId];\n      component.removeOverride(id);\n    }\n\n    // Remove this action's autorun and corresponding disposer\n    disposer.get(actionId)?.dispose();\n    disposer.delete(actionId);\n\n    // Remove the action data\n    actionData.delete(actionId);\n\n    // Remove the action entity after some time\n    actionEntity != null && setTimeout(() => world.deleteEntity(actionEntity), 5000);\n  }\n\n  return { add, cancel, withOptimisticUpdates, Action };\n}\n","import { defineComponent } from \"../Component\";\nimport { Type } from \"../constants\";\nimport { World, Component, SchemaOf, Metadata } from \"../types\";\n\nexport function defineActionComponent<T = unknown>(world: World) {\n  const Action = defineComponent(\n    world,\n    {\n      state: Type.String,\n      on: Type.OptionalEntity,\n      metadata: Type.OptionalT,\n      overrides: Type.OptionalStringArray,\n      txHash: Type.OptionalString,\n    },\n    { id: \"Action\" }\n  );\n  return Action as Component<SchemaOf<typeof Action>, Metadata, T>;\n}\n"],"mappings":"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","names":["ActionState","merge","mapObject","awaitStreamValue","uuid","defineActionComponent","world","defineComponent","createActionSystem","world","txReduced$","waitForTransaction","Action","defineActionComponent","componentsWithOptimisticUpdates","actionData","disposer","dispose","withOptimisticUpdates","component","optimisticComponent","overridableComponent","add","actionRequest","entity","createEntity","setComponent","action","mapObject","c","subscription","merge","checkRequirement","getComponentValue","requirementResult","executeAction","updateComponent","overrides","o","uuid","value","id","tx","awaitStreamValue","v","handleError","remove","e","cancel","actionId","actionEntity","override","componentId"]}