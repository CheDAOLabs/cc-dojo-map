var P=(o=>(o[o.Boolean=0]="Boolean",o[o.Number=1]="Number",o[o.OptionalNumber=2]="OptionalNumber",o[o.BigInt=3]="BigInt",o[o.OptionalBigInt=4]="OptionalBigInt",o[o.String=5]="String",o[o.OptionalString=6]="OptionalString",o[o.NumberArray=7]="NumberArray",o[o.OptionalNumberArray=8]="OptionalNumberArray",o[o.BigIntArray=9]="BigIntArray",o[o.OptionalBigIntArray=10]="OptionalBigIntArray",o[o.StringArray=11]="StringArray",o[o.OptionalStringArray=12]="OptionalStringArray",o[o.Entity=13]="Entity",o[o.OptionalEntity=14]="OptionalEntity",o[o.EntityArray=15]="EntityArray",o[o.OptionalEntityArray=16]="OptionalEntityArray",o[o.T=17]="T",o[o.OptionalT=18]="OptionalT",o))(P||{}),w=(i=>(i[i.Enter=0]="Enter",i[i.Exit=1]="Exit",i[i.Update=2]="Update",i[i.Noop=3]="Noop",i))(w||{}),k=[14,16,2,8,4,10,6,12,18];import{transformIterator as j,uuid as L}from"@latticexyz/utils";import{mapObject as N}from"@latticexyz/utils";import{filter as D,map as K,Subject as $}from"rxjs";function M(e){let t=new Map;function n(l){let s=t.get(a(l));return s?new Set([...s].map(x)):new Set}function a(l){return Object.values(l).join("/")}function i(l,s){if(!s)return;let v=a(s),f=t.get(v);f||(f=new Set,t.set(v,f)),f.add(l)}function d(l,s){if(!s)return;let v=a(s),f=t.get(v);f&&f.delete(l)}for(let l of O(e)){let s=g(e,l);i(p(l),s)}let c=e.update$.subscribe(({entity:l,value:s})=>{d(p(l),s[1]),i(p(l),s[0])});return e.world.registerDisposer(()=>c?.unsubscribe()),{...e,getEntitiesWithValue:n}}import{map as W,pipe as B}from"rxjs";function X(e,t){return e.component===t}function F(e,t){let n=g(t,e);return{entity:e,component:t,value:[n,void 0],type:n==null?3:0}}function Y(e){return B(W(t=>F(t,e)))}function I(e){return"getEntitiesWithValue"in e}function T(e,t){return Object.keys(e.schema).every(n=>n in t)}function b(e){return e.metadata?.componentName??e.metadata?.tableName??e.metadata?.tableId??e.metadata?.contractId??e.id}function ie(e,t,n){if(Object.keys(t).length===0)throw new Error("Component schema must have at least one key");let a=n?.id??L(),i=N(t,()=>new Map),d=new $,c=n?.metadata,s={values:i,schema:t,id:a,update$:d,metadata:c,entities:()=>j(Object.values(i)[0].keys(),x),world:e};return n?.indexed&&(s=M(s)),e.registerComponent(s),s}function E(e,t,n){let a=p(t),i=g(e,t);for(let[d,c]of Object.entries(n))e.values[d]?e.values[d].set(a,c):e.metadata?.tableId&&/^\d+$/.test(d)||console.warn("Component definition for",b(e),"is missing key",d,", ignoring value",c,"for entity",t,". Existing keys: ",Object.keys(e.values));e.update$.next({entity:t,value:[n,i],component:e})}function ue(e,t,n,a){let i=g(e,t);if(i===void 0){if(a===void 0)throw new Error(`Can't update component ${b(e)} without a current value or initial value`);E(e,t,{...a,...n})}else E(e,t,{...i,...n})}function se(e,t){let n=p(t),a=g(e,t);for(let i of Object.keys(e.values))e.values[i].delete(n);e.update$.next({entity:t,value:[void 0,a],component:e})}function le(e,t){let n=p(t);return Object.values(e.values)[0].has(n)}function g(e,t){let n={},a=p(t),i=Object.keys(e.schema);for(let d of i){let c=e.values[d].get(a);if(c===void 0&&!k.includes(e.schema[d]))return;n[d]=c}return n}function de(e,t){let n=g(e,t);if(!n)throw new Error(`No value for component ${b(e)} on entity ${t}`);return n}function q(e,t){if(!e&&!t)return!0;if(!e||!t)return!1;let n=!0;for(let a of Object.keys(e))if(n=e[a]===t[a],!n)return!1;return n}function me(e,t){return[e,t]}function ce(e,t){if(I(e)&&T(e,t))return e.getEntitiesWithValue(t);let n=new Set;for(let a of O(e)){let i=g(e,a);q(t,i)&&n.add(a)}return n}function O(e){return e.entities()}function Se(e){let t=0,n=new Map,a=new Map,i=new $;function d(u,r){n.set(u,{update:r,nonce:t++}),C(r.entity,r.value)}function c(u){let r=n.get(u)?.update.entity;if(n.delete(u),r==null)return;let S=[...n.values()].filter(m=>m.update.entity===r).sort((m,h)=>m.nonce<h.nonce?-1:1);if(S.length>0){let m=S[S.length-1];C(r,m.update.value)}else C(r,void 0)}function l(u){let r=g(e,u),S=p(u),m=a.get(S);return(r||m)&&m!==null?{...r,...m}:void 0}let s=u=>({get(r,S){return S==="get"?m=>{let h=r.get(m),V=a.get(m);return V&&V[u]!=null?V[u]:h}:S==="has"?m=>r.has(m)||a.has(m):S==="keys"?()=>new Set([...r.keys(),...a.keys()]).values():Reflect.get(r,S,r)}}),v={};for(let u of Object.keys(e.values))v[u]=new Proxy(e.values[u],s(u));let f=v,y=new Proxy(e,{get(u,r){return r==="addOverride"?d:r==="removeOverride"?c:r==="values"?f:r==="update$"?i:r==="entities"?()=>new Set([...j(a.keys(),x),...u.entities()]).values():Reflect.get(u,r)},has(u,r){return r==="addOverride"||r==="removeOverride"?!0:r in u}});function C(u,r){let S=p(u),m=l(u);r!==void 0?a.set(S,r):a.delete(S),i.next({entity:u,value:[l(u),m],component:y})}return e.update$.pipe(D(u=>!a.get(p(u.entity))),K(u=>({...u,component:y}))).subscribe(i),y}function A(e,t){return`localcache-${t}-${e.id}`}function fe(e,t){localStorage.removeItem(A(e,t))}function pe(e,t){let{world:n,update$:a,values:i}=e,d=A(e,t),c=0,l=Date.now(),s=localStorage.getItem(d);if(s){let f=JSON.parse(s),y={};for(let[C,u]of f)for(let[r,S]of u)y[r]=y[r]||{},y[r][C]=S;for(let[C,u]of Object.entries(y)){let r=n.registerEntity({id:C});E(e,r,u)}console.info("Loading component",b(e),"from local cache.")}let v=a.subscribe(()=>{c++;let f=JSON.stringify(Object.entries(N(i,y=>[...y.entries()].map(C=>[x(C[0]),C[1]]))));localStorage.setItem(d,f),c>200&&console.warn("Component",b(e),"was locally cached",c,"times since",new Date(l).toLocaleTimeString(),"- the local cache is in an alpha state and should not be used with components that update frequently yet")});return e.world.registerDisposer(()=>v?.unsubscribe()),e}function ge(e,t,n){let a=e.registerEntity(n??{});if(t)for(let[i,d]of t)E(i,a,d);return a}function p(e){return Symbol.for(e)}function x(e){return Symbol.keyFor(e)}export{P as a,w as b,k as c,ge as d,p as e,x as f,M as g,X as h,F as i,Y as j,I as k,T as l,ie as m,E as n,ue as o,se as p,le as q,g as r,de as s,q as t,me as u,ce as v,O as w,Se as x,fe as y,pe as z};
//# sourceMappingURL=chunk-EL5Z72NP.js.map