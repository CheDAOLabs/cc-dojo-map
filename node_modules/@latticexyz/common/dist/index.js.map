{"version":3,"sources":["../src/createBurnerAccount.ts","../src/createContract.ts","../src/createNonceManager.ts","../src/debug.ts","../src/getBurnerPrivateKey.ts","../src/hexToResourceId.ts","../src/resourceTypes.ts","../src/resourceIdToHex.ts","../src/readHex.ts","../src/spliceHex.ts","../src/transportObserver.ts"],"sourcesContent":["import { Account, Hex } from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\n\nexport function createBurnerAccount(privateKey: Hex): Account {\n  const account = privateKeyToAccount(privateKey);\n  // We may override account features here\n  return {\n    ...account,\n  };\n}\n","import {\n  Abi,\n  Account,\n  Address,\n  Chain,\n  GetContractParameters,\n  GetContractReturnType,\n  Hex,\n  PublicClient,\n  SimulateContractParameters,\n  Transport,\n  WalletClient,\n  WriteContractParameters,\n  getContract,\n} from \"viem\";\nimport pRetry from \"p-retry\";\nimport { createNonceManager } from \"./createNonceManager\";\nimport { debug as parentDebug } from \"./debug\";\nimport { UnionOmit } from \"./type-utils/common\";\n\nconst debug = parentDebug.extend(\"createContract\");\n\n// copied from viem because this isn't exported\n// TODO: import from viem?\nfunction getFunctionParameters(values: [args?: readonly unknown[], options?: object]): {\n  args: readonly unknown[];\n  options: object;\n} {\n  const hasArgs = values.length && Array.isArray(values[0]);\n  const args = hasArgs ? values[0]! : [];\n  const options = (hasArgs ? values[1] : values[0]) ?? {};\n  return { args, options };\n}\n\nexport type ContractWrite = {\n  id: string;\n  request: WriteContractParameters;\n  result: Promise<Hex>;\n};\n\nexport type CreateContractOptions<\n  TTransport extends Transport,\n  TAddress extends Address,\n  TAbi extends Abi,\n  TChain extends Chain,\n  TAccount extends Account,\n  TPublicClient extends PublicClient<TTransport, TChain>,\n  TWalletClient extends WalletClient<TTransport, TChain, TAccount>\n> = Required<GetContractParameters<TTransport, TChain, TAccount, TAbi, TPublicClient, TWalletClient, TAddress>> & {\n  onWrite?: (write: ContractWrite) => void;\n};\n\nexport function createContract<\n  TTransport extends Transport,\n  TAddress extends Address,\n  TAbi extends Abi,\n  TChain extends Chain,\n  TAccount extends Account,\n  TPublicClient extends PublicClient<TTransport, TChain>,\n  TWalletClient extends WalletClient<TTransport, TChain, TAccount>\n>({\n  abi,\n  address,\n  publicClient,\n  walletClient,\n  onWrite,\n}: CreateContractOptions<\n  TTransport,\n  TAddress,\n  TAbi,\n  TChain,\n  TAccount,\n  TPublicClient,\n  TWalletClient\n>): GetContractReturnType<TAbi, TPublicClient, TWalletClient, TAddress> {\n  const contract = getContract<TTransport, TAddress, TAbi, TChain, TAccount, TPublicClient, TWalletClient>({\n    abi,\n    address,\n    publicClient,\n    walletClient,\n  }) as unknown as GetContractReturnType<Abi, PublicClient, WalletClient>;\n\n  if (contract.write) {\n    let nextWriteId = 0;\n    const nonceManager = createNonceManager({\n      publicClient: publicClient as PublicClient,\n      address: walletClient.account.address,\n    });\n\n    // Replace write calls with our own proxy. Implemented ~the same as viem, but adds better handling of nonces (via queue + retries).\n    contract.write = new Proxy(\n      {},\n      {\n        get(_, functionName: string): GetContractReturnType<Abi, PublicClient, WalletClient>[\"write\"][string] {\n          async function prepareWrite(\n            options: WriteContractParameters\n          ): Promise<WriteContractParameters<TAbi, typeof functionName, TChain, TAccount>> {\n            if (options.gas) {\n              debug(\"gas provided, skipping simulate\", functionName, options);\n              return options as unknown as WriteContractParameters<TAbi, typeof functionName, TChain, TAccount>;\n            }\n\n            debug(\"simulating write\", functionName, options);\n            const { request } = await publicClient.simulateContract({\n              ...options,\n              account: options.account ?? walletClient.account,\n            } as unknown as SimulateContractParameters<TAbi, typeof functionName, TChain>);\n\n            return request as unknown as WriteContractParameters<TAbi, typeof functionName, TChain, TAccount>;\n          }\n\n          async function write(options: WriteContractParameters): Promise<Hex> {\n            const preparedWrite = await prepareWrite(options);\n\n            return await pRetry(\n              async () => {\n                if (!nonceManager.hasNonce()) {\n                  await nonceManager.resetNonce();\n                }\n\n                const nonce = nonceManager.nextNonce();\n                debug(\"calling write function with nonce\", nonce, preparedWrite);\n                return await walletClient.writeContract({\n                  nonce,\n                  ...preparedWrite,\n                });\n              },\n              {\n                retries: 3,\n                onFailedAttempt: async (error) => {\n                  // On nonce errors, reset the nonce and retry\n                  if (nonceManager.shouldResetNonce(error)) {\n                    debug(\"got nonce error, retrying\", error);\n                    await nonceManager.resetNonce();\n                    return;\n                  }\n                  // TODO: prepareWrite again if there are gas errors?\n                  throw error;\n                },\n              }\n            );\n          }\n\n          return (...parameters) => {\n            const id = `${walletClient.chain.id}:${walletClient.account.address}:${nextWriteId++}`;\n            const { args, options } = <\n              {\n                args: unknown[];\n                options: UnionOmit<WriteContractParameters, \"address\" | \"abi\" | \"functionName\" | \"args\">;\n              }\n            >getFunctionParameters(parameters as any);\n\n            const request = {\n              address,\n              abi,\n              functionName,\n              args,\n              ...options,\n            };\n\n            const result = write(request);\n\n            onWrite?.({ id, request, result });\n\n            return result;\n          };\n        },\n      }\n    );\n  }\n\n  return contract as unknown as GetContractReturnType<TAbi, TPublicClient, TWalletClient, TAddress>;\n}\n","import {\n  BaseError,\n  BlockTag,\n  Hex,\n  NonceTooHighError,\n  NonceTooLowError,\n  PublicClient,\n  TransactionExecutionError,\n} from \"viem\";\nimport { debug as parentDebug } from \"./debug\";\n\nconst debug = parentDebug.extend(\"createNonceManager\");\n\ntype CreateNonceManagerOptions = {\n  publicClient: PublicClient;\n  address: Hex;\n  blockTag?: BlockTag;\n};\n\ntype CreateNonceManagerResult = {\n  hasNonce: () => boolean;\n  nextNonce: () => number;\n  resetNonce: () => Promise<void>;\n  shouldResetNonce: (error: unknown) => boolean;\n};\n\nexport function createNonceManager({\n  publicClient,\n  address,\n  blockTag,\n}: CreateNonceManagerOptions): CreateNonceManagerResult {\n  const nonceRef = { current: -1 };\n  const channel =\n    typeof BroadcastChannel !== \"undefined\"\n      ? // TODO: fetch chain ID or require it via types?\n        new BroadcastChannel(`mud:createNonceManager:${publicClient.chain?.id}:${address}`)\n      : null;\n\n  if (channel) {\n    channel.addEventListener(\"message\", (event) => {\n      const nonce = JSON.parse(event.data);\n      debug(\"got nonce from broadcast channel\", nonce);\n      nonceRef.current = nonce;\n    });\n  }\n\n  function hasNonce(): boolean {\n    return nonceRef.current >= 0;\n  }\n\n  function nextNonce(): number {\n    if (!hasNonce()) throw new Error(\"call resetNonce before using nextNonce\");\n    const nonce = nonceRef.current++;\n    channel?.postMessage(JSON.stringify(nonceRef.current));\n    return nonce;\n  }\n\n  async function resetNonce(): Promise<void> {\n    const nonce = await publicClient.getTransactionCount({ address, blockTag });\n    nonceRef.current = nonce;\n    channel?.postMessage(JSON.stringify(nonceRef.current));\n    debug(\"reset nonce to\", nonceRef.current);\n  }\n\n  function shouldResetNonce(error: unknown): boolean {\n    return (\n      error instanceof BaseError &&\n      error.walk((e) => e instanceof NonceTooLowError || e instanceof NonceTooHighError) != null\n    );\n  }\n\n  return {\n    hasNonce,\n    nextNonce,\n    resetNonce,\n    shouldResetNonce,\n  };\n}\n","import createDebug from \"debug\";\n\nexport const debug = createDebug(\"mud:common\");\n","import { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { isHex, Hex } from \"viem\";\n\nfunction assertPrivateKey(privateKey: string, cacheKey: string): asserts privateKey is Hex {\n  if (!isHex(privateKey)) {\n    console.error(\"Private key found in cache is not valid hex\", { privateKey, cacheKey });\n    throw new Error(`Private key found in cache (${cacheKey}) is not valid hex`);\n  }\n  // ensure we can extract address from private key\n  // this should throw on bad private keys\n  privateKeyToAccount(privateKey);\n}\n\nexport function getBurnerPrivateKey(cacheKey = \"mud:burnerWallet\"): Hex {\n  const cachedPrivateKey = localStorage.getItem(cacheKey);\n\n  if (cachedPrivateKey != null) {\n    assertPrivateKey(cachedPrivateKey, cacheKey);\n    return cachedPrivateKey;\n  }\n\n  const privateKey = generatePrivateKey();\n  console.log(\"New burner wallet created:\", privateKeyToAccount(privateKey));\n  localStorage.setItem(cacheKey, privateKey);\n  return privateKey;\n}\n","import { Hex, hexToString, sliceHex } from \"viem\";\nimport { ResourceId } from \"./common\";\nimport { ResourceType, resourceTypes } from \"./resourceTypes\";\nimport { resourceTypeIds } from \"./resourceIdToHex\";\nimport { ReverseMap } from \"./type-utils/common\";\n\nconst resourceTypeIdToType = Object.fromEntries(\n  Object.entries(resourceTypeIds).map(([key, value]) => [value, key])\n) as ReverseMap<typeof resourceTypeIds>;\n\nfunction getResourceType(resourceTypeId: string): ResourceType | undefined {\n  // TODO: replace Partial with `noUncheckedIndexedAccess`\n  const type = (resourceTypeIdToType as Partial<Record<string, ResourceType>>)[resourceTypeId];\n  if (resourceTypes.includes(type as ResourceType)) {\n    return type;\n  }\n}\n\nexport function hexToResourceId(hex: Hex): ResourceId {\n  const resourceTypeId = hexToString(sliceHex(hex, 0, 2)).replace(/\\0+$/, \"\");\n  const type = getResourceType(resourceTypeId);\n  const namespace = hexToString(sliceHex(hex, 2, 16)).replace(/\\0+$/, \"\");\n  const name = hexToString(sliceHex(hex, 16, 32)).replace(/\\0+$/, \"\");\n\n  if (!type) {\n    throw new Error(`Unknown resource type: ${resourceTypeId}`);\n  }\n\n  return { type, namespace, name };\n}\n","export const resourceTypes = [\"table\", \"offchainTable\", \"namespace\", \"module\", \"system\"] as const;\n\nexport type ResourceType = (typeof resourceTypes)[number];\n","import { Hex, stringToHex, concatHex } from \"viem\";\nimport { ResourceId } from \"./common\";\nimport { ResourceType } from \"./resourceTypes\";\n\n/** @internal */\nexport const resourceTypeIds = {\n  // keep these in sync with storeResourceTypes.sol\n  table: \"tb\",\n  offchainTable: \"ot\",\n  // keep these in sync with worldResourceTypes.sol\n  namespace: \"ns\",\n  module: \"md\",\n  system: \"sy\",\n} as const satisfies Record<ResourceType, string>;\n\nexport function resourceIdToHex(resourceId: ResourceId): Hex {\n  const typeId = resourceTypeIds[resourceId.type];\n  return concatHex([\n    stringToHex(typeId, { size: 2 }),\n    stringToHex(resourceId.namespace.slice(0, 14), { size: 14 }),\n    stringToHex(resourceId.name.slice(0, 16), { size: 16 }),\n  ]);\n}\n","import { Hex } from \"viem\";\n\n/**\n * Get the hex value at start/end positions. This will always return a valid hex string.\n *\n * If `start` is out of range, this returns `\"0x\"`.\n *\n * If `end` is specified and out of range, the result is right zero-padded to the desired length (`end - start`).\n */\nexport function readHex(data: Hex, start: number, end?: number): Hex {\n  return `0x${data\n    .replace(/^0x/, \"\")\n    .slice(start * 2, end != null ? end * 2 : undefined)\n    .padEnd(((end ?? start) - start) * 2, \"0\")}`;\n}\n","import { Hex, concatHex } from \"viem\";\nimport { readHex } from \"./readHex\";\n\nexport function spliceHex(data: Hex, start: number, deleteCount = 0, newData: Hex = \"0x\"): Hex {\n  return concatHex([readHex(data, 0, start), newData, readHex(data, start + deleteCount)]);\n}\n","import { Hex, Transport, keccak256 } from \"viem\";\nimport { debug as parentDebug } from \"./debug\";\n\nconst debug = parentDebug.extend(\"transportObserver\");\n\nexport function transportObserver<TTransport extends Transport>(transport: TTransport): TTransport {\n  return ((opts) => {\n    const result = transport(opts);\n    const request: typeof result.request = async (req) => {\n      if (req.method === \"eth_sendRawTransaction\" && req.params instanceof Array) {\n        const txs = req.params.map((data: Hex) => keccak256(data));\n        debug(\"saw txs\", txs);\n        // TODO: pass these tx hashes into dev tools\n      }\n      // TODO: add support for `eth_sendTransaction`\n      return result.request(req);\n    };\n    return {\n      ...result,\n      request,\n    };\n  }) as TTransport;\n}\n"],"mappings":"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","names":["privateKeyToAccount","createBurnerAccount","privateKey","getContract","pRetry","BaseError","NonceTooHighError","NonceTooLowError","createDebug","debug","debug","createNonceManager","publicClient","address","blockTag","nonceRef","channel","event","nonce","hasNonce","nextNonce","resetNonce","shouldResetNonce","error","BaseError","e","NonceTooLowError","NonceTooHighError","debug","getFunctionParameters","values","hasArgs","args","options","createContract","abi","address","publicClient","walletClient","onWrite","contract","getContract","nextWriteId","nonceManager","createNonceManager","_","functionName","prepareWrite","request","write","preparedWrite","pRetry","nonce","error","parameters","id","result","generatePrivateKey","privateKeyToAccount","isHex","assertPrivateKey","privateKey","cacheKey","getBurnerPrivateKey","cachedPrivateKey","hexToString","sliceHex","resourceTypes","stringToHex","concatHex","resourceTypeIds","resourceIdToHex","resourceId","typeId","resourceTypeIdToType","resourceTypeIds","key","value","getResourceType","resourceTypeId","type","resourceTypes","hexToResourceId","hex","hexToString","sliceHex","namespace","name","readHex","data","start","end","concatHex","spliceHex","data","start","deleteCount","newData","concatHex","readHex","keccak256","debug","transportObserver","transport","opts","result","req","txs","data","keccak256"]}