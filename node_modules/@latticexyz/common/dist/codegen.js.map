{"version":3,"sources":["../src/codegen/render-solidity/common.ts","../src/codegen/utils/contractToInterface.ts","../src/codegen/utils/extractUserTypes.ts","../src/codegen/utils/format.ts","../src/codegen/utils/formatAndWrite.ts","../src/codegen/utils/loadUserTypesFile.ts","../src/codegen/utils/posixPath.ts","../src/codegen/render-solidity/renderEnums.ts","../src/codegen/render-solidity/renderTypeHelpers.ts","../src/codegen/render-typescript/schemaTypesToRecsTypeStrings.ts"],"sourcesContent":["import path from \"path\";\nimport {\n  AbsoluteImportDatum,\n  RelativeImportDatum,\n  ImportDatum,\n  StaticResourceData,\n  RenderKeyTuple,\n  RenderType,\n} from \"./types\";\nimport { posixPath } from \"../utils\";\n\nexport const renderedSolidityHeader = `// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */`;\n\n/**\n * Renders a list of lines\n */\nexport function renderList<T>(list: T[], renderItem: (item: T, index: number) => string): string {\n  return internalRenderList(\"\", list, renderItem);\n}\n\n/**\n * Renders a comma-separated list of arguments for solidity functions, ignoring empty and undefined ones\n */\nexport function renderArguments(args: (string | undefined)[]): string {\n  const filteredArgs = args.filter((arg) => arg !== undefined && arg !== \"\") as string[];\n  return internalRenderList(\",\", filteredArgs, (arg) => arg);\n}\n\nexport function renderCommonData({\n  staticResourceData,\n  keyTuple,\n}: {\n  staticResourceData?: StaticResourceData;\n  keyTuple: RenderKeyTuple[];\n}): {\n  _tableId: string;\n  _typedTableId: string;\n  _keyArgs: string;\n  _typedKeyArgs: string;\n  _keyTupleDefinition: string;\n} {\n  // static resource means static tableId as well, and no tableId arguments\n  const _tableId = staticResourceData ? \"\" : \"_tableId\";\n  const _typedTableId = staticResourceData ? \"\" : \"ResourceId _tableId\";\n\n  const _keyArgs = renderArguments(keyTuple.map(({ name }) => name));\n  const _typedKeyArgs = renderArguments(keyTuple.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));\n\n  const _keyTupleDefinition = `\n    bytes32[] memory _keyTuple = new bytes32[](${keyTuple.length});\n    ${renderList(keyTuple, (key, index) => `_keyTuple[${index}] = ${renderValueTypeToBytes32(key.name, key)};`)}\n  `;\n\n  return {\n    _tableId,\n    _typedTableId,\n    _keyArgs,\n    _typedKeyArgs,\n    _keyTupleDefinition,\n  };\n}\n\n/** For 2 paths which are relative to a common root, create a relative import path from one to another */\nexport function solidityRelativeImportPath(fromPath: string, usedInPath: string): string {\n  // 1st \"./\" must be added because path strips it,\n  // but solidity expects it unless there's \"../\" (\"./../\" is fine).\n  // 2nd and 3rd \"./\" forcefully avoid absolute paths (everything is relative to `src`).\n  return posixPath(\"./\" + path.relative(\"./\" + usedInPath, \"./\" + fromPath));\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderImports(imports: ImportDatum[]): string {\n  return renderAbsoluteImports(\n    imports.map((importDatum) => {\n      if (\"path\" in importDatum) {\n        return importDatum;\n      } else {\n        return {\n          symbol: importDatum.symbol,\n          path: solidityRelativeImportPath(importDatum.fromPath, importDatum.usedInPath),\n        };\n      }\n    })\n  );\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderRelativeImports(imports: RelativeImportDatum[]): string {\n  return renderAbsoluteImports(\n    imports.map(({ symbol, fromPath, usedInPath }) => ({\n      symbol,\n      path: solidityRelativeImportPath(fromPath, usedInPath),\n    }))\n  );\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderAbsoluteImports(imports: AbsoluteImportDatum[]): string {\n  // Aggregate symbols by import path, also deduplicating them\n  const aggregatedImports = new Map<string, Set<string>>();\n  for (const { symbol, path } of imports) {\n    if (!aggregatedImports.has(path)) {\n      aggregatedImports.set(path, new Set());\n    }\n    aggregatedImports.get(path)?.add(symbol);\n  }\n  // Render imports\n  const renderedImports = [];\n  for (const [path, symbols] of aggregatedImports) {\n    const renderedSymbols = [...symbols].join(\", \");\n    renderedImports.push(`import { ${renderedSymbols} } from \"${posixPath(path)}\";`);\n  }\n  return renderedImports.join(\"\\n\");\n}\n\nexport function renderWithStore(\n  storeArgument: boolean,\n  callback: (\n    _typedStore: string | undefined,\n    _store: string,\n    _commentSuffix: string,\n    _untypedStore: string | undefined,\n    _methodPrefix: string,\n    _internal?: boolean\n  ) => string\n): string {\n  let result = \"\";\n  result += callback(undefined, \"StoreSwitch\", \"\", undefined, \"\");\n  result += callback(undefined, \"StoreCore\", \"\", undefined, \"_\", true);\n\n  if (storeArgument) {\n    result += \"\\n\" + callback(\"IStore _store\", \"_store\", \" (using the specified store)\", \"_store\", \"\");\n  }\n\n  return result;\n}\n\nexport function renderWithFieldSuffix(\n  withSuffixlessFieldMethods: boolean,\n  fieldName: string,\n  callback: (_methodNameSuffix: string) => string\n): string {\n  const methodNameSuffix = `${fieldName[0].toUpperCase()}${fieldName.slice(1)}`;\n  let result = \"\";\n  result += callback(methodNameSuffix);\n\n  if (withSuffixlessFieldMethods) {\n    result += \"\\n\" + callback(\"\");\n  }\n\n  return result;\n}\n\nexport function renderTableId({ namespace, name, offchainOnly, tableIdName }: StaticResourceData): {\n  hardcodedTableId: string;\n  tableIdDefinition: string;\n} {\n  const hardcodedTableId = `\n    ResourceId.wrap(\n      bytes32(\n        abi.encodePacked(\n          ${offchainOnly ? \"RESOURCE_OFFCHAIN_TABLE\" : \"RESOURCE_TABLE\"},\n          bytes14(\"${namespace}\"),\n          bytes16(\"${name}\")\n        )\n      )\n    )\n  `;\n\n  const tableIdDefinition = `\n    ResourceId constant _tableId = ${hardcodedTableId};\n    ResourceId constant ${tableIdName} = _tableId;\n  `;\n  return {\n    hardcodedTableId,\n    tableIdDefinition,\n  };\n}\n\nexport function renderValueTypeToBytes32(name: string, { typeUnwrap, internalTypeId }: RenderType): string {\n  const innerText = typeUnwrap.length ? `${typeUnwrap}(${name})` : name;\n\n  if (internalTypeId === \"bytes32\") {\n    return innerText;\n  } else if (internalTypeId.match(/^bytes\\d{1,2}$/)) {\n    return `bytes32(${innerText})`;\n  } else if (internalTypeId.match(/^uint\\d{1,3}$/)) {\n    return `bytes32(uint256(${innerText}))`;\n  } else if (internalTypeId.match(/^int\\d{1,3}$/)) {\n    return `bytes32(uint256(int256(${innerText})))`;\n  } else if (internalTypeId === \"address\") {\n    return `bytes32(uint256(uint160(${innerText})))`;\n  } else if (internalTypeId === \"bool\") {\n    return `_boolToBytes32(${innerText})`;\n  } else {\n    throw new Error(`Unknown value type id ${internalTypeId}`);\n  }\n}\n\nexport function isLeftAligned(field: Pick<RenderType, \"internalTypeId\">): boolean {\n  return field.internalTypeId.match(/^bytes\\d{1,2}$/) !== null;\n}\n\nexport function getLeftPaddingBits(field: Pick<RenderType, \"internalTypeId\" | \"staticByteLength\">): number {\n  if (isLeftAligned(field)) {\n    return 0;\n  } else {\n    return 256 - field.staticByteLength * 8;\n  }\n}\n\nfunction internalRenderList<T>(\n  lineTerminator: string,\n  list: T[],\n  renderItem: (item: T, index: number) => string\n): string {\n  return list\n    .map((item, index) => renderItem(item, index) + (index === list.length - 1 ? \"\" : lineTerminator))\n    .join(\"\\n\");\n}\n","import { parse, visit } from \"@solidity-parser/parser\";\nimport type { SourceUnit, TypeName, VariableDeclaration } from \"@solidity-parser/parser/dist/src/ast-types\";\nimport { MUDError } from \"../../errors\";\n\nexport interface ContractInterfaceFunction {\n  name: string;\n  parameters: string[];\n  stateMutability: string;\n  returnParameters: string[];\n}\n\nexport interface ContractInterfaceError {\n  name: string;\n  parameters: string[];\n}\n\ninterface SymbolImport {\n  symbol: string;\n  path: string;\n}\n\n/**\n * Parse the contract data to get the functions necessary to generate an interface,\n * and symbols to import from the original contract.\n * @param data contents of a file with the solidity contract\n * @param contractName name of the contract\n * @returns interface data\n */\nexport function contractToInterface(\n  data: string,\n  contractName: string\n): {\n  functions: ContractInterfaceFunction[];\n  errors: ContractInterfaceError[];\n  symbolImports: SymbolImport[];\n} {\n  const ast = parse(data);\n\n  let withContract = false;\n  let symbolImports: SymbolImport[] = [];\n  const functions: ContractInterfaceFunction[] = [];\n  const errors: ContractInterfaceError[] = [];\n\n  visit(ast, {\n    ContractDefinition({ name }) {\n      if (name === contractName) {\n        withContract = true;\n      }\n    },\n    FunctionDefinition(\n      { name, visibility, parameters, stateMutability, returnParameters, isConstructor, isFallback, isReceiveEther },\n      parent\n    ) {\n      if (parent !== undefined && parent.type === \"ContractDefinition\" && parent.name === contractName) {\n        try {\n          // skip constructor and fallbacks\n          if (isConstructor || isFallback || isReceiveEther) return;\n          // forbid default visibility (this check might be unnecessary, modern solidity already disallows this)\n          if (visibility === \"default\") throw new MUDError(`Visibility is not specified`);\n\n          if (visibility === \"external\" || visibility === \"public\") {\n            functions.push({\n              name: name === null ? \"\" : name,\n              parameters: parameters.map(parseParameter),\n              stateMutability: stateMutability || \"\",\n              returnParameters: returnParameters === null ? [] : returnParameters.map(parseParameter),\n            });\n\n            for (const { typeName } of parameters.concat(returnParameters ?? [])) {\n              const symbols = typeNameToSymbols(typeName);\n              symbolImports = symbolImports.concat(symbolsToImports(ast, symbols));\n            }\n          }\n        } catch (error: unknown) {\n          if (error instanceof MUDError) {\n            error.message = `Function \"${name}\" in contract \"${contractName}\": ${error.message}`;\n          }\n          throw error;\n        }\n      }\n    },\n    CustomErrorDefinition({ name, parameters }) {\n      errors.push({\n        name: name === null ? \"\" : name,\n        parameters: parameters.map(parseParameter),\n      });\n\n      for (const parameter of parameters) {\n        const symbols = typeNameToSymbols(parameter.typeName);\n        symbolImports = symbolImports.concat(symbolsToImports(ast, symbols));\n      }\n    },\n  });\n\n  if (!withContract) {\n    throw new MUDError(`Contract not found: ${contractName}`);\n  }\n\n  return {\n    functions,\n    errors,\n    symbolImports,\n  };\n}\n\nfunction parseParameter({ name, typeName, storageLocation }: VariableDeclaration): string {\n  let typedNameWithLocation = \"\";\n\n  const { name: flattenedTypeName, stateMutability } = flattenTypeName(typeName);\n  // type name (e.g. uint256)\n  typedNameWithLocation += flattenedTypeName;\n  // optional mutability (e.g. address payable)\n  if (stateMutability !== null) {\n    typedNameWithLocation += ` ${stateMutability}`;\n  }\n  // location, when relevant (e.g. string memory)\n  if (storageLocation !== null) {\n    typedNameWithLocation += ` ${storageLocation}`;\n  }\n  // optional variable name\n  if (name !== null) {\n    typedNameWithLocation += ` ${name}`;\n  }\n\n  return typedNameWithLocation;\n}\n\nfunction flattenTypeName(typeName: TypeName | null): { name: string; stateMutability: string | null } {\n  if (typeName === null) {\n    return {\n      name: \"\",\n      stateMutability: null,\n    };\n  }\n  if (typeName.type === \"ElementaryTypeName\") {\n    return {\n      name: typeName.name,\n      stateMutability: typeName.stateMutability,\n    };\n  } else if (typeName.type === \"UserDefinedTypeName\") {\n    return {\n      name: typeName.namePath,\n      stateMutability: null,\n    };\n  } else if (typeName.type === \"ArrayTypeName\") {\n    let length = \"\";\n    if (typeName.length?.type === \"NumberLiteral\") {\n      length = typeName.length.number;\n    } else if (typeName.length?.type === \"Identifier\") {\n      length = typeName.length.name;\n    }\n\n    const { name, stateMutability } = flattenTypeName(typeName.baseTypeName);\n    return {\n      name: `${name}[${length}]`,\n      stateMutability,\n    };\n  } else {\n    // TODO function types are unsupported but could be useful\n    throw new MUDError(`Invalid typeName.type ${typeName.type}`);\n  }\n}\n\n// Get symbols that need to be imported for given typeName\nfunction typeNameToSymbols(typeName: TypeName | null): string[] {\n  if (typeName?.type === \"UserDefinedTypeName\") {\n    // split is needed to get a library, if types are internal to it\n    const symbol = typeName.namePath.split(\".\")[0];\n    return [symbol];\n  } else if (typeName?.type === \"ArrayTypeName\") {\n    const symbols = typeNameToSymbols(typeName.baseTypeName);\n    // array types can also use symbols (constants) for length\n    if (typeName.length?.type === \"Identifier\") {\n      const innerTypeName = typeName.length.name;\n      symbols.push(innerTypeName.split(\".\")[0]);\n    }\n    return symbols;\n  } else {\n    return [];\n  }\n}\n\n// Get imports for given symbols.\n// To avoid circular dependencies of interfaces on their implementations,\n// symbols used for args/returns must always be imported from an auxiliary file.\n// To avoid parsing the entire project to build dependencies,\n// symbols must be imported with an explicit `import { symbol } from ...`\nfunction symbolsToImports(ast: SourceUnit, symbols: string[]): SymbolImport[] {\n  const imports: SymbolImport[] = [];\n\n  for (const symbol of symbols) {\n    let symbolImport: SymbolImport | undefined;\n\n    visit(ast, {\n      ImportDirective({ path, symbolAliases }) {\n        if (symbolAliases) {\n          for (const symbolAndAlias of symbolAliases) {\n            // either check the alias, or the original symbol if there's no alias\n            const symbolAlias = symbolAndAlias[1] || symbolAndAlias[0];\n            if (symbol === symbolAlias) {\n              symbolImport = {\n                // always use the original symbol for interface imports\n                symbol: symbolAndAlias[0],\n                path,\n              };\n              return;\n            }\n          }\n        }\n      },\n    });\n\n    if (symbolImport) {\n      imports.push(symbolImport);\n    } else {\n      throw new MUDError(`Symbol \"${symbol}\" has no explicit import`);\n    }\n  }\n\n  return imports;\n}\n","import { parse, visit } from \"@solidity-parser/parser\";\nimport { MUDError } from \"../../errors\";\n\nexport interface SolidityUserDefinedType {\n  typeId: string;\n  internalTypeId: string;\n  importSymbol: string;\n  fromPath: string;\n  isRelativePath: boolean;\n}\n\n/**\n * Parse the solidity data to extract user-defined type information.\n * @param data contents of a solidity file with the user types declarations\n * @param userTypeNames names of the user types to extract\n */\nexport function extractUserTypes(\n  data: string,\n  userTypeNames: string[],\n  fromPath: string\n): Record<string, SolidityUserDefinedType> {\n  const ast = parse(data);\n\n  const isRelativePath = fromPath.at(0) === \".\";\n  const userDefinedTypes: Record<string, SolidityUserDefinedType> = {};\n\n  visit(ast, {\n    TypeDefinition({ name, definition }, parent) {\n      if (definition.name.includes(\"fixed\")) throw new MUDError(`Fixed point numbers are not supported by MUD`);\n      if (userTypeNames.includes(name)) {\n        if (name in userDefinedTypes) {\n          throw new MUDError(`File has multiple user types with the same name: ${name}`);\n        }\n\n        if (parent?.type === \"ContractDefinition\") {\n          userDefinedTypes[name] = {\n            typeId: `${parent.name}.${name}`,\n            internalTypeId: definition.name,\n            importSymbol: parent.name,\n            fromPath,\n            isRelativePath,\n          };\n        } else {\n          userDefinedTypes[name] = {\n            typeId: name,\n            internalTypeId: definition.name,\n            importSymbol: name,\n            fromPath,\n            isRelativePath,\n          };\n        }\n      }\n    },\n  });\n\n  return userDefinedTypes;\n}\n","import chalk from \"chalk\";\nimport prettier from \"prettier\";\nimport prettierPluginSolidity from \"prettier-plugin-solidity\";\n\nexport async function formatSolidity(content: string, prettierConfigPath?: string): Promise<string> {\n  let config;\n  if (prettierConfigPath) {\n    config = await prettier.resolveConfig(prettierConfigPath);\n  }\n  try {\n    return prettier.format(content, {\n      plugins: [prettierPluginSolidity],\n      parser: \"solidity-parse\",\n\n      printWidth: 120,\n      semi: true,\n      tabWidth: 2,\n      useTabs: false,\n      bracketSpacing: true,\n\n      ...config,\n    });\n  } catch (error) {\n    let message;\n    if (error instanceof Error) {\n      message = error.message;\n    } else {\n      message = error;\n    }\n    console.log(chalk.yellow(`Error during output formatting: ${message}`));\n    return content;\n  }\n}\n\nexport async function formatTypescript(content: string): Promise<string> {\n  return prettier.format(content, {\n    parser: \"typescript\",\n  });\n}\n","import { mkdirSync, writeFileSync } from \"fs\";\nimport { dirname } from \"path\";\nimport { formatSolidity, formatTypescript } from \"./format\";\n\nexport async function formatAndWriteSolidity(output: string, fullOutputPath: string, logPrefix: string): Promise<void> {\n  const formattedOutput = await formatSolidity(output);\n\n  mkdirSync(dirname(fullOutputPath), { recursive: true });\n\n  writeFileSync(fullOutputPath, formattedOutput);\n  console.log(`${logPrefix}: ${fullOutputPath}`);\n}\n\nexport async function formatAndWriteTypescript(\n  output: string,\n  fullOutputPath: string,\n  logPrefix: string\n): Promise<void> {\n  const formattedOutput = await formatTypescript(output);\n\n  mkdirSync(dirname(fullOutputPath), { recursive: true });\n\n  writeFileSync(fullOutputPath, formattedOutput);\n  console.log(`${logPrefix}: ${fullOutputPath}`);\n}\n","import { readFileSync } from \"fs\";\nimport path from \"path\";\nimport { SolidityUserDefinedType, extractUserTypes } from \"./extractUserTypes\";\nimport { MUDError } from \"../../errors\";\n\nexport type UserType = {\n  filePath: string;\n  internalType: string;\n};\n\nexport function loadAndExtractUserTypes(\n  userTypes: Record<string, UserType>,\n  outputBaseDirectory: string,\n  remappings: [string, string][]\n): Record<string, SolidityUserDefinedType> {\n  const userTypesPerFile: Record<string, string[]> = {};\n  for (const [userTypeName, { filePath: unresolvedFilePath }] of Object.entries(userTypes)) {\n    if (!(unresolvedFilePath in userTypesPerFile)) {\n      userTypesPerFile[unresolvedFilePath] = [];\n    }\n    userTypesPerFile[unresolvedFilePath].push(userTypeName);\n  }\n  let extractedUserTypes: Record<string, SolidityUserDefinedType> = {};\n  for (const [unresolvedFilePath, userTypeNames] of Object.entries(userTypesPerFile)) {\n    const { filePath, data } = loadUserTypesFile(outputBaseDirectory, unresolvedFilePath, remappings);\n    const userTypesInFile = extractUserTypes(data, userTypeNames, filePath);\n\n    // Verify the actual user type matches the internalType specified in the config\n    for (const [userTypeName, userType] of Object.entries(userTypesInFile)) {\n      if (userType.internalTypeId !== userTypes[userTypeName].internalType) {\n        throw new MUDError(\n          `User type \"${userTypeName}\" has internal type \"${userType.internalTypeId}\" but config specifies \"${userTypes[userTypeName].internalType}\"`\n        );\n      }\n    }\n\n    extractedUserTypes = Object.assign(extractedUserTypes, userTypesInFile);\n  }\n  return extractedUserTypes;\n}\n\nfunction loadUserTypesFile(\n  outputBaseDirectory: string,\n  unresolvedFilePath: string,\n  remappings: [string, string][]\n): {\n  filePath: string;\n  data: string;\n} {\n  if (unresolvedFilePath.at(0) === \".\") {\n    const relativePath = path.relative(outputBaseDirectory, unresolvedFilePath);\n    return {\n      filePath: \"./\" + relativePath, // solc doesn't like relative paths without \"./\"\n      data: readFileSync(unresolvedFilePath, \"utf8\"),\n    };\n  } else {\n    // apply remappings to read the file via node\n    let remappedFilePath = unresolvedFilePath;\n    for (const [from, to] of remappings) {\n      if (remappedFilePath.includes(from)) {\n        remappedFilePath = remappedFilePath.replace(from, to);\n        break;\n      }\n    }\n\n    return {\n      filePath: unresolvedFilePath,\n      data: readFileSync(remappedFilePath, \"utf8\"),\n    };\n  }\n}\n","/**\n * Explicitly normalize a given path to a posix path (using `/` as separator).\n * This should be used for generating Solidity files that will be consumed by solc,\n * because solc expects `/` as path separator, but path.join produces `\\` if the user is on windows.\n */\nexport function posixPath(path: string): string {\n  return path.replace(/\\\\/g, \"/\");\n}\n","import { renderArguments, renderList, renderedSolidityHeader } from \"./common\";\nimport { RenderEnum } from \"./types\";\n\nexport function renderEnums(enums: RenderEnum[]): string {\n  let result = renderedSolidityHeader;\n\n  result += renderList(\n    enums,\n    ({ name, memberNames }) => `\n    enum ${name} {\n      ${renderArguments(memberNames)}\n    }\n  `\n  );\n\n  return result;\n}\n","import { RenderField, RenderKeyTuple, RenderType } from \"./types\";\n\nexport function renderTypeHelpers(options: { fields: RenderField[]; keyTuple: RenderKeyTuple[] }): string {\n  const { fields, keyTuple } = options;\n\n  let result = \"\";\n\n  for (const wrappingHelper of getWrappingHelpers([...fields, ...keyTuple])) {\n    result += wrappingHelper;\n  }\n\n  // bool is special - it's the only primitive value type that can't be typecasted to/from\n  if (fields.some(({ internalTypeId }) => internalTypeId.match(\"bool\"))) {\n    result += `\n    function _toBool(uint8 value) pure returns (bool result) {\n      assembly {\n        result := value\n      }\n    }\n    `;\n  }\n  if (keyTuple.some(({ internalTypeId }) => internalTypeId.match(\"bool\"))) {\n    result += `\n    function _boolToBytes32(bool value) pure returns (bytes32 result) {\n      assembly {\n        result := value\n      }\n    }\n    `;\n  }\n\n  return result;\n}\n\nfunction getWrappingHelpers(array: RenderType[]): string[] {\n  const wrappers = new Map<string, string>();\n  const unwrappers = new Map<string, string>();\n  for (const { typeWrappingData, typeWrap, typeUnwrap, internalTypeId } of array) {\n    if (!typeWrappingData) continue;\n    const { kind } = typeWrappingData;\n\n    if (kind === \"staticArray\") {\n      const { elementType, staticLength } = typeWrappingData;\n      wrappers.set(typeWrap, renderWrapperStaticArray(typeWrap, elementType, staticLength, internalTypeId));\n      unwrappers.set(typeUnwrap, renderUnwrapperStaticArray(typeUnwrap, elementType, staticLength, internalTypeId));\n    }\n  }\n\n  return [...wrappers.values(), ...unwrappers.values()];\n}\n\nfunction renderWrapperStaticArray(\n  functionName: string,\n  elementType: string,\n  staticLength: number,\n  internalTypeId: string\n): string {\n  // WARNING: ensure this still works if changing major solidity versions!\n  // (the memory layout for static arrays may change)\n  return `\n    function ${functionName}(\n      ${internalTypeId} memory _value\n    ) pure returns (\n      ${elementType}[${staticLength}] memory _result\n    ) {\n      if (_value.length < ${staticLength}) {\n        // return an uninitialized array if the length is smaller than the fixed length to avoid memory corruption\n        return _result;\n      } else {\n        // in memory static arrays are just dynamic arrays without the length byte\n        // (without the length check this could lead to memory corruption)\n        assembly {\n          _result := add(_value, 0x20)\n        }\n      }\n    }\n  `;\n}\n\nfunction renderUnwrapperStaticArray(\n  functionName: string,\n  elementType: string,\n  staticLength: number,\n  internalTypeId: string\n): string {\n  // byte length for memory copying (more efficient than a loop)\n  const byteLength = staticLength * 32;\n  // TODO to optimize memory usage consider generalizing TightEncoder to a render-time utility\n  return `\n    function ${functionName}(\n      ${elementType}[${staticLength}] memory _value\n    ) pure returns (\n      ${internalTypeId} memory _result\n    ) {\n      _result = new ${internalTypeId}(${staticLength});\n      uint256 fromPointer;\n      uint256 toPointer;\n      assembly {\n        fromPointer := _value\n        toPointer := add(_result, 0x20)\n      }\n      Memory.copy(fromPointer, toPointer, ${byteLength});\n    }\n  `;\n}\n","import { SchemaType } from \"@latticexyz/schema-type/deprecated\";\n\nexport const schemaTypesToRecsTypeStrings: Record<SchemaType, string> = {\n  [SchemaType.UINT8]: \"RecsType.Number\",\n  [SchemaType.UINT16]: \"RecsType.Number\",\n  [SchemaType.UINT24]: \"RecsType.Number\",\n  [SchemaType.UINT32]: \"RecsType.Number\",\n  [SchemaType.UINT40]: \"RecsType.Number\",\n  [SchemaType.UINT48]: \"RecsType.Number\",\n  [SchemaType.UINT56]: \"RecsType.BigInt\",\n  [SchemaType.UINT64]: \"RecsType.BigInt\",\n  [SchemaType.UINT72]: \"RecsType.BigInt\",\n  [SchemaType.UINT80]: \"RecsType.BigInt\",\n  [SchemaType.UINT88]: \"RecsType.BigInt\",\n  [SchemaType.UINT96]: \"RecsType.BigInt\",\n  [SchemaType.UINT104]: \"RecsType.BigInt\",\n  [SchemaType.UINT112]: \"RecsType.BigInt\",\n  [SchemaType.UINT120]: \"RecsType.BigInt\",\n  [SchemaType.UINT128]: \"RecsType.BigInt\",\n  [SchemaType.UINT136]: \"RecsType.BigInt\",\n  [SchemaType.UINT144]: \"RecsType.BigInt\",\n  [SchemaType.UINT152]: \"RecsType.BigInt\",\n  [SchemaType.UINT160]: \"RecsType.BigInt\",\n  [SchemaType.UINT168]: \"RecsType.BigInt\",\n  [SchemaType.UINT176]: \"RecsType.BigInt\",\n  [SchemaType.UINT184]: \"RecsType.BigInt\",\n  [SchemaType.UINT192]: \"RecsType.BigInt\",\n  [SchemaType.UINT200]: \"RecsType.BigInt\",\n  [SchemaType.UINT208]: \"RecsType.BigInt\",\n  [SchemaType.UINT216]: \"RecsType.BigInt\",\n  [SchemaType.UINT224]: \"RecsType.BigInt\",\n  [SchemaType.UINT232]: \"RecsType.BigInt\",\n  [SchemaType.UINT240]: \"RecsType.BigInt\",\n  [SchemaType.UINT248]: \"RecsType.BigInt\",\n  [SchemaType.UINT256]: \"RecsType.BigInt\",\n  [SchemaType.INT8]: \"RecsType.Number\",\n  [SchemaType.INT16]: \"RecsType.Number\",\n  [SchemaType.INT24]: \"RecsType.Number\",\n  [SchemaType.INT32]: \"RecsType.Number\",\n  [SchemaType.INT40]: \"RecsType.Number\",\n  [SchemaType.INT48]: \"RecsType.Number\",\n  [SchemaType.INT56]: \"RecsType.BigInt\",\n  [SchemaType.INT64]: \"RecsType.BigInt\",\n  [SchemaType.INT72]: \"RecsType.BigInt\",\n  [SchemaType.INT80]: \"RecsType.BigInt\",\n  [SchemaType.INT88]: \"RecsType.BigInt\",\n  [SchemaType.INT96]: \"RecsType.BigInt\",\n  [SchemaType.INT104]: \"RecsType.BigInt\",\n  [SchemaType.INT112]: \"RecsType.BigInt\",\n  [SchemaType.INT120]: \"RecsType.BigInt\",\n  [SchemaType.INT128]: \"RecsType.BigInt\",\n  [SchemaType.INT136]: \"RecsType.BigInt\",\n  [SchemaType.INT144]: \"RecsType.BigInt\",\n  [SchemaType.INT152]: \"RecsType.BigInt\",\n  [SchemaType.INT160]: \"RecsType.BigInt\",\n  [SchemaType.INT168]: \"RecsType.BigInt\",\n  [SchemaType.INT176]: \"RecsType.BigInt\",\n  [SchemaType.INT184]: \"RecsType.BigInt\",\n  [SchemaType.INT192]: \"RecsType.BigInt\",\n  [SchemaType.INT200]: \"RecsType.BigInt\",\n  [SchemaType.INT208]: \"RecsType.BigInt\",\n  [SchemaType.INT216]: \"RecsType.BigInt\",\n  [SchemaType.INT224]: \"RecsType.BigInt\",\n  [SchemaType.INT232]: \"RecsType.BigInt\",\n  [SchemaType.INT240]: \"RecsType.BigInt\",\n  [SchemaType.INT248]: \"RecsType.BigInt\",\n  [SchemaType.INT256]: \"RecsType.BigInt\",\n  [SchemaType.BYTES1]: \"RecsType.String\",\n  [SchemaType.BYTES2]: \"RecsType.String\",\n  [SchemaType.BYTES3]: \"RecsType.String\",\n  [SchemaType.BYTES4]: \"RecsType.String\",\n  [SchemaType.BYTES5]: \"RecsType.String\",\n  [SchemaType.BYTES6]: \"RecsType.String\",\n  [SchemaType.BYTES7]: \"RecsType.String\",\n  [SchemaType.BYTES8]: \"RecsType.String\",\n  [SchemaType.BYTES9]: \"RecsType.String\",\n  [SchemaType.BYTES10]: \"RecsType.String\",\n  [SchemaType.BYTES11]: \"RecsType.String\",\n  [SchemaType.BYTES12]: \"RecsType.String\",\n  [SchemaType.BYTES13]: \"RecsType.String\",\n  [SchemaType.BYTES14]: \"RecsType.String\",\n  [SchemaType.BYTES15]: \"RecsType.String\",\n  [SchemaType.BYTES16]: \"RecsType.String\",\n  [SchemaType.BYTES17]: \"RecsType.String\",\n  [SchemaType.BYTES18]: \"RecsType.String\",\n  [SchemaType.BYTES19]: \"RecsType.String\",\n  [SchemaType.BYTES20]: \"RecsType.String\",\n  [SchemaType.BYTES21]: \"RecsType.String\",\n  [SchemaType.BYTES22]: \"RecsType.String\",\n  [SchemaType.BYTES23]: \"RecsType.String\",\n  [SchemaType.BYTES24]: \"RecsType.String\",\n  [SchemaType.BYTES25]: \"RecsType.String\",\n  [SchemaType.BYTES26]: \"RecsType.String\",\n  [SchemaType.BYTES27]: \"RecsType.String\",\n  [SchemaType.BYTES28]: \"RecsType.String\",\n  [SchemaType.BYTES29]: \"RecsType.String\",\n  [SchemaType.BYTES30]: \"RecsType.String\",\n  [SchemaType.BYTES31]: \"RecsType.String\",\n  [SchemaType.BYTES32]: \"RecsType.String\",\n  [SchemaType.BOOL]: \"RecsType.Boolean\",\n  [SchemaType.ADDRESS]: \"RecsType.String\",\n  [SchemaType.UINT8_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.UINT16_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.UINT24_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.UINT32_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.UINT40_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.UINT48_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.UINT56_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT64_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT72_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT80_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT88_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT96_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT104_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT112_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT120_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT128_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT136_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT144_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT152_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT160_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT168_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT176_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT184_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT192_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT200_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT208_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT216_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT224_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT232_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT240_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT248_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.UINT256_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT8_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.INT16_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.INT24_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.INT32_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.INT40_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.INT48_ARRAY]: \"RecsType.NumberArray\",\n  [SchemaType.INT56_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT64_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT72_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT80_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT88_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT96_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT104_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT112_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT120_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT128_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT136_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT144_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT152_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT160_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT168_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT176_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT184_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT192_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT200_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT208_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT216_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT224_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT232_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT240_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT248_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.INT256_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES1_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES2_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES3_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES4_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES5_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES6_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES7_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES8_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES9_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES10_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES11_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES12_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES13_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES14_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES15_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES16_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES17_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES18_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES19_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES20_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES21_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES22_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES23_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES24_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES25_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES26_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES27_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES28_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES29_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES30_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES31_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BYTES32_ARRAY]: \"RecsType.BigIntArray\",\n  [SchemaType.BOOL_ARRAY]: \"RecsType.T\", // no boolean array\n  [SchemaType.ADDRESS_ARRAY]: \"RecsType.StringArray\",\n  [SchemaType.BYTES]: \"RecsType.String\",\n  [SchemaType.STRING]: \"RecsType.String\",\n};\n"],"mappings":"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CpB,CAACA,EAAW,KAAK,EAAG,kBACpB,CAACA,EAAW,KAAK,EAAG,kBACpB,CAACA,EAAW,KAAK,EAAG,kBACpB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,MAAM,EAAG,kBACrB,CAACA,EAAW,OAAO,EAAG,kBACtB,CAACA,EAAW,OAAO,EAAG,kBACtB,CAACA,EAAW,OAAO,EAAG,kBACtB,CAACA,EAAW,OAAO,EAAG,kBACtB,CAACA,EAAW,OAAO,EAAG,kBACtB,CAACA,EAAW,OAAO,EAAG,kBACtB,CAACA,EAAW,OAAO,EAAG,kBACtB,CAACA,EAAW,OAAO,EAAG,kBACtB,CAACA,EAAW,OAAO,EAAG,kBACtB,CAACA,EAAW,OAAO,EAAG,kBACtB,CAACA,EAAW,OAAO,EAAG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","names":["path","parse","visit","contractToInterface","data","contractName","ast","parse","withContract","symbolImports","functions","errors","visit","name","visibility","parameters","stateMutability","returnParameters","isConstructor","isFallback","isReceiveEther","parent","MUDError","parseParameter","typeName","symbols","typeNameToSymbols","symbolsToImports","error","parameter","storageLocation","typedNameWithLocation","flattenedTypeName","flattenTypeName","length","innerTypeName","imports","symbol","symbolImport","path","symbolAliases","symbolAndAlias","symbolAlias","parse","visit","extractUserTypes","data","userTypeNames","fromPath","ast","parse","isRelativePath","userDefinedTypes","visit","name","definition","parent","MUDError","chalk","prettier","prettierPluginSolidity","formatSolidity","content","prettierConfigPath","config","error","message","formatTypescript","mkdirSync","writeFileSync","dirname","formatAndWriteSolidity","output","fullOutputPath","logPrefix","formattedOutput","formatSolidity","mkdirSync","dirname","writeFileSync","formatAndWriteTypescript","formatTypescript","readFileSync","path","loadAndExtractUserTypes","userTypes","outputBaseDirectory","remappings","userTypesPerFile","userTypeName","unresolvedFilePath","extractedUserTypes","userTypeNames","filePath","data","loadUserTypesFile","userTypesInFile","extractUserTypes","userType","MUDError","path","readFileSync","remappedFilePath","from","to","posixPath","path","renderedSolidityHeader","renderList","list","renderItem","internalRenderList","renderArguments","args","filteredArgs","arg","renderCommonData","staticResourceData","keyTuple","_tableId","_typedTableId","_keyArgs","name","_typedKeyArgs","typeWithLocation","_keyTupleDefinition","key","index","renderValueTypeToBytes32","solidityRelativeImportPath","fromPath","usedInPath","posixPath","path","renderImports","imports","renderAbsoluteImports","importDatum","renderRelativeImports","symbol","aggregatedImports","renderedImports","symbols","renderedSymbols","renderWithStore","storeArgument","callback","result","renderWithFieldSuffix","withSuffixlessFieldMethods","fieldName","methodNameSuffix","renderTableId","namespace","offchainOnly","tableIdName","hardcodedTableId","tableIdDefinition","typeUnwrap","internalTypeId","innerText","isLeftAligned","field","getLeftPaddingBits","lineTerminator","item","renderEnums","enums","result","renderedSolidityHeader","renderList","name","memberNames","renderArguments","renderTypeHelpers","options","fields","keyTuple","result","wrappingHelper","getWrappingHelpers","internalTypeId","array","wrappers","unwrappers","typeWrappingData","typeWrap","typeUnwrap","kind","elementType","staticLength","renderWrapperStaticArray","renderUnwrapperStaticArray","functionName","byteLength","SchemaType","schemaTypesToRecsTypeStrings"]}