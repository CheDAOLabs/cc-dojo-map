import{privateKeyToAccount as k}from"viem/accounts";function L(e){return{...k(e)}}import{getContract as E}from"viem";import $ from"p-retry";import{BaseError as I,NonceTooHighError as M,NonceTooLowError as O}from"viem";import v from"debug";var m=v("mud:common");var P=m.extend("createNonceManager");function w({publicClient:e,address:t,blockTag:r}){let n={current:-1},o=typeof BroadcastChannel<"u"?new BroadcastChannel(`mud:createNonceManager:${e.chain?.id}:${t}`):null;o&&o.addEventListener("message",a=>{let p=JSON.parse(a.data);P("got nonce from broadcast channel",p),n.current=p});function c(){return n.current>=0}function l(){if(!c())throw new Error("call resetNonce before using nextNonce");let a=n.current++;return o?.postMessage(JSON.stringify(n.current)),a}async function u(){let a=await e.getTransactionCount({address:t,blockTag:r});n.current=a,o?.postMessage(JSON.stringify(n.current)),P("reset nonce to",n.current)}function y(a){return a instanceof I&&a.walk(p=>p instanceof O||p instanceof M)!=null}return{hasNonce:c,nextNonce:l,resetNonce:u,shouldResetNonce:y}}var d=m.extend("createContract");function S(e){let t=e.length&&Array.isArray(e[0]),r=t?e[0]:[],n=(t?e[1]:e[0])??{};return{args:r,options:n}}function ye({abi:e,address:t,publicClient:r,walletClient:n,onWrite:o}){let c=E({abi:e,address:t,publicClient:r,walletClient:n});if(c.write){let l=0,u=w({publicClient:r,address:n.account.address});c.write=new Proxy({},{get(y,a){async function p(s){if(s.gas)return d("gas provided, skipping simulate",a,s),s;d("simulating write",a,s);let{request:T}=await r.simulateContract({...s,account:s.account??n.account});return T}async function R(s){let T=await p(s);return await $(async()=>{u.hasNonce()||await u.resetNonce();let i=u.nextNonce();return d("calling write function with nonce",i,T),await n.writeContract({nonce:i,...T})},{retries:3,onFailedAttempt:async i=>{if(u.shouldResetNonce(i)){d("got nonce error, retrying",i),await u.resetNonce();return}throw i}})}return(...s)=>{let T=`${n.chain.id}:${n.account.address}:${l++}`,{args:i,options:W}=S(s),A={address:t,abi:e,functionName:a,args:i,...W},h=R(A);return o?.({id:T,request:A,result:h}),h}}})}return c}import{generatePrivateKey as B,privateKeyToAccount as H}from"viem/accounts";import{isHex as G}from"viem";function q(e,t){if(!G(e))throw console.error("Private key found in cache is not valid hex",{privateKey:e,cacheKey:t}),new Error(`Private key found in cache (${t}) is not valid hex`);H(e)}function He(e="mud:burnerWallet"){let t=localStorage.getItem(e);if(t!=null)return q(t,e),t;let r=B();return console.log("New burner wallet created:",H(r)),localStorage.setItem(e,r),r}import{hexToString as C,sliceHex as b}from"viem";var N=["table","offchainTable","namespace","module","system"];import{stringToHex as f,concatHex as j}from"viem";var x={table:"tb",offchainTable:"ot",namespace:"ns",module:"md",system:"sy"};function ve(e){let t=x[e.type];return j([f(t,{size:2}),f(e.namespace.slice(0,14),{size:14}),f(e.name.slice(0,16),{size:16})])}var D=Object.fromEntries(Object.entries(x).map(([e,t])=>[t,e]));function z(e){let t=D[e];if(N.includes(t))return t}function Be(e){let t=C(b(e,0,2)).replace(/\0+$/,""),r=z(t),n=C(b(e,2,16)).replace(/\0+$/,""),o=C(b(e,16,32)).replace(/\0+$/,"");if(!r)throw new Error(`Unknown resource type: ${t}`);return{type:r,namespace:n,name:o}}function g(e,t,r){return`0x${e.replace(/^0x/,"").slice(t*2,r!=null?r*2:void 0).padEnd(((r??t)-t)*2,"0")}`}import{concatHex as J}from"viem";function Je(e,t,r=0,n="0x"){return J([g(e,0,t),n,g(e,t+r)])}import{keccak256 as K}from"viem";var U=m.extend("transportObserver");function Qe(e){return t=>{let r=e(t);return{...r,request:async o=>{if(o.method==="eth_sendRawTransaction"&&o.params instanceof Array){let c=o.params.map(l=>K(l));U("saw txs",c)}return r.request(o)}}}}export{L as createBurnerAccount,ye as createContract,w as createNonceManager,He as getBurnerPrivateKey,Be as hexToResourceId,g as readHex,ve as resourceIdToHex,x as resourceTypeIds,N as resourceTypes,Je as spliceHex,Qe as transportObserver};
//# sourceMappingURL=index.js.map