import {useDojo} from './DojoContext';import {useComponentValue} from "@dojoengine/react";import {Direction,} from './dojo/createSystemCalls'import {EntityIndex, setComponent} from '@latticexyz/recs';import {useEffect, useState} from 'react';import {getFirstComponentByType} from './utils';import {Moves, Position} from './generated/graphql';import {Simulate} from "react-dom/test-utils";import durationChange = Simulate.durationChange;import load = Simulate.load;import {Button, message, ConfigProvider, theme, Input, Select, Spin, InputNumber, Steps} from 'antd';import {Provider, Contract, constants, shortString, num} from "starknet";const coin = "<span class='sk'>ðŸª™</span>";const door  = "<span class='sk'>ðŸšª</span>";const address = "0x078fcf70e22f475b8ffde567f8118e5d99ded383da150e01e55fa79251c7c808"const abi = [    {        "name": "ERC721Enumerable",        "type": "impl",        "interface_name": "cc_starknet::IERC721Enumerable"    },    {        "name": "core::integer::u256",        "type": "struct",        "members": [            {                "name": "low",                "type": "core::integer::u128"            },            {                "name": "high",                "type": "core::integer::u128"            }        ]    },    {        "name": "cc_starknet::IERC721Enumerable",        "type": "interface",        "items": [            {                "name": "total_supply",                "type": "function",                "inputs": [],                "outputs": [                    {                        "type": "core::integer::u256"                    }                ],                "state_mutability": "view"            },            {                "name": "token_by_index",                "type": "function",                "inputs": [                    {                        "name": "index",                        "type": "core::integer::u256"                    }                ],                "outputs": [                    {                        "type": "core::integer::u256"                    }                ],                "state_mutability": "view"            },            {                "name": "token_of_owner_by_index",                "type": "function",                "inputs": [                    {                        "name": "owner",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "index",                        "type": "core::integer::u256"                    }                ],                "outputs": [                    {                        "type": "core::integer::u256"                    }                ],                "state_mutability": "view"            }        ]    },    {        "name": "ERC721EnumerableCamelOnly",        "type": "impl",        "interface_name": "cc_starknet::IERC721EnumerableCamelOnly"    },    {        "name": "cc_starknet::IERC721EnumerableCamelOnly",        "type": "interface",        "items": [            {                "name": "totalSupply",                "type": "function",                "inputs": [],                "outputs": [                    {                        "type": "core::integer::u256"                    }                ],                "state_mutability": "view"            },            {                "name": "tokenByIndex",                "type": "function",                "inputs": [                    {                        "name": "index",                        "type": "core::integer::u256"                    }                ],                "outputs": [                    {                        "type": "core::integer::u256"                    }                ],                "state_mutability": "view"            },            {                "name": "tokenOfOwnerByIndex",                "type": "function",                "inputs": [                    {                        "name": "owner",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "index",                        "type": "core::integer::u256"                    }                ],                "outputs": [                    {                        "type": "core::integer::u256"                    }                ],                "state_mutability": "view"            }        ]    },    {        "name": "ERC721Impl",        "type": "impl",        "interface_name": "openzeppelin::token::erc721::interface::IERC721"    },    {        "name": "core::array::Span::<core::felt252>",        "type": "struct",        "members": [            {                "name": "snapshot",                "type": "@core::array::Array::<core::felt252>"            }        ]    },    {        "name": "core::bool",        "type": "enum",        "variants": [            {                "name": "False",                "type": "()"            },            {                "name": "True",                "type": "()"            }        ]    },    {        "name": "openzeppelin::token::erc721::interface::IERC721",        "type": "interface",        "items": [            {                "name": "balance_of",                "type": "function",                "inputs": [                    {                        "name": "account",                        "type": "core::starknet::contract_address::ContractAddress"                    }                ],                "outputs": [                    {                        "type": "core::integer::u256"                    }                ],                "state_mutability": "view"            },            {                "name": "owner_of",                "type": "function",                "inputs": [                    {                        "name": "token_id",                        "type": "core::integer::u256"                    }                ],                "outputs": [                    {                        "type": "core::starknet::contract_address::ContractAddress"                    }                ],                "state_mutability": "view"            },            {                "name": "transfer_from",                "type": "function",                "inputs": [                    {                        "name": "from",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "to",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "token_id",                        "type": "core::integer::u256"                    }                ],                "outputs": [],                "state_mutability": "external"            },            {                "name": "safe_transfer_from",                "type": "function",                "inputs": [                    {                        "name": "from",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "to",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "token_id",                        "type": "core::integer::u256"                    },                    {                        "name": "data",                        "type": "core::array::Span::<core::felt252>"                    }                ],                "outputs": [],                "state_mutability": "external"            },            {                "name": "approve",                "type": "function",                "inputs": [                    {                        "name": "to",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "token_id",                        "type": "core::integer::u256"                    }                ],                "outputs": [],                "state_mutability": "external"            },            {                "name": "set_approval_for_all",                "type": "function",                "inputs": [                    {                        "name": "operator",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "approved",                        "type": "core::bool"                    }                ],                "outputs": [],                "state_mutability": "external"            },            {                "name": "get_approved",                "type": "function",                "inputs": [                    {                        "name": "token_id",                        "type": "core::integer::u256"                    }                ],                "outputs": [                    {                        "type": "core::starknet::contract_address::ContractAddress"                    }                ],                "state_mutability": "view"            },            {                "name": "is_approved_for_all",                "type": "function",                "inputs": [                    {                        "name": "owner",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "operator",                        "type": "core::starknet::contract_address::ContractAddress"                    }                ],                "outputs": [                    {                        "type": "core::bool"                    }                ],                "state_mutability": "view"            }        ]    },    {        "name": "ERC721MetadataImpl",        "type": "impl",        "interface_name": "cc_starknet::IERC721Metadata"    },    {        "name": "cc_starknet::IERC721Metadata",        "type": "interface",        "items": [            {                "name": "name",                "type": "function",                "inputs": [],                "outputs": [                    {                        "type": "core::felt252"                    }                ],                "state_mutability": "view"            },            {                "name": "symbol",                "type": "function",                "inputs": [],                "outputs": [                    {                        "type": "core::felt252"                    }                ],                "state_mutability": "view"            },            {                "name": "token_uri",                "type": "function",                "inputs": [                    {                        "name": "token_id",                        "type": "core::integer::u256"                    }                ],                "outputs": [                    {                        "type": "core::array::Array::<core::felt252>"                    }                ],                "state_mutability": "view"            }        ]    },    {        "name": "ERC721MetadataCamelOnlyImpl",        "type": "impl",        "interface_name": "cc_starknet::IERC721MetadataCamelOnly"    },    {        "name": "cc_starknet::IERC721MetadataCamelOnly",        "type": "interface",        "items": [            {                "name": "tokenURI",                "type": "function",                "inputs": [                    {                        "name": "tokenId",                        "type": "core::integer::u256"                    }                ],                "outputs": [                    {                        "type": "core::array::Array::<core::felt252>"                    }                ],                "state_mutability": "view"            }        ]    },    {        "name": "ERC721CamelOnlyImpl",        "type": "impl",        "interface_name": "openzeppelin::token::erc721::interface::IERC721CamelOnly"    },    {        "name": "openzeppelin::token::erc721::interface::IERC721CamelOnly",        "type": "interface",        "items": [            {                "name": "balanceOf",                "type": "function",                "inputs": [                    {                        "name": "account",                        "type": "core::starknet::contract_address::ContractAddress"                    }                ],                "outputs": [                    {                        "type": "core::integer::u256"                    }                ],                "state_mutability": "view"            },            {                "name": "ownerOf",                "type": "function",                "inputs": [                    {                        "name": "tokenId",                        "type": "core::integer::u256"                    }                ],                "outputs": [                    {                        "type": "core::starknet::contract_address::ContractAddress"                    }                ],                "state_mutability": "view"            },            {                "name": "transferFrom",                "type": "function",                "inputs": [                    {                        "name": "from",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "to",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "tokenId",                        "type": "core::integer::u256"                    }                ],                "outputs": [],                "state_mutability": "external"            },            {                "name": "safeTransferFrom",                "type": "function",                "inputs": [                    {                        "name": "from",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "to",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "tokenId",                        "type": "core::integer::u256"                    },                    {                        "name": "data",                        "type": "core::array::Span::<core::felt252>"                    }                ],                "outputs": [],                "state_mutability": "external"            },            {                "name": "setApprovalForAll",                "type": "function",                "inputs": [                    {                        "name": "operator",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "approved",                        "type": "core::bool"                    }                ],                "outputs": [],                "state_mutability": "external"            },            {                "name": "getApproved",                "type": "function",                "inputs": [                    {                        "name": "tokenId",                        "type": "core::integer::u256"                    }                ],                "outputs": [                    {                        "type": "core::starknet::contract_address::ContractAddress"                    }                ],                "state_mutability": "view"            },            {                "name": "isApprovedForAll",                "type": "function",                "inputs": [                    {                        "name": "owner",                        "type": "core::starknet::contract_address::ContractAddress"                    },                    {                        "name": "operator",                        "type": "core::starknet::contract_address::ContractAddress"                    }                ],                "outputs": [                    {                        "type": "core::bool"                    }                ],                "state_mutability": "view"            }        ]    },    {        "name": "mint",        "type": "function",        "inputs": [],        "outputs": [],        "state_mutability": "external"    },    {        "name": "supports_interface",        "type": "function",        "inputs": [            {                "name": "interface_id",                "type": "core::felt252"            }        ],        "outputs": [            {                "type": "core::bool"            }        ],        "state_mutability": "view"    },    {        "name": "supportsInterface",        "type": "function",        "inputs": [            {                "name": "interfaceId",                "type": "core::felt252"            }        ],        "outputs": [            {                "type": "core::bool"            }        ],        "state_mutability": "view"    },    {        "name": "get_seeds",        "type": "function",        "inputs": [            {                "name": "token_id",                "type": "core::integer::u256"            }        ],        "outputs": [            {                "type": "core::integer::u256"            }        ],        "state_mutability": "view"    },    {        "name": "token_URI",        "type": "function",        "inputs": [            {                "name": "token_id",                "type": "core::integer::u256"            }        ],        "outputs": [            {                "type": "core::array::Array::<core::felt252>"            }        ],        "state_mutability": "view"    },    {        "name": "get_svg",        "type": "function",        "inputs": [            {                "name": "token_id",                "type": "core::integer::u256"            }        ],        "outputs": [            {                "type": "core::array::Array::<core::felt252>"            }        ],        "state_mutability": "view"    },    {        "name": "cc_starknet::utils::pack::Pack",        "type": "struct",        "members": [            {                "name": "first",                "type": "core::felt252"            },            {                "name": "second",                "type": "core::felt252"            },            {                "name": "third",                "type": "core::felt252"            }        ]    },    {        "name": "core::array::Span::<core::integer::u8>",        "type": "struct",        "members": [            {                "name": "snapshot",                "type": "@core::array::Array::<core::integer::u8>"            }        ]    },    {        "name": "cc_starknet::Dungeons::EntityDataSerde",        "type": "struct",        "members": [            {                "name": "x",                "type": "core::array::Span::<core::integer::u8>"            },            {                "name": "y",                "type": "core::array::Span::<core::integer::u8>"            },            {                "name": "entity_data",                "type": "core::array::Span::<core::integer::u8>"            }        ]    },    {        "name": "cc_starknet::Dungeons::DungeonSerde",        "type": "struct",        "members": [            {                "name": "size",                "type": "core::integer::u8"            },            {                "name": "environment",                "type": "core::integer::u8"            },            {                "name": "structure",                "type": "core::integer::u8"            },            {                "name": "legendary",                "type": "core::integer::u8"            },            {                "name": "layout",                "type": "cc_starknet::utils::pack::Pack"            },            {                "name": "entities",                "type": "cc_starknet::Dungeons::EntityDataSerde"            },            {                "name": "affinity",                "type": "core::felt252"            },            {                "name": "dungeon_name",                "type": "core::array::Span::<core::felt252>"            }        ]    },    {        "name": "generate_dungeon",        "type": "function",        "inputs": [            {                "name": "token_id",                "type": "core::integer::u256"            }        ],        "outputs": [            {                "type": "cc_starknet::Dungeons::DungeonSerde"            }        ],        "state_mutability": "view"    },    {        "name": "get_entities",        "type": "function",        "inputs": [            {                "name": "token_id",                "type": "core::integer::u256"            }        ],        "outputs": [            {                "type": "cc_starknet::Dungeons::EntityDataSerde"            }        ],        "state_mutability": "view"    },    {        "name": "get_layout",        "type": "function",        "inputs": [            {                "name": "seed",                "type": "core::integer::u256"            },            {                "name": "size",                "type": "core::integer::u128"            }        ],        "outputs": [            {                "type": "(cc_starknet::utils::pack::Pack, core::integer::u8)"            }        ],        "state_mutability": "view"    },    {        "name": "get_size",        "type": "function",        "inputs": [            {                "name": "token_id",                "type": "core::integer::u256"            }        ],        "outputs": [            {                "type": "core::integer::u128"            }        ],        "state_mutability": "view"    },    {        "name": "get_environment",        "type": "function",        "inputs": [            {                "name": "token_id",                "type": "core::integer::u256"            }        ],        "outputs": [            {                "type": "core::integer::u8"            }        ],        "state_mutability": "view"    },    {        "name": "get_name",        "type": "function",        "inputs": [            {                "name": "token_id",                "type": "core::integer::u256"            }        ],        "outputs": [            {                "type": "(core::array::Array::<core::felt252>, core::felt252, core::integer::u8)"            }        ],        "state_mutability": "view"    },    {        "name": "constructor",        "type": "constructor",        "inputs": []    },    {        "kind": "struct",        "name": "cc_starknet::Dungeons::Minted",        "type": "event",        "members": [            {                "kind": "key",                "name": "account",                "type": "core::starknet::contract_address::ContractAddress"            },            {                "kind": "data",                "name": "token_id",                "type": "core::integer::u256"            }        ]    },    {        "kind": "struct",        "name": "cc_starknet::Dungeons::Transfer",        "type": "event",        "members": [            {                "kind": "key",                "name": "from",                "type": "core::starknet::contract_address::ContractAddress"            },            {                "kind": "key",                "name": "to",                "type": "core::starknet::contract_address::ContractAddress"            },            {                "kind": "key",                "name": "token_id",                "type": "core::integer::u256"            }        ]    },    {        "kind": "struct",        "name": "cc_starknet::Dungeons::Approval",        "type": "event",        "members": [            {                "kind": "key",                "name": "owner",                "type": "core::starknet::contract_address::ContractAddress"            },            {                "kind": "key",                "name": "approved",                "type": "core::starknet::contract_address::ContractAddress"            },            {                "kind": "key",                "name": "token_id",                "type": "core::integer::u256"            }        ]    },    {        "kind": "struct",        "name": "cc_starknet::Dungeons::ApprovalForAll",        "type": "event",        "members": [            {                "kind": "key",                "name": "owner",                "type": "core::starknet::contract_address::ContractAddress"            },            {                "kind": "key",                "name": "operator",                "type": "core::starknet::contract_address::ContractAddress"            },            {                "kind": "data",                "name": "approved",                "type": "core::bool"            }        ]    },    {        "kind": "enum",        "name": "cc_starknet::Dungeons::Event",        "type": "event",        "variants": [            {                "kind": "nested",                "name": "Minted",                "type": "cc_starknet::Dungeons::Minted"            },            {                "kind": "nested",                "name": "Transfer",                "type": "cc_starknet::Dungeons::Transfer"            },            {                "kind": "nested",                "name": "Approval",                "type": "cc_starknet::Dungeons::Approval"            },            {                "kind": "nested",                "name": "ApprovalForAll",                "type": "cc_starknet::Dungeons::ApprovalForAll"            }        ]    }];const provider = new Provider({sequencer: {network: constants.NetworkName.SN_GOERLI}});const contract = new Contract(abi, address, provider)const decode_string = (array: any) => {    let result = "";    for (let i = 0; i < array.length; i++) {        let temp = shortString.decodeShortString(array[i]);        // console.log("temp:", temp);        result += temp;    }    return result;};const decode_map = (layout: any, size: any) => {    // eslint-disable-next-line    let layoutIntFirst = BigInt(layout.first).toString(2).padStart(248, '0');    // eslint-disable-next-line    let layoutIntSecond = BigInt(layout.second).toString(2);    // eslint-disable-next-line    let layoutIntThird = BigInt(layout.third).toString(2);    let bits = layoutIntFirst + layoutIntSecond + layoutIntThird;    console.log("bits", bits);    // Store dungeon in 2D array    let dungeon = [];    // let grid = []    let counter = 0;    for (let y = 0; y < size; y++) {        let row = []        // let grid_row = [];        for (let x = 0; x < size; x++) {            // eslint-disable-next-line            const bit = bits[counter] == '1' ? '<span class="bl"> </span>' : '<span class="bl">X</span>';            row.push(bit)            // grid_row.push(bits[counter] == 1 ? 0 : 1);            counter++;        }        dungeon.push(row)        // grid.push(grid_row);    }    return dungeon;}function App() {    const {        setup: {            systemCalls: {spawn, move},            components: {Moves, Position},            network: {graphSdk, call}        },        account: {create, list, select, account, isDeploying}    } = useDojo();    // entity id - this example uses the account address as the entity id    const entityId = account.address;    // get current component values    const position = useComponentValue(Position, parseInt(entityId.toString()) as EntityIndex);    const moves = useComponentValue(Moves, parseInt(entityId.toString()) as EntityIndex);    useEffect(() => {        if (!entityId) return;        const fetchData = async () => {            const {data} = await graphSdk.getEntities();            if (data) {                const remaining = getFirstComponentByType(data.entities?.edges, 'Moves') as Moves;                const position = getFirstComponentByType(data.entities?.edges, 'Position') as Position;                setComponent(Moves, parseInt(entityId.toString()) as EntityIndex, {remaining: remaining.remaining})                setComponent(Position, parseInt(entityId.toString()) as EntityIndex, {x: position.x, y: position.y})            }        }        fetchData();    }, [account.address]);    const [mapData, setMapData] = useState([        [            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            "X",            " ",            " ",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            "X",            " ",            " ",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            " ",            " ",            " ",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            " ",            " ",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            "X",            "X"        ],        [            "X",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            " ",            "X",            "X",            "X",            "X"        ],        [            "X",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            "X",            "X",            " ",            "X",            "X",            "X",            "X",            " ",            "X",            "X",            "X",            "X"        ],        [            "X",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            "X",            "X",            " ",            "X",            "X",            "X",            "X",            " ",            "X",            "X",            "X",            "X"        ],        [            "X",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            "X",            "X",            " ",            "X",            "X",            "X",            "X",            " ",            "X",            "X",            "X",            "X"        ],        [            "X",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            "X",            "X",            " ",            "X",            "X",            "X",            "X",            " ",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            "X",            "X",            "X",            " ",            " ",            "X",            "X",            "X",            "X",            " ",            "X",            "X",            "X",            " ",            " ",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            "X",            "X",            "X",            "X",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            "X",            "X",            "X",            " ",            " ",            "X",            "X",            "X",            "X",            " ",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            "X",            "X",            "X",            " ",            " ",            " ",            " ",            " ",            " ",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ],        [            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X",            "X"        ]    ]);    const [tokenId, setTokenId] = useState(2);    const [mapName, setMapName] = useState("loading...")    const [owner, setOwner] = useState("0x...")    const onChangeTokenId = async (value: number) => {        console.log('changed', value);        setTokenId(value);        await loadMap(value)    };    const [loading, setLoading] = useState(false);    const [loadingSvg, setLoadingSvg] = useState(false);    const [svg, setSvg] = useState("");    const [entities, setEntities] = useState(null);    const loadMap = async (token_id) => {        setLoading(true);        setLoadingSvg(true);        console.log("loading:" + token_id)        const owner_num = await contract.owner_of(token_id);        const dungeon_data = await contract.generate_dungeon(token_id);        console.log("dungeon", dungeon_data);        const size = Number(dungeon_data.size);        const entities_data = dungeon_data.entities;        setEntities(entities_data);        console.log('entities', entities);        const dungeon_name = dungeon_data.dungeon_name;        const layout = dungeon_data.layout;        const map = decode_map(layout, size);        const name = decode_string(dungeon_name);        console.log("map", map)        console.log("name", name)        const owner = num.toHex(owner_num)        console.log("owner", owner);        setOwner(owner.substring(0, 5) + '...' + owner.substring(owner.length - 5, owner.length));        setMapName(name);        setMapData(map)        setLoading(false)        const svg_data = await contract.get_svg(token_id);        console.log("svg", svg_data)        setSvg(decode_string(svg_data))        setLoadingSvg(false);    }    const render = () => {        let rowString = ""        if (!position) {            return rowString;        }        let dungeon = JSON.parse(JSON.stringify(mapData));        console.log("x,y", position.x, position.y)        if (dungeon[0].length < position.x || dungeon.length < position.y) {            console.log("a")            return rowString;        }        dungeon[position.y][position.x] = "<span class='sk'>ðŸ’€</span>";        if (entities != null ) {            if (entities.entity_data.length > 0) {                for (let i = 0; i < entities.entity_data.length; i++) {                    let entity = {                        x: entities.x[i],                        y: entities.y[i],                        entityType: entities.entity_data[i]                    }                    // entityList.push(entity)                    // Update dungeon with our entity                    if (entity.entityType == 1) {                        // Place a door                        dungeon[entity.y][entity.x] = coin;                    } else if (entity.entityType == 0) {                        // Place a point of interest                        dungeon[entity.y][entity.x] = door;                    }                }            }        }        for (let y = 0; y < dungeon.length; y++) {            for (let x = 0; x < dungeon.length; x++) {                const tile = dungeon[y][x]                rowString += `${tile} `            }            rowString += '\n'        }        return (rowString)    };    // const [map, setMap] = useState(render());    const isCollision = (x: any, y: any) => {        const res = mapData[y][x] != '<span class="bl"> </span>';        return res;    }    useEffect(() => {        async function handleKeyDown(event: any) {            console.log("handle KeyDown:", event.key)            if (event.key === 'w') {                await cc_move(account, Direction.Up)            }            if (event.key === 's') {                await cc_move(account, Direction.Down)            }            if (event.key === 'a') {                await cc_move(account, Direction.Left)            }            if (event.key === 'd') {                await cc_move(account, Direction.Right)            }        }        window.addEventListener('keydown', handleKeyDown);        return () => {            window.removeEventListener('keydown', handleKeyDown);        };    }, [position]);    useEffect(() => {        loadMap(tokenId);    }, []);    const [messageApi, contextHolder] = message.useMessage();    const cc_move = async (account: any, direction: any) => {        if (loading) {            messageApi.open({                type: 'warning',                content: 'This is a success message',            });            return;        }        setLoading(true);        if (direction == Direction.Up) {            if (isCollision(position.x, position.y - 1)) {                console.log("is collision")                setLoading(false);                return            }        }        if (direction == Direction.Down) {            if (isCollision(position.x, position.y + 1)) {                console.log("is collision")                setLoading(false);                return            }        }        if (direction == Direction.Left) {            if (isCollision(position.x - 1, position.y)) {                console.log("is collision")                setLoading(false);                return            }        }        if (direction == Direction.Right) {            if (isCollision(position.x + 1, position.y)) {                console.log("is collision")                setLoading(false);                return            }        }        await move(account, direction)        setLoading(false);    }    const {darkAlgorithm} = theme;    return (        <ConfigProvider            theme={{                algorithm: darkAlgorithm,            }}>            <div style={{"width": "1000px"}}>                <Button onClick={create}>{isDeploying ? "deploying burner" : "create burner"}</Button>                <div className="card">                    select signer:{" "}                    <Select onChange={e => select(e.target.value)}>                        {list().map((account, index) => {                            return <option value={account.address} key={index}>{account.address}</option>                        })}                    </Select>                </div>                <div className="card">                    <Button onClick={() => spawn(account)}>Spawn</Button>                    <div>Moves Left: {moves ? `${moves['remaining']}` : 'Need to Spawn'}</div>                    <div>Position: {position ? `${position['x']}, ${position['y']}` : 'Need to Spawn'}</div>                </div>                <div className="card"                     style={{                         padding: 0,                         backgroundColor: "black",                         width: "650px",                         height: "650px",                         float: "left",                         display: "flex",                         alignItems: "center",                         alignContent: "center"                     }}>                    <div className="container">                        <div className="div1">                            {loading ? (<div style={{                                position: "relative",                                textAlign: "center",                                width: "650px",                                height: "650px",                                backgroundColor: "rgba(0, 0, 0, 0.5)"                            }}>                                <Spin style={{                                    position: "absolute",                                    top: "50%",                                    left: "50%",                                    transform: "translate(-50%,-50%)"                                }}/></div>) : <></>}                        </div>                        <div className="div2">                            <div style={{display: "flex", alignItems: "center", height: "650px"}}>                                <pre style={{}} className=" MapPre" dangerouslySetInnerHTML={{__html: render()}}></pre>                            </div>                        </div>                    </div>                </div>                <div className="card" style={{"float": "right"}}>                    <div>                        {loadingSvg ?                            <p>tokenId: <InputNumber disabled={true} min={1} max={10000} defaultValue={1}                                                     value={tokenId}                                                     onChange={onChangeTokenId}/></p>                            :                            <p>tokenId: <InputNumber min={1} max={10000} defaultValue={1} value={tokenId}                                                     onChange={onChangeTokenId}/></p>                        }                        <p>name: {mapName}</p>                        <p>owner: {owner}</p>                    </div>                    <br/>                    <br/>                    {loadingSvg ?                        <Spin>                            <div dangerouslySetInnerHTML={{__html: svg}}></div>                        </Spin>                        :                        <div dangerouslySetInnerHTML={{__html: svg}}></div>                    }                    <br/>                    <br/>                    <Button onClick={() => cc_move(account, Direction.Up)}>Move Up                    </Button>                    <br/>                    <Button onClick={() => cc_move(account, Direction.Left)}>Move Left</Button>                    <Button onClick={() => cc_move(account, Direction.Right)}>Move Right</Button>                    <br/>                    <Button onClick={() => cc_move(account, Direction.Down)}>Move Down</Button>                </div>            </div>        </ConfigProvider>    );}export default App;